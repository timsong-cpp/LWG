<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p>Revised 2024-05-14 at 00:51:20 UTC
</p><h2>Tentative Issues</h2>
<hr>
<h3 id="2457"><a href="#2457">2457</a><sup><a href="https://cplusplus.github.io/LWG/issue2457">(i)</a></sup>. <code>std::begin()</code> and <code>std::end()</code> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2023-04-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<code>begin</code>, <code>end</code>, <code>rbegin</code>, and <code>rend</code> to 25.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>

<p><i>[2023-04-06; LWG reflector poll in November 2021]</i></p>

<p>
Changed to Tentatively NAD after 12 votes in favour.
Use <code>views::join</code> or <code>mdspan</code> instead.
</p>



<p id="res-2457"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3635"><a href="#3635">3635</a><sup><a href="https://cplusplus.github.io/LWG/issue3635">(i)</a></sup>. Add <code>__cpp_lib_deduction_guides</code> to feature test macros</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-09 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0433R2" title=" Toward a resolution of US7 and US14: Integrating template deduction for class templates into the standard library">P0433R2</a>, the proposal for adding deduction guides to the standard library, contained a 
recommendation to use <code>__cpp_lib_deduction_guides</code> as a feature test macro. However, it appears that this feature test macro has been accidentally omitted from the Standard when the paper was applied and probably needs to be added back.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-11-16; Konstantin Varlamov comments and improves wording]</i></p>

<p>
One potential topic of discussion is whether the new feature test macro needs to be defined in every library 
header that contains an explicit deduction guide. While this would be consistent with the current approach, 
no other macro is associated with such a large set of headers (20 headers in total, whereas the current 
record-holder is <code>__cpp_lib_nonmember_container_access</code> with 12 headers). For this reason, it should 
be considered whether perhaps the new macro should only be defined in <code>&lt;version&gt;</code> (which would, 
however, make it an outlier). The proposed wording currently contains an exhaustive list (note that the 
deduction guides for <code>&lt;mutex&gt;</code> were removed by LWG <a href="lwg-defects.html#2981" title="Remove redundant deduction guides from standard library (Status: C++20)">2981</a>).
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD as it's too late to be useful, and code which needs
to be portable to pre-CTAD compilers can just not use CTAD.
</p>

<p><i>[2023-04-21; Reflector poll for 'Tentatively NAD']</i></p>

<p><i>[
"We keep changing the deduction guides, and different libraries might be
conformant in some headers and not others. The status cannot be represented
by a single number."
]</i></p>




<p id="res-3635"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;functional&gt;, &lt;list&gt;, &lt;map&gt;,
  // &lt;memory&gt;, &lt;optional&gt;, &lt;queue&gt;, &lt;regex&gt;, &lt;scoped_allocator&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;string&gt;, &lt;tuple&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;utility&gt;, &lt;valarray&gt;,
  // &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3714"><a href="#3714">3714</a><sup><a href="https://cplusplus.github.io/LWG/issue3714">(i)</a></sup>. Non-single-argument constructors for range adaptors should not be <code>explicit</code></h3>
<p><b>Section:</b> 26.7.26.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a>, 26.7.28.2 <a href="https://wg21.link/range.adjacent.transform.view">[range.adjacent.transform.view]</a>, 26.7.29.2 <a href="https://wg21.link/range.chunk.view.input">[range.chunk.view.input]</a>, 26.7.29.6 <a href="https://wg21.link/range.chunk.view.fwd">[range.chunk.view.fwd]</a>, 26.7.30.2 <a href="https://wg21.link/range.slide.view">[range.slide.view]</a>, 26.7.31.2 <a href="https://wg21.link/range.chunk.by.view">[range.chunk.by.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <code>explicit</code>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <code>join_with_view</code>, 
are all <code>explicit</code>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <code>explicit</code> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://wg21.link/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711" title=" Making multi-param constructors of views explicit">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.26.2 <a href="https://wg21.link/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>fun_</i></code> with <code>std::move(fun)</code> and <code><i>zip_</i></code> 
with <code>std::move(views)...</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://wg21.link/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>fun_</i></code> with <code>std::move(fun)</code> and 
<code><i>inner_</i></code> with <code>std::move(base)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://wg21.link/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <code>n &gt; 0</code> is <code>true</code>.
<p/>
-2- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.6 <a href="https://wg21.link/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <code>n &gt; 0</code> is <code>true</code>.
<p/>
-2- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.30.2 <a href="https://wg21.link/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>n_</i></code> with <code>n</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.31.2 <a href="https://wg21.link/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>base_</i></code> with <code>std::move(base)</code> and 
<code><i>pred_</i></code> with <code>std::move(pred)</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3901"><a href="#3901">3901</a><sup><a href="https://cplusplus.github.io/LWG/issue3901">(i)</a></sup>. Is uses-allocator construction of a <i>cv</i>-qualified object type still well-formed after LWG 3870?</h3>
<p><b>Section:</b> 20.2.8 <a href="https://wg21.link/allocator.uses">[allocator.uses]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-05 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#3870" title="Remove voidify (Status: C++23)">3870</a> made <code>std::construct_at</code> unable to create an object of a <i>cv</i>-qualified type, 
which affects <code>std::uninitialized_construct_using_allocator</code>. However, uses-allocator construction is 
currently not required to be equivalent to some call to <code>std::uninitialized_construct_using_allocator</code>, 
which possibly implies that uses-allocator construction of a <i>cv</i>-qualified type may still be required to be 
well-formed.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.</p>
<p>Not all uses-allocator construction is done using <code>construct_at</code>.
<code>std::tuple&lt;const T&gt;(allocator_arg, alloc)</code> does
uses-allocator construction of a const type, so we can't make it ill-formed.
</p>



<p id="res-3901"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3908"><a href="#3908">3908</a><sup><a href="https://cplusplus.github.io/LWG/issue3908">(i)</a></sup>. <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 26.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9" title=" views::enumerate">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 26.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 26.7.24.3 <a href="https://wg21.link/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3909"><a href="#3909">3909</a><sup><a href="https://cplusplus.github.io/LWG/issue3909">(i)</a></sup>. Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="lwg-defects.html#3724" title="decay-copy should be constrained (Status: C++23)">3724</a>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="lwg-active.html#3896" title="The definition of viewable_range is not quite right (Status: New)">3896</a>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 26.4.5 <a href="https://wg21.link/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 26.7 <a href="https://wg21.link/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://wg21.link/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3930"><a href="#3930">3930</a><sup><a href="https://cplusplus.github.io/LWG/issue3930">(i)</a></sup>. Simplify type trait wording</h3>
<p><b>Section:</b> 99 [meta] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many traits that have a requirement that they are instantiated only if
"<code>T</code> shall be a complete type, <i>cv</i> <code>void</code>, or an array of unknown bound."
<p/>
Breaking down what this means, by supporting <i>cv</i>-<code>void</code> and arrays of unknown
bound (almost) the only remaining type-category is incomplete class types.
<p/>
The remaining edge case is incomplete enumerations, but they are required to
have a known fixed-base, so act as complete types, they can be copied,
assigned, etc., without knowing the names of their enumerators.
<p/>
Hence, I suggest clearer wording would be:
"<code>T</code> shall not be an incomplete class type."
<p/>
This is easier to understand, as we do not need to mentally enumerate every
type against a list to check it qualifies; it is a simpler test for the library to
check if we were to mandate these restrictions.
<p/>
There are a very small number of traits with subtly different wording, where
incomplete unions are supported, or arrays of unknown bound are not a
concern due to invoking <code>remove_all_extents</code> first. The bulk of the changes
can be made to traits with only the precise wording above though, and then
we can review whether any of the remaining restrictions deserve a wording
update of their own.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll,
including a request to withdraw the issue from the submitter.
</p>
<p>
Incomplete enumeration types are found within the <i>enum-specifier</i>
of an enum without a fixed underlying type:
<pre><code>
enum E {
    A = sizeof(E) // error, E is incomplete at this point
};
</code></pre>
and we definitely can't provide an underlying type for this case.
</p>



<p id="res-3930"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Throughout 99 [meta] replace all occurrences of
</p>
<blockquote><p>
<code>T</code> shall be a complete type, <i>cv</i> <code>void</code>, or an array of unknown bound.
</p></blockquote>
<p>
by
</p>
<blockquote><p>
<code>T</code> shall not be an incomplete class type.
</p></blockquote>

</li>

</ol>





<hr>
<h3 id="3936"><a href="#3936">3936</a><sup><a href="https://cplusplus.github.io/LWG/issue3936">(i)</a></sup>. Are implementations allowed to deprecate components not in [depr]?</h3>
<p><b>Section:</b> 99 [depr] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-22 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.1 <a href="https://wg21.link/depr.general">[depr.general]</a>/2 allows implementations to apply the
<code>deprecated</code> attribute to deprecated components.
However, there doesn't seem to be any wording disallowing applying the
<code>deprecated</code> attribute to non-deprecated components.
</p>
<p>
Is it intended to allow implementations to deprecate every library component
as they want? If so, should we turn the allowance into "<i>Recommended practice</i>" and move it to somewhere in 16.4 <a href="https://wg21.link/requirements">[requirements]</a>?
</p>
<p>
There doesn't seem to be wording which formally recommends applying
<code>deprecated</code> attribute to deprecated components either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after nine votes in favour during reflector poll.
Let implementations decide when to apply these attributes.
</p>



<p id="res-3936"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i>
There are two mutually exclusive proposed resolutions,
depending on whether it is allowed to deprecate components not in
99 [depr].
</p>
</blockquote>

<p><strong>Option A:</strong></p>

<ol>
<li>
<p>Insert a paragraph at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- <i>Recommended practice</i>:
Implementations should not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in 99 [depr].
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in 99 [depr] whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>

<p><strong>Option B:</strong></p>

<ol>
<li>
<p>Insert two paragraphs at the end of 16.4.2.2 <a href="https://wg21.link/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- Implementations shall not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://wg21.link/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in 99 [depr].
</ins>
</p>
<p>
<ins>-?- <i>Recommended practice</i>:
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in 99 [depr] whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3958"><a href="#3958">3958</a><sup><a href="https://cplusplus.github.io/LWG/issue3958">(i)</a></sup>. <code>ranges::to</code> should prioritize the "<code>reserve</code>" branch</h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-17 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the constructed range object has no range version constructor, <code>ranges::to</code> falls into a 
branch designed specifically for C++17-compliant containers, which calls the legacy constructor that 
accepts an iterator pair with <code>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</code>.    
<p/>
However, this kind of initialization may bring some performance issues, because we split the original 
range into pairs of iterators, which may lose information contained in the original range, for example:
</p>
<blockquote><pre>
#include &lt;boost/container/vector.hpp&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  std::istringstream ints("1 2 3 4 5");
  std::ranges::subrange s(std::istream_iterator&lt;int&gt;(ints),
                          std::istream_iterator&lt;int&gt;(),
                          5);
  auto r = std::ranges::to&lt;boost::container::vector&gt;(s); // <span style="color:red;font-weight:bolder">discard size info</span>
}
</pre></blockquote>
<p>
Above, <code>subrange</code> saves the size information of the stream, but <code>ranges::to</code> only extracts 
its iterator pair to create the object, so that the original size information is discarded, resulting in 
unnecessary allocations.
<p/>
I believe we should prefer to use the "<code>reserve</code>" branch here because it is really designed for this situation.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
"This optimizes exotic cases at the expense of realistic cases."
</p>



<p id="res-3958"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 26.5.7.2 <a href="https://wg21.link/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or <code>convertible_to&lt;range_reference_t&lt;R&gt;, 
range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(2.1.2) &mdash; Otherwise, if <code>constructible_from&lt;C, from_range_t, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p><del>(2.1.3) &mdash; Otherwise, if</del></p>
<ol style="list-style-type: none">
<li><p><del>(2.1.3.1) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</del></p></li>
<li><p><del>(2.1.3.2) &mdash; the <i>qualified-id</i>  
<code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> is valid and denotes a type that models 
<code>derived_from&lt;input_iterator_tag&gt;</code>, and</del></p></li>
<li><p><del>(2.1.3.3) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</del></p>
<blockquote><pre><del>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</del></pre></blockquote></li>
</ol>
</li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
<li><p><ins>(?.?.?) &mdash; Otherwise, if</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?.?) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; the <i>qualified-id</i> <code>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</code> 
is valid and denotes a type that models <code>derived_from&lt;input_iterator_tag&gt;</code>, and</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> 
is <code>true</code>:</ins></p>
<blockquote><pre><ins>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</ins></pre></blockquote></li>
</ol>
</li>
</ol>
</li>
<li><p>(2.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3980"><a href="#3980">3980</a><sup><a href="https://cplusplus.github.io/LWG/issue3980">(i)</a></sup>. The read exclusive ownership of an atomic read-modify-write operation and whether its read and write are two operations are unclear</h3>
<p><b>Section:</b> 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Such two questions are sourced from StackOverflow:
</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/77126045/can-the-read-operations-in-compare-exchange-strong-in-different-two-thread-rea/77126363?noredirect=1#comment135968355_77126363">Can the read operations in <code>compare_exchange_strong</code> in different two thread read the same value?</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/65568185/for-purposes-of-ordering-is-atomic-read-modify-write-one-operation-or-two">For purposes of ordering, is atomic read-modify-write one operation or two?</a></p></li>
</ol>
<p>
Given this example:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;

struct SpinLock{
  std::atomic&lt;bool&gt; atomic_;
  void lock(){
    bool expected = false;
    while (!atomic_.compare_exchange_strong(expected,true,std::memory_order_release,std::memory_order_relaxed)) {
    }
  }
  void unlock(){
    atomic_.store(false, std::memory_order_release);
  }
};

int main(){
  SpinLock spin{false};
  auto t1 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  auto t2 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  t1.join();
  t2.join();
}
</pre>
</blockquote>
<p>
In the current draft, the relevant phrasing that can interpret that only one read-modify-write operation reads the initial 
value false is 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> p10:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write 
associated with the read-modify-write operation.
</p></blockquote>
<p>
However, the wording can have two meanings, each kind of read can result in different explanations for the example
</p>
<ol>
<li><p>The check of the violation is done before the side effect of the RMW is in the modification order, i.e. the rule is 
just checked at the read point.</p></li>
<li><p>The check of the violation is done after the side effect of the RMW is in the modification order, i.e. the rule is 
checked when <code>RMW</code> tries to add the side effect that is based on the read-value to the modification order, and that 
side effect wouldn't be added to the modification order if the rule was violated.</p></li>
</ol>
<p>
With the first interpretation, the two RMW operations can read the same initial value because that value is indeed the last value 
in the modification order before such two RMW operations produce the side effect to the modification order.
<p/>
With the second interpretation, there is only one RMW operation that can read the initial value because the latter one in 
the modification order would violate the rule if it read the initial value.
<p/>
Such two interpretations arise from that the wording doesn't clearly specify when that check is performed.
<p/>
So, my proposed wording is:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the value from a side effect <code>X</code>, where <code>X</code> 
immediately precedes the side effect of the read-modify-write operation in the modification order.
</p></blockquote>
<p>
This wording keeps a similar utterance to 6.9.2.2 <a href="https://wg21.link/intro.races">[intro.races]</a>, and it can clearly convey the meaning 
that we say the value read by <code>RWM</code> is associated with the side effect of <code>RMW</code> in the modification order.
<p/>
Relevant discussion can be seen <a href="https://github.com/cplusplus/CWG/issues/423">CWG/issues/423</a> here.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>NAD. The first reading isn't plausible. </p>



<p id="res-3980"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 33.5.4 <a href="https://wg21.link/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote>
<p>
-10- Atomic read-modify-write operations shall always read the <del>last</del> value <ins>from a side effect <i>X</i>, 
where <i>X</i> immediately precedes the side effect of the read-modify-write operation</ins> <del>(</del>in the 
modification order<del>) written before the write associated with the read-modify-write operation</del>.
<p/>
-11- Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3981"><a href="#3981">3981</a><sup><a href="https://cplusplus.github.io/LWG/issue3981">(i)</a></sup>. Range adaptor closure object is underspecified for its return type</h3>
<p><b>Section:</b> 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to provide pipe support for user-defined range adaptors, <a href="https://wg21.link/P2387R3" title=" Pipe support for user-defined range adaptors">P2387R3</a> 
removed the specification that the adaptor closure object returns a view, which conforms to the wording of <code>ranges::to</code>.
<p/>
However, the current wording seems to be too low-spec so that the range adaptor closure object can return any type 
or even <code>void</code>. This makes it possible to break the previous specification when returning types that don't make sense, 
<a href="https://godbolt.org/z/Y4nvjY3xj">for example</a>:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

struct Closure : std::ranges::range_adaptor_closure&lt;Closure&gt; {
  struct NonCopyable {
    NonCopyable(const NonCopyable&amp;) = delete;
  };

  const NonCopyable&amp; operator()(std::ranges::range auto&amp;&amp;);
};

auto r = std::views::iota(0) | Closure{}; // <span style="color:red;font-weight:bolder">hard error in stdlibc++ and MSVC-STL</span>
</pre></blockquote>
<p>
Above, since the return type of the pipeline operator is declared as <code>auto</code>, this causes the deleted 
copy constructor to be invoked in the function body and produces a hard error.
<p/>
The proposed resolution adds a specification for the range adaptor closure object to return a <i>cv</i>-unqualified class type.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD.
"The wording says <code>R | C</code> is equivalent to <code>C(R)</code>,
not <code>auto(C(R))</code>."
</p>



<p id="res-3981"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>range adaptor closure object</i> is a unary function object that accepts a range argument. For a range adaptor
closure object <code>C</code> and an expression <code>R</code> such that <code>decltype((R))</code> models <code>range</code>, the 
following expressions are equivalent:
</p>
<p>[&hellip;]</p>
<p>
-2- Given an object <code>t</code> of type <code>T</code>, where
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>t</code> is a unary function object that accepts a range argument <ins>and returns a 
<i>cv</i>-unqualified class object</ins>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
then the implementation ensures that <code>t</code> is a range adaptor closure object.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3982"><a href="#3982">3982</a><sup><a href="https://cplusplus.github.io/LWG/issue3982">(i)</a></sup>. <code><i>is-derived-from-view-interface</i></code> should require that <code>T</code> is derived from <code>view_interface&lt;T&gt;</code></h3>
<p><b>Section:</b> 26.4.4 <a href="https://wg21.link/range.view">[range.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.view">issues</a> in [range.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the wording of <code><i>is-derived-from-view-interface</i></code> only detects whether type <code>T</code> is unambiguously 
derived from one base class <code>view_interface&lt;U&gt;</code> where <code>U</code> is not required to be <code>T</code>, which is not 
the intention of CRTP.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.
The wording correctly handles the case where T derives from <code>Base</code>
which derives from <code>view_interface&lt;Base&gt;</code>.
We don't want it to only be satisfied for direct inheritance from
<code>view_interface&lt;T&gt;</code>, but from any specialization of
<code>view_interface</code>.
Previously the concept only checked for inheritance from <code>view_base</code>
but it was changed when <code>view_interface</code> stopped inheriting from
<code>view_base</code>.
</p>



<p id="res-3982"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 26.4.4 <a href="https://wg21.link/range.view">[range.view]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr bool <i>is-derived-from-view-interface</i> = <i>see below</i>;            // exposition only
template&lt;class T&gt;
  constexpr bool enable_view =
    derived_from&lt;T, view_base&gt; || <i>is-derived-from-view-interface</i>&lt;T&gt;;
</pre>
<blockquote>
<p>
-6- For a type <code>T</code>, <code><i>is-derived-from-view-interface</i>&lt;T&gt;</code>
is <code>true</code> if and only if <code>T</code> has exactly one public base class
<code>view_interface&lt;<ins>T</ins><del>U</del>&gt;</code> <del>for some type <code>U</code></del> and
<code>T</code> has no base classes of type <code>view_interface&lt;<ins>U</ins><del>V</del>&gt;</code> for any
other type <code><ins>U</ins><del>V</del></code>.
<p/>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3996"><a href="#3996">3996</a><sup><a href="https://cplusplus.github.io/LWG/issue3996">(i)</a></sup>. <code>projected&lt;I, identity&gt;</code> should just be <code>I</code></h3>
<p><b>Section:</b> 25.3.6.4 <a href="https://wg21.link/projected">[projected]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-12 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#projected">issues</a> in [projected].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>projected</code> is a wrapper of the implementation type regardless of whether <code>Proj</code> is <code>identity</code>.
<p/>
Since <code>identity</code> always returns a reference, this prevents <code>projected&lt;I, identity&gt;</code> from fully 
emulating the properties of the original iterator when its reference is a prvalue. 
<p/>
Such non-equivalence may lead to unexpected behavior in some cases (<a href="https://godbolt.org/z/KM45ndWvh">demo</a>):
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;ranges&gt;
#include &lt;iostream&gt;

int main() {
  auto outer = std::views::iota(0, 5)
             | std::views::transform([](int i) {
                 return std::views::single(i) | std::views::filter([](int) { return true; });
               });
  
  for (auto&amp;&amp; inner : outer)
    for (auto&amp;&amp; elem : inner)
      std::cout &lt;&lt; elem &lt;&lt; " "; // 0 1 2 3 4 
  
  std::ranges::for_each(
    outer,
    [](auto&amp;&amp; inner) {
      // <span  style="color:#C80000;font-weight:bold">error: passing 'const filter_view' as 'this' argument discards qualifiers</span>
      for (auto&amp;&amp; elem : inner)
        std::cout &lt;&lt; elem &lt;&lt; " ";
    });
}
</pre></blockquote>
<p>
In the above example, <code>ranges::for_each</code> requires <code>indirect_unary_predicate&lt;Pred, projected&lt;I, identity&gt;&gt;</code>
which ultimately requires <code>invocable&lt;Pred&amp;, iter_common_reference_t&lt;projected&lt;I, identity&gt;&gt;&gt;</code>.
<p/> 
According to the current wording, the reference and indirect value type of <code>projected&lt;I, identity&gt;</code> are 
<code>filter_view&amp;&amp;</code> and <code>filter_view&amp;</code> respectively, which causes its common reference to be eventually 
calculated as <code>const filter_view&amp;</code>. Since the former is not <code>const</code>-iterable, this results in a hard error 
during instantiation because <code>const begin</code> is called unexpectedly in an unconstrained lambda.
</p>
<p>
It seems like having <code>projected&lt;I, identity&gt;</code> just be <code>I</code> is a more appropriate choice, 
which makes the concept checking really specific to <code>I</code> rather than a potentially incomplete iterator wrapper.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
NAD. <a href="https://wg21.link/P2997" title=" Removing the common reference requirement from the indirectly invocable concepts">P2997</a> solves this, and more.
"Applying the projection does in fact materialize prvalues,
so this is just lying unless we special-case identity everywhere."
</p>



<p id="res-3996"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages — C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.3.6.4 <a href="https://wg21.link/projected">[projected]</a> as indicated:</p>

<blockquote>
<p>
-1- Class template <code>projected</code> is used to constrain algorithms that accept callable objects and projections 
(3.43 <a href="https://wg21.link/defns.projection">[defns.projection]</a>). It combines an <code>indirectly_readable</code> type <code>I</code> and a callable 
object type <code>Proj</code> into a new <code>indirectly_readable</code> type whose <code>reference</code> type is the 
result of applying <code>Proj</code> to the <code>iter_reference_t</code> of <code>I</code>.
</p>
<blockquote><pre>
namespace std {
  template&lt;class I, class Proj&gt;
  struct <i>projected-impl</i> {                               // <i>exposition only</i>
    struct <i>type</i> {                                       // <i>exposition only</i>
      using value_type = remove_cvref_t&lt;indirect_result_t&lt;Proj&amp;, I&gt;&gt;;
      using difference_type = iter_difference_t&lt;I&gt;;     // <i>present only if</i> I
                                                        // <i>models</i> weakly_incrementable
      indirect_result_t&lt;Proj&amp;, I&gt; operator*() const;    // <i>not defined</i>
    };
  };

  template&lt;indirectly_readable I, indirectly_regular_unary_invocable&lt;I&gt; Proj&gt;
    using projected = <ins>conditional_t&lt;is_same_v&lt;Proj, identity&gt;, I, typename</ins> <i>projected-impl</i>&lt;I, Proj&gt;::type<ins>&gt;</ins>;
}
</pre></blockquote>
</blockquote>


</li>

</ol>





<hr>
<h3 id="4003"><a href="#4003">4003</a><sup><a href="https://cplusplus.github.io/LWG/issue4003">(i)</a></sup>. <code>view_interface::back</code> is overconstrained</h3>
<p><b>Section:</b> 26.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-28 <b>Last modified:</b> 2023-11-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#view.interface">issues</a> in [view.interface].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>view_interface</code> only provides the <code>back</code> member when the derived class satisfies both 
<code>bidirectional_range</code> and <code>common_range</code>, which ensures that <code>ranges::prev</code> can act its sentinel.
<p/>
However, requiring <code>common_range</code> seems to be too strict because when the derived class satisfies both 
<code>random_access_range</code> and <code>sized_range</code>, its end iterator can still be calculated in constant time, 
which is what some range adaptors currently do to greedily become common ranges.
<p/>
I think we should follow similar rules to eliminate this inconsistency (<a href="https://godbolt.org/z/1oEf58Krh">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

constexpr auto r = std::ranges::subrange(std::views::iota(0), 5);
constexpr auto z = std::views::zip(r);
static_assert(r.back() == 4); // <span style="color:red;font-weight:bolder">ill-formed</span>
static_assert(std::get&lt;0&gt;(z.back()) == 4); // ok
</pre></blockquote>

<p><i>[2023-11-07; Reflector poll]</i></p>

+<p>NAD. "During the <code>concat</code> discussion LEWG decided not to
support the corner case of random-access sized but not-common ranges."
"If we did want to address such ranges, would be better to enforce commonness
for random-access sized ranges by having <code>ranges::end</code> return
<code>ranges::begin(r) + ranges::size(r)</code>."
</p>


<p id="res-4003"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.5.3 <a href="https://wg21.link/view.interface">[view.interface]</a>, class template <code>view_interface</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
    [&hellip;]
  public:
    [&hellip;]
    constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                             <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
    constexpr decltype(auto) back() const
      requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
               <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 26.5.3.2 <a href="https://wg21.link/view.interface.members">[view.interface.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) back() requires <ins>(</ins>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;<ins>) ||</ins>
                                         <ins>(random_access_range&lt;D&gt; &amp;&amp; sized_range&lt;D&gt;)</ins>;
constexpr decltype(auto) back() const
  requires <ins>(</ins>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;<ins>) ||</ins>
           <ins>(random_access_range&lt;const D&gt; &amp;&amp; sized_range&lt;const D&gt;)</ins>;
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>!empty()</code> is <code>true</code>.
<p/>
-4- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<ins>auto <i>common-arg-end</i> = []&lt;class R&gt;(R&amp; r) {
  if constexpr (common_range&lt;R&gt;) {
    return ranges::end(r);
  } else {
    return ranges::begin(r) + ranges::distance(r);
  }
};</ins>
return *ranges::prev(<ins><i>common-arg-end</i></ins><del>ranges::end</del>(<i>derived</i>()));
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4006"><a href="#4006">4006</a><sup><a href="https://cplusplus.github.io/LWG/issue4006">(i)</a></sup>. <code>chunk_view::<i>outer-iterator</i>::value_type</code> should provide <code>empty</code></h3>
<p><b>Section:</b> 26.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-05 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.chunk.outer.value">issues</a> in [range.chunk.outer.value].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>chunk_view::<i>outer-iterator</i>::value_type</code> can determine whether it is empty by simply checking whether the 
<code>chunk_view</code>'s <code><i>remainder_</i></code> is <code>0</code>, which makes it valuable to explicitly provide a 
<code>noexcept empty</code> member.
<p/>
Otherwise, the <code>view_interface::empty</code> is synthesized only through the <code>size</code> member when the original 
sentinel and iterator type model <code>sized_sentinel_for</code>, <a href="https://godbolt.org/z/v3MbzfT9G">which seems overkill</a>:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  auto ints = std::istringstream{"1 2 3 4 5 6 7 8 9 10"};
  for (auto chunk : std::views::istream&lt;int&gt;(ints) | std::views::chunk(3)) {
    for (auto elem : chunk) {
      assert(!chunk.empty()); // <span style="color:red;font-weight:bolder">no matching function for call to 'empty()'</span>
      std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    assert(chunk.empty()); // <span style="color:red;font-weight:bolder">ditto</span>
    std::cout &lt;&lt; "\n";
  }
}
</pre></blockquote>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll in November 2023.
</p>
<p>
"The example shows you could use it if it existed, but not why that would be useful."
</p>
<p>
"This is a bad idea - the fact that the chunk 'shrinks' as it is iterated over
is an implementation detail and not supposed to be observable."
</p>



<p id="res-4006"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages — C++">N4964</a>.
</p>

<ol>

<li><p>Modify 26.7.29.4 <a href="https://wg21.link/range.chunk.outer.value">[range.chunk.outer.value]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
  namespace std::ranges {
    template&lt;view V&gt;
      requires input_range&lt;V&gt;
    struct chunk_view&lt;V&gt;::<i>outer-iterator</i>::value_type : view_interface&lt;value_type&gt; {
    private:
      chunk_view* <i>parent_</i>;                                        // <i>exposition only</i>

      constexpr explicit value_type(chunk_view&amp; parent);          // <i>exposition only</i>

    public:
      constexpr <i>inner-iterator</i> begin() const noexcept;
      constexpr default_sentinel_t end() const noexcept;

      <ins>constexpr bool empty() const noexcept;</ins>
      constexpr auto size() const
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    };
  }
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr default_sentinel_t end() const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <code>default_sentinel</code>.
</p>
</blockquote>
<pre>
<ins>constexpr bool empty() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return <i>parent_</i>-&gt;<i>remainder_</i> == 0;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4056"><a href="#4056">4056</a><sup><a href="https://cplusplus.github.io/LWG/issue4056">(i)</a></sup>. The effects of <code>std::swap</code> are under-specified</h3>
<p><b>Section:</b> 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-02-28 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.swap">active issues</a> in [utility.swap].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in [utility.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Subclause 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> describes the effect of <code>std::swap</code> as follows:
</p>
<blockquote>
<p>
<i>Effects</i>: Exchanges values stored in two locations.
</p>
</blockquote>
<p>
This description is extremely vague. A possible implementation which complies with this wording is:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
constexpr void swap(T&amp;, T&amp;) noexcept(/* ... */)
{
    int __x = 0, __y = 0;
    int __z = __x;
    __x = __y;
    __y = __z;
}
</pre>
</blockquote>
<p>
This exchanges values stored in two locations; namely in the locations of two objects with automatic 
storage duration within <code>swap</code>. Since this has no observable effect and complies, it is also 
valid to implement <code>swap</code> as follows:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
constexpr void swap(T&amp;, T&amp;) noexcept(/* ... */) { }
</pre>
</blockquote>
<p>
Furthermore, there is implementation divergence. 
<a href="https://github.com/llvm/llvm-project/blob/26402777ebf4eb3d8f3d5a45943b451c740b2d76/libcxx/include/__utility/swap.h#L42">
libc++ uses direct-initialization</a> to construct a temporary <code>T</code>, but 
<a href="https://github.com/gcc-mirror/gcc/blob/80c386cb20d38ebc55f30a79418fabfbed904b87/libstdc%2B%2B-v3/include/bits/move.h#L221">
libstdc++ uses copy-initialization</a>. For most types, this hopefully calls the same constructor, however, 
this is not universally true. The standard should specify in more detail what is meant to happen.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD Editorial after reflector poll.
</p>
<p>
<em>Cpp17MoveConstructible</em> require direct-init and copy-init to be
semantically equivalent, so the different implementation techniques can
only be observed by types which fail to meet the function's preconditions.
</p>
<p>
Replace the unusual "stored in two locations" wording
<a href="https://github.com/cplusplus/draft/pull/6857">editorially</a>.
</p>



<p id="res-4056"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 22.2.2 <a href="https://wg21.link/utility.swap">[utility.swap]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr void swap(T&amp; a, T&amp; b) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code> and 
<code>is_move_assignable_v&lt;T&gt;</code> is <code>true</code>.
<p/>
-2-<i>Preconditions</i>: Type <code>T</code> meets the <i>Cpp17MoveConstructible</i> (Table 31) and 
<i>Cpp17MoveAssignable</i> (Table 33) requirements.
<p/>
-3- <i>Effects</i>: <del>Exchanges values stored in two locations.</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>auto t(std::move(a));
a = std::move(b);
b = std::move(t);</ins>
</pre></blockquote>
<p>
-4- <i>Remarks</i>: The exception specification is equivalent to: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4060"><a href="#4060">4060</a><sup><a href="https://cplusplus.github.io/LWG/issue4060">(i)</a></sup>. <code>submdspan</code> preconditions do not forbid creating invalid pointer</h3>
<p><b>Section:</b> 99 [mdspan.submdspan.submdspan] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Mark Hoemmen <b>Opened:</b> 2024-03-26 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Oliver Lee and Ryan Wooster pointed out to us that creating a <code>submdspan</code> with zero-length 
<code><i>tuple-like</i></code> or <code>strided_slice</code> slice specifiers at the upper extent can cause 
the Standard <code>submdspan_mapping</code> overloads to access the input <code>mdspan</code>'s mapping 
out of bounds.
This happens in the following line of specification ( [mdspan.submdspan.mapping] p8 in
<a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a> moved to [mdspan.submdspan.mapping.common] p8 <b>after</b> the merge of 
<a href="https://wg21.link/P2642R6">P2642R6</a>).
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Let <code>offset</code> be a value of type <code>size_t</code> equal to <code>(*this)(<i>first_</i>&lt;index_type, P&gt;(slices...)...)</code>.
</p>
</blockquote>
<p>
If <code>data_handle_type</code> is a pointer to an array, then the resulting offset can be larger than 
<code>required_span_size()</code>, thus making the pointer invalid (not just one past the end). In a 
constexpr context, the result is ill-formed. With the <a href="https://github.com/kokkos/mdspan">reference 
<code>mdspan</code> implementation</a>, Clang can actually report a build error (e.g., for out-of-bounds access 
to a <code>std::array</code>). The contributed example illustrates this.
<p/>
Oliver and Ryan offer the following example and analysis:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Example 1:
</p>
<blockquote><pre>
auto x = std::array&lt;int, 3&gt;{};
auto A = mdspan{x.data(), extents{3}}; 
auto B = submdspan(A, pair{3, 3});
</pre></blockquote>
<p>
B is an <code>mdspan</code> with zero elements.
<p/>
Example 2:
</p>
<blockquote><pre>
auto y = std::array&lt;int, 9&gt;{};
auto C = mdspan{y.data(), extents{3, 3}}; 
auto D = submdspan(C, pair{3, 3}, pair{3, 3});
</pre></blockquote>
<p>
A precondition for each slice specifier is ( [mdspan.submdspan.extents]):
</p>
<blockquote><pre>
0 &le; <i>first_</i>&lt;index_type, <i>k</i>&gt;(slices...) &le; <i>last_</i>&lt;<i>k</i>&gt;(src.extents(), slices...) &le; src.extent(<i>k</i>).
</pre></blockquote>
<p>
Our understanding is that precondition is satisfied. In the second example, <code><i>first_</i>&lt;0&gt;</code> 
is 3 and <code><i>first_</i>&lt;1&gt;</code> is also 3.
<p/>
However, the submapping offset is defined as <code>(*this)(<i>first_</i>&lt;index_type, P&gt;(slices...)...)</code>, 
which then can result in an invalid data handle of the <code>submdspan</code>, even if the data handle is never 
accessed/dereferenced.
<p/>
<a href="https://godbolt.org/z/zaMTbMEK7">godbolt demo</a>
</p>
</blockquote>
<p>
We expect this situation to come up in practice.
<p/>
Suppose we have an <code>N x N</code> mdspan representing a matrix <code>A</code>, and we want to partition it 
into a <code>2 x 2</code> "matrix of matrices" (also called a "block matrix"). This partitioning is a 
common operation in linear algebra algorithms such as matrix factorizations.  
Examples of this <code>2 x 2</code> partitioning appear in <a href="https://wg21.link/P2642" title=" Padded mdspan layouts">P2642</a> and <a href="https://wg21.link/P1673" title=" A free function linear algebra interface based on the BLAS">P1673</a>.
</p>
<blockquote><pre>
mdspan A{A_ptr, N, N};

size_t p = partition_point(N); // <i>integer in 0, 1, &hellip;, N (inclusive)</i>
auto A_00 = submdspan(A, tuple{0, p}, tuple{0, p});
auto A_10 = submdspan(A, tuple{p, N}, tuple{0, 0});
auto A_01 = submdspan(A, tuple{0, p}, tuple{p, N});
auto A_11 = submdspan(A, tuple{p, N}, tuple{p, N});
</pre></blockquote>
<p>
Table illustrating the resulting <code>2 x 2</code> block matrix follows:
</p>
<table border="1">
<tr>
  <td><code>A_00</code></td>
  <td><code>A_01</code></td>
</tr>
<tr>
  <td><code>A_10</code></td>
  <td><code>A_11</code></td>
</tr>
</table> 
<p>
It's valid for <code>p</code> to be <code>0</code>. That makes every block but <code>A_11</code> have zero size.
Thus, it should also be valid for <code>p</code> to be <code>N</code>. That makes every block but 
<code>A_00</code> have zero size. However, that leads to the aforementioned UB.
<p/>
It doesn't make sense to change <code><i>first_</i></code> or <code><i>last_</i></code>. The definitions of 
<code><i>first_</i></code> and <code><i>last_</i></code> are meant to turn the slice specifier into a pair of bounds.
Since <code>submdspan(A, tuple{p, N}, tuple{p, N})</code> is valid even if <code>p</code> equals <code>N</code>,
then that strongly suggests that <code><i>first_</i>&lt;0&gt;</code> and <code><i>first_</i>&lt;1&gt;</code> 
should always be <code>p</code>, even if <code>p</code> equals <code>N</code>.
<p/>
As a result, we find ourselves needing to change <code>submdspan_mapping</code>. This will affect both 
the Standard <code>submdspan_mapping</code> overloads, and any custom (user-defined) overloads.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4060"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a> <b>after</b> the merge of <a href="https://wg21.link/P2642R6">P2642R6</a>.
</p>

<ol>
<li><p>Modify the new  [mdspan.submdspan.mapping.common] as indicated:</p>

<blockquote>
<p>
-8- <ins>If <code><i>first_</i>&lt;index_type, <i>k</i>&gt;(slices...)</code> equals <code>extents().extent(<i>k</i>)</code> 
for any rank index <code><i>k</i></code> of <code>extents()</code>, then l</ins><del>L</del>et <code>offset</code> be 
a value of type <code>size_t</code> equal to <ins><code>(*this).required_span_size()</code>. Otherwise, let 
<code>offset</code> be a value of type <code>size_t</code> equal to</ins> 
<code>(*this)(<i>first_</i>&lt;index_type, P&gt;(slices...)...)</code>.
</p>
</blockquote>
</li>

<li><p>Modify 99 [mdspan.submdspan.submdspan] as indicated:</p>

<blockquote class="note">
<p>
As a drive-by readability fix, we also propose changing a variable name in paragraph 6
as indicated below.
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class ElementType, class Extents, class LayoutPolicy,
         class AccessorPolicy, class... SliceSpecifiers&gt;
  constexpr auto submdspan(
    const mdspan&lt;ElementType, Extents, LayoutPolicy, AccessorPolicy&gt;&amp; src,
    SliceSpecifiers... slices) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-1- Let <code>index_type</code> be <code>typename Extents::index_type</code>.
<p/>
-2- Let <code>sub_map_offset</code> be the result of <code>submdspan_mapping(src.mapping(), slices...)</code>.
<p/>
[&hellip;]
<p/>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Mandates</i>: [&hellip;]
<p/>
-5-<i>Preconditions</i>: [&hellip;]
<p/>
-6- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto sub_map_<ins>result</ins><del>offset</del> = submdspan_mapping(src.mapping(), slices...);
return mdspan(src.accessor().offset(src.data(), sub_map_<ins>result</ins><del>offset</del>.offset),
              sub_map_<ins>result</ins><del>offset</del>.mapping,
              AccessorPolicy::offset_policy(src.accessor()));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4061"><a href="#4061">4061</a><sup><a href="https://cplusplus.github.io/LWG/issue4061">(i)</a></sup>. Should <code>std::basic_format_context</code> be default-constructible/copyable/movable?</h3>
<p><b>Section:</b> 22.14.6.7 <a href="https://wg21.link/format.context">[format.context]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-03-24 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#format.context">issues</a> in [format.context].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per 22.14.6.7 <a href="https://wg21.link/format.context">[format.context]</a>, it seems that <code>std::basic_format_context</code> has a default 
constructor that is effectively defaulted, which means that it is default constructible if and only 
if <code>OutIt</code> is default constructible. Currently only libstdc++ makes it conditionally default 
constructible, while libc++ and MSVC STL (together with fmtlib) make it never default constructible.
<p/>
It seems that <code>basic_format_context</code> objects are supposed to be created by the implementation 
in some internal way, and user codes are only supposed to modify existing <code>basic_format_context</code> 
objects during formatting.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-4061"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages — C++">N4971</a>.
</p>

<ol>
<li><p>Modify 22.14.6.7 <a href="https://wg21.link/format.context">[format.context]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Out, class charT&gt;
  class basic_format_context {
    basic_format_args&lt;basic_format_context&gt; args_; // <i>exposition only</i>
    Out out_;                                      // <i>exposition only</i>

    <ins>basic_format_context(const basic_format_context&amp;) = delete;
    basic_format_context&amp; operator=(const basic_format_context&amp;) = delete;</ins>
  public:
    using iterator = Out;
    using char_type = charT;
    template&lt;class T&gt; using formatter_type = formatter&lt;T, charT&gt;;
    
    basic_format_arg&lt;basic_format_context&gt; arg(size_t id) const noexcept;
    std::locale locale();
    
    iterator out();
    void advance_to(iterator it);
  };
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4071"><a href="#4071">4071</a><sup><a href="https://cplusplus.github.io/LWG/issue4071">(i)</a></sup>. <code>reference_wrapper</code> comparisons are not SFINAE-friendly</h3>
<p><b>Section:</b> 22.10.6.6 <a href="https://wg21.link/refwrap.comparisons">[refwrap.comparisons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-04-19 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2944R3" title=" Comparisons for reference_wrapper">P2944R3</a> added these hidden friends to <code class='backtick'>reference_wrapper</code>:
</p>
<pre><code>
   friend constexpr <em>synth-three-way-result</em>&lt;T&gt; operator&lt;=&gt;(reference_wrapper, reference_wrapper);
   friend constexpr <em>synth-three-way-result</em>&lt;T&gt; operator&lt;=&gt;(reference_wrapper, const T&amp;);
   friend constexpr <em>synth-three-way-result</em>&lt;T&gt; operator&lt;=&gt;(reference_wrapper, reference_wrapper&lt;const T&gt;);
</code></pre>

<p>
These functions are not templates, and so their declarations are ill-formed
for any type that does have any comparison operators, e.g.
<pre><code>
    struct A { } a;
    std::reference_wrapper&lt;A&gt; r(a);
</code></pre>
</p>
<p>
Instantiating <code>reference_wrapper&lt;A&gt;</code> will instantiate
the declarations of the hidden friends, which will attempt to determine the
return types of the <code>operator&lt;=&gt;</code> functions.
That fails because <em><code class='backtick'>synth-three-way</code></em> is constrained
and can't be called with arguments of type <code class='backtick'>A</code>.
</p>

<p>
This can be solved by changing those functions into templates, so they
aren't instantiated eagerly, e.g.,
<pre><code>
    <ins>template&lt;class U = T&gt;</ins>
    friend constexpr <em>synth-three-way-result</em>&lt;<del>T</del><ins>U</ins>&gt; operator&lt;=&gt;(reference_wrapper, reference_wrapper);
</code></pre>
or by giving them a deduced return type (so that it isn't instantiated eagerly)
and constraining them to only be callable when valid:
<pre><code>
    friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper x, reference_wrapper y)
    <ins>requires requires (const T t) { <em>synth-three-way</em>(t, t); }</ins>
</code></pre>
The second alternative is used in the proposed resolution.
</p>
<p>
In practice the <em>requires-clause</em> can be implemented more simply
(and efficiently) by checking the constraints of <em>synth-three-way</em>
directly:
<pre><code>    requires (const T t) { { t &lt; t } -> <em>boolean-testable</em>; }
</code></pre>
but when specified in prose in a <em>Constraints</em>: element it seems
clearer to just use <code><em>synth-three-way</em>(x.get(), y.get())</code>.
</p>

<p>The proposed resolution has been committed to libstdc++'s master branch.</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-4071"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>
<ol>
<li><p>Modify 22.10.6.1 <a href="https://wg21.link/refwrap.general">[refwrap.general]</a> as indicated:</p>

<blockquote>
<pre><code>
   // [refwrap.comparisons], comparisons
   friend constexpr bool operator==(reference_wrapper, reference_wrapper);
   friend constexpr bool operator==(reference_wrapper, const T&amp;);
   friend constexpr bool operator==(reference_wrapper, reference_wrapper&lt;const T&gt;);

   friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper, reference_wrapper);
   friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper, const T&amp;);
   friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper, reference_wrapper&lt;const T&gt;);
</code></pre>
</blockquote>

</li>
<li><p>Modify 22.10.6.6 <a href="https://wg21.link/refwrap.comparisons">[refwrap.comparisons]</a> as indicated:</p>
<blockquote>
<pre><code>
friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper x, reference_wrapper y);
</code></pre>

<p>
<ins>-?-
<em>Constraints</em>:
The expression
<code><em>synth-three-way</em>(x.get(), y.get())</code>
is well-formed.
</ins>
</p>

<p>-7-
<em>Returns</em>: <code><em>synth-three-way</em>(x.get(), y.get())</code>.
</p>

<pre><code>
friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper x, const T&amp; y);
</code></pre>

<p>
<ins>-?-
<em>Constraints</em>:
The expression
<code><em>synth-three-way</em>(x.get(), y)</code>
is well-formed.
</ins>
</p>

<p>-8-
<em>Returns</em>: <code><em>synth-three-way</em>(x.get(), y)</code>.
</p>

<pre><code>
friend constexpr <del><em>synth-three-way-result</em>&lt;T&gt;</del><ins>auto</ins> operator&lt;=&gt;(reference_wrapper x, reference_wrapper&lt;const T&gt; y);
</code></pre>

<p>-9-
<em>Constraints</em>: <code>is_const_v&lt;T&gt;</code> is <code class='backtick'>false</code>.
<ins>
The expression
<code><em>synth-three-way</em>(x.get(), y.get())</code>
is well-formed.
</ins>
</p>

<p>-10-
<em>Returns</em>: <code><em>synth-three-way</em>(x.get(), y.get())</code>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4074"><a href="#4074">4074</a><sup><a href="https://cplusplus.github.io/LWG/issue4074">(i)</a></sup>. <code><i>compatible-joinable-ranges</i></code> is underconstrained</h3>
<p><b>Section:</b> 26.7.15.2 <a href="https://wg21.link/range.join.with.view">[range.join.with.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-21 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.with.view">active issues</a> in [range.join.with.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.with.view">issues</a> in [range.join.with.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>join_with_view</code> requires the value type, reference and rvalue reference of the inner range 
and pattern range to share common (reference) types through <code><i>compatible-joinable-ranges</i></code>.
<p/>
However, unlike what <code>concat_view</code> and <code>generator</code> do, this concept only requires that 
these three types be valid and does not further check the relationship between them to be compatible 
with the <code>indirectly_readable</code> requirement for <code>input_iterator</code>.
This results in a validly-constructed <code>join_with_view</code> that may not model <code>input_range</code>, 
which seems unintended.
<p/>
The proposed resolution aliases <code><i>compatible-joinable-ranges</i></code> to <code><i>concatable</i></code> 
i.e. specialization for two ranges to fully constrain, and I believe this could also be a better fit for 
LWG <a href="lwg-active.html#3971" title="Join ranges of rvalue references with ranges of prvalues (Status: Open)">3971</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.7.15.2 <a href="https://wg21.link/range.join.with.view">[range.join.with.view]</a> as indicated:</p>
  
<blockquote>
<pre>
namespace std::ranges {
  template&lt;class R, class P&gt;
    concept <i>compatible-joinable-ranges</i> = <ins><i>concatable</i>&lt;R, P&gt;;</ins>  // <i>exposition only</i>
        <del>common_with&lt;range_value_t&lt;R&gt;, range_value_t&lt;P&gt;&gt; &amp;&amp;
        common_reference_with&lt;range_reference_t&lt;R&gt;, range_reference_t&lt;P&gt;&gt; &amp;&amp;
        common_reference_with&lt;range_rvalue_reference_t&lt;R&gt;, range_rvalue_reference_t&lt;P&gt;&gt;;</del>
  
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-04-24; Hewill Kang provides improved wording]</i></p>


<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-4074"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:</p>
  
<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see 17.11.1 <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 25.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  // <i>26.7.15 <a href="https://wg21.link/range.join.with">[range.join.with]</a></i>, <i>join with view</i>
  <del>template&lt;class R, class P&gt;
    concept <i>compatible-joinable-ranges</i> = <i>see below</i>; // <i>exposition only</i></del>

  template&lt;input_range V, forward_range Pattern&gt;
    requires <del>view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; <i>compatible-joinable-ranges</i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;</del>
          <ins><i>see below</i></ins>
  class join_with_view;                                                             // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.15.2 <a href="https://wg21.link/range.join.with.view">[range.join.with.view]</a> as indicated:</p>
  
<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;class R, class P&gt;
    concept <i>compatible-joinable-ranges</i> =            // <i>exposition only</i>
        common_with&lt;range_value_t&lt;R&gt;, range_value_t&lt;P&gt;&gt; &amp;&amp;
        common_reference_with&lt;range_reference_t&lt;R&gt;, range_reference_t&lt;P&gt;&gt; &amp;&amp;
        common_reference_with&lt;range_rvalue_reference_t&lt;R&gt;, range_rvalue_reference_t&lt;P&gt;&gt;;</del>
  
  [&hellip;]

  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; <i><del>compatible-joinable-ranges</del><ins>concatable</ins></i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view : public view_interface&lt;join_with_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
    constexpr auto begin() const
      requires forward_range&lt;const V&gt; &amp;&amp;
               forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; &amp;&amp;
               input_range&lt;range_reference_t&lt;const V&gt;&gt; <ins>&amp;&amp;
               <i>concatable</i>&lt;range_reference_t&lt;const V&gt;, const Pattern&gt;</ins> {
      return <i>iterator</i>&lt;true&gt;{*this, ranges::begin(<i>base_</i>)};
    }
    [&hellip;]
    constexpr auto end() const
      requires forward_range&lt;const V&gt; &amp;&amp; forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; &amp;&amp;
               input_range&lt;range_reference_t&lt;const V&gt;&gt; <ins>&amp;&amp;
               <i>concatable</i>&lt;range_reference_t&lt;const V&gt;, const Pattern&gt;</ins> {
      [&hellip;]
    }
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.15.3 <a href="https://wg21.link/range.join.with.iterator">[range.join.with.iterator]</a> as indicated:</p>
  
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; <i><del>compatible-joinable-ranges</del><ins>concatable</ins></i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.15.4 <a href="https://wg21.link/range.join.with.sentinel">[range.join.with.sentinel]</a> as indicated:</p>
  
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; <i><del>compatible-joinable-ranges</del><ins>concatable</ins></i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::<i>sentinel</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4076"><a href="#4076">4076</a><sup><a href="https://cplusplus.github.io/LWG/issue4076">(i)</a></sup>. <code>concat_view</code> should be freestanding</h3>
<p><b>Section:</b> 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-21 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>concat_view</code> can be freestanding, but this never seems to come up in the discussion, 
which seems to be an oversight.
</p>

<p><i>[2024-04-21; Daniel comments]</i></p>

<p>
The specification of some member functions of <code>concat_view</code> seem to depend on freestanding-deleted
<code>get</code> overloads for <code>variant</code>, but so does <code>join_with_view</code>, which is marked as freestanding,
so it does not seem to be a good reason to accept <code>join_with_view</code> but not <code>concat_view</code> as freestanding.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4076"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
#define __cpp_lib_ranges_concat 202403L // <ins><i>freestanding</i>,</ins> <i>also in</i> &lt;ranges&gt;
</pre>
</blockquote>
</li>

<li><p>Modify 26.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see 17.11.1 <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.10.2 <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 25.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  // <i>26.7.18 <a href="https://wg21.link/range.concat">[range.concat]</a>, concat view</i>
  template&lt;input_range... Views&gt;
    requires <i>see below</i>
  class concat_view;                                                                <ins>// <i>freestanding</i></ins>
  
  namespace views { inline constexpr <i>unspecified</i> concat = <i>unspecified</i>; }            <ins>// <i>freestanding</i></ins>
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4079"><a href="#4079">4079</a><sup><a href="https://cplusplus.github.io/LWG/issue4079">(i)</a></sup>. Missing <i>Preconditions</i> in <code>concat_view::<i>iterator</i></code>'s conversion constructor</h3>
<p><b>Section:</b> 26.7.18.3 <a href="https://wg21.link/range.concat.iterator">[range.concat.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-26 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.iterator">active issues</a> in [range.concat.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.iterator">issues</a> in [range.concat.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This conversion constructor obtains the alternative iterator of the argument
through <code>std::get</code>, which will throw when the <code>variant</code> is valueless.
We seem to be missing a <i>Preconditions</i> element here.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4079"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.7.18.3 <a href="https://wg21.link/range.concat.iterator">[range.concat.iterator]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i>(<i>iterator</i>&lt;!Const&gt; it)
  requires Const &amp;&amp;
           (convertible_to&lt;iterator_t&lt;Views&gt;, iterator_t&lt;const Views&gt;&gt; &amp;&amp; ...);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>it.<i>it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-8- <i>Effects</i>: Initializes <code><i>parent_</i></code> with <code>it.<i>parent_</i></code>, and let <code><i>i</i></code> be
<code>it.<i>it_</i>.index()</code>, initializes <code><i>it_</i></code> with 
<code><i>base-iter</i>(in_place_index&lt;<i>i</i>&gt;, std::get&lt;<i>i</i>&gt;(std::move(it.<i>it_</i>)))</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4082"><a href="#4082">4082</a><sup><a href="https://cplusplus.github.io/LWG/issue4082">(i)</a></sup>. <code>views::concat(r)</code> is well-formed when <code>r</code> is an <code>output_range</code></h3>
<p><b>Section:</b> 26.7.18.1 <a href="https://wg21.link/range.concat.overview">[range.concat.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-27 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>views::concat</code> will return <code>views::all(r)</code> when it takes only one argument, 
which only requires that the type of <code>r</code> models <code>viewable_range</code> which includes <code>output_range</code>:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
auto r = std::views::counted(std::back_inserter(v), 3);
auto c = std::views::concat(r); // <span style="color:red;font-weight:bolder">well-formed</span>
</pre></blockquote>
<p>
Since <code>concat_view</code> requires all ranges to be <code>input_range</code>, this seems inconsistent. 
We should reject the above just like <code>views::zip_transform</code> still requires <code>F</code> to be 
<code>move_constructible</code> in the case of an empty pack.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4082"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.7.18.1 <a href="https://wg21.link/range.concat.overview">[range.concat.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::concat</code> denotes a customization point object (16.3.3.3.5 <a href="https://wg21.link/customization.point.object">[customization.point.object]</a>).
Given a pack of subexpressions <code>Es...</code>, the expression <code>views::concat(Es...)</code> is expression-equivalent to
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>views::all(Es...)</code> if <code>Es</code> is a pack with only one element <ins>whose type models 
<code>input_range</code></ins>,</p></li>
<li><p>(2.2) &mdash; otherwise, <code>concat_view(Es...)</code>.</p></li>
</ol>

</blockquote>
</li>

</ol>





<hr>
<h3 id="4083"><a href="#4083">4083</a><sup><a href="https://cplusplus.github.io/LWG/issue4083">(i)</a></sup>. <code>views::as_rvalue</code> should reject non-input ranges</h3>
<p><b>Section:</b> 26.7.7.1 <a href="https://wg21.link/range.as.rvalue.overview">[range.as.rvalue.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-27 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.as.rvalue.overview">active issues</a> in [range.as.rvalue.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.as.rvalue.overview">issues</a> in [range.as.rvalue.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>views::as_rvalue(r)</code> equivalent to <code>views::all(r)</code> when <code>r</code>'s reference and rvalue reference are
of the same type, which means that in this case we only need to check whether the type of <code>r</code> models <code>viewable_range</code>.
<p/>
However, libstdc++'s implementation always requires <code>as_rvalue_view{r}</code> to be valid, which leads to
divergence when <code>r</code> is not an <code>input_range</code> (<a href="https://godbolt.org/z/EbzEsK88Y">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct I {
  int operator*();
  using difference_type = int;
  I&amp; operator++();
  void operator++(int);
};

std::ranges::range auto r = std::ranges::subrange{I{}, std::unreachable_sentinel}
                          | std::views::as_rvalue; // <span style="color:red;font-weight:bolder">// well-formed in libc++/MSVC-STL, ill-formed in libstdc++</span>
</pre></blockquote>
<p>
Although this is precisely a bug in libstdc++ that does not conform to the current wording, it is reasonable to
require <code>r</code> to be an <code>input_range</code> to be consistent with the constraints of <code>as_rvalue_view</code>.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4083"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages — C++">N4981</a>.
</p>

<ol>
<li><p>Modify 26.7.7.1 <a href="https://wg21.link/range.as.rvalue.overview">[range.as.rvalue.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::as_rvalue</code> denotes a range adaptor object (26.7.2 <a href="https://wg21.link/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> be an expression and let <code>T</code> be <code>decltype((E))</code>. The expression 
<code>views::as_rvalue(E)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>views::all(E)</code> if <ins><code>T</code> models <code>input_range</code> and</ins> 
<code>same_as&lt;range_rvalue_reference_t&lt;T&gt;, range_reference_t&lt;T&gt;&gt;</code> is <code>true</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, <code>as_rvalue_view(E)</code>.</p></li>
</ol>

</blockquote>
</li>

</ol>





</body>
</html>
