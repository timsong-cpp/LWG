<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2016-08-02 at 21:08:51 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2179" href="#2179">2179.</a> <tt>enable_shared_from_this</tt> and construction from raw pointers</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab], 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-16 <b>Last modified:</b> 2016-05-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
On reflector message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32927">c++std-lib-32927</a>, 
Matt Austern asked whether the following example should be well-defined or not
</p>
<blockquote><pre>
struct X : public enable_shared_from_this&lt;X&gt; { };
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
pointing out that 20.11.2.2.1 [util.smartptr.shared.const] does not seem to allow it, since
<tt>xp1</tt> and <tt>xp2</tt> aren't allowed to share ownership, because each of them is required to have 
<tt>use_count() == 1</tt>. Despite this wording it might be reasonable (and technical possible)
to implement that request.
<p/>
On the other hand, there is the non-normative note in 20.11.2.5 [util.smartptr.enab] p11 (already part of TR1):
</p>
<blockquote><p>
The <tt>shared_ptr</tt> constructors that <span style="color:#C80000;font-weight:bold">create unique pointers</span> 
can detect the presence of an <tt>enable_shared_from_this</tt> base and assign the newly created <tt>shared_ptr</tt> 
to its <tt>__weak_this member</tt>.
</p></blockquote>
<p>
Now according to the specification in 20.11.2.2.1 [util.smartptr.shared.const] p3-7:
</p>
<blockquote><pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre></blockquote>
<p>
the notion of <em>creating unique pointers</em> can be read to be included by this note, because the post-condition
of this constructor is <tt>unique() == true</tt>. Evidence for this interpretation seems to be weak, though.
<p/>
Howard Hinnant presented the counter argument, that actually the following is an "anti-idiom" and it seems questionable 
to teach it to be well-defined in any case:
</p>
<blockquote><pre>
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
He also pointed out that the current post-conditions of the affected <tt>shared_ptr</tt> constructor
would need to be reworded.
<p/>
It needs to be decided, which direction to follow. If this idiom seems too much broken to be supported,
the note could be improved. If it should be supported, the constructors in
20.11.2.2.1 [util.smartptr.shared.const] need a careful analysis to ensure that post-conditions
are correct.
<p/>
Several library implementations currently do not support this example, instead they typically
cause a crash. Matt points out that there are currently no explicit requirements imposed on
<tt>shared_ptr</tt> objects to prevent them from owning the same underlying object without sharing the 
ownership. It might be useful to add such a requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
More discussion is needed to pick a direction to guide a proposed resolution.
</p>

<p><i>[2013-05-09 Jonathan comments]</i></p>

<p>
The note says the newly created <tt>shared_ptr</tt> is assigned to the <tt>weak_ptr</tt> member. It doesn't 
say before doing that the <tt>shared_ptr</tt> should check if the <tt>weak_ptr</tt> is non-empty and possibly 
share ownership with some other pre-existing <tt>shared_ptr</tt>.
</p>

<p><i>[2015-08-26 Daniel comments]</i></p>

<p>
LWG issue <a href="lwg-active.html#2529">2529</a> is independent but related to this issue.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2208" href="#2208">2208.</a> <tt>std::reverse_iterator</tt> should be a literal type</h3>
<p><b>Section:</b> 24.5.1 [reverse.iterators] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2016-05-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in [reverse.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator::reverse_iterator(Iterator)</tt> should be constexpr
so that other constexpr functions can return <tt>reverse_iterator</tt>s. Of the
other methods, the other constructors, <tt>base()</tt>, <tt>operator+</tt>, <tt>operator-</tt>,
<tt>operator[]</tt>, and the non-member operators can probably also be
<tt>constexpr</tt>.
<p/>
<tt>operator*</tt> cannot be constexpr because it involves an assignment to a
member variable. Discussion starting with c++std-lib-33282 indicated
that it would be useful to make reverse_iterator a literal type
despite this restriction on its use at compile time.
</p>



<p><b>Proposed resolution:</b></p>
This issue was Resolved by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0">P0031R0</a>
adopted at Jacksonville, 2016.





<hr>
<h3><a name="2223" href="#2223">2223.</a> <tt>shrink_to_fit</tt> effect on iterator validity</h3>
<p><b>Section:</b> 23.3.11.3 [vector.capacity] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-17 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
After the additions by <a href="lwg-defects.html#2033">2033</a>, it appears clear that the intended effect includes a reallocation and 
thus the potential effect on iterators should be explicitly added to the text in order to not contradict 
23.2.1 [container.requirements.general]/11, or at the very least, explicitly state that a reallocation may 
happen.
<p/>
Taking consistency with "reserve" into consideration, I propose:
</p>
<ul>
<li><p>
that the current "Remarks" are made its "Effect" instead, inserting "Reallocation happens at this point if and only 
if the function effectively reduces the capacity." after the note on non-bindingness.
</p>
</li>
<li><p>
adding a "Remarks" paragraph, similar to that of reserve: "Reallocation invalidates all the references, pointers, 
and iterators referring to the elements in the sequence."
</p></li>
</ul>
<p>
BTW, while we are at it, I believe the effect on iterators should also be explicitly stated in the other instance 
a reallocation may happen: 23.3.11.5 [vector.modifiers]/1 &mdash; even if obvious, it only contradicts 
23.2.1 [container.requirements.general]/11 implicitly. 
<p/>
I propose to also insert "Reallocation invalidates all the references, pointers, and iterators referring to the 
elements in the sequence." at the appropriate location in its "Remarks".
</p>

<p><i>[2012-12-19: Jonathan Wakely comments]</i></p>


<p>
The described problem also affects <tt>std::basic_string</tt> and <tt>std::deque</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 

<p>Daniel extends the P/R.</p>

<p>Rationale:</p>

<p>The wording in 21.3.1.4 [string.capacity] combined with 21.3.1.1 [string.require]
seems to say the necessary things. We cannot impose all requirements as we do for <tt>vector</tt>, because
we want to allow the short-string-optimization.</p>


<p><i>[2014-02-15 post-Issaquah session]</i></p>

<p>
STL: I think that <tt>shrink_to_fit</tt> should be a no-op when called twice.
</p>
<p>
STL: Do we ever define reallocation for <tt>deque</tt>? Nope, all mentions of "reallocation" are in <tt>vector</tt>.
     We define what it means in <tt>vector::reserve()</tt>, but not for <tt>deque</tt>.
</p>
<p>
STL: Oh duh, they define reallocate in the PR. But I think we can do better here.
</p>
<p>
STL: Optimally, deque shrinking just allocates a new map of pointers, and drops empty blocks, but preserves pointers/references to elements.
</p>
<p>
Alisdair: That's like unordered containers, invalidating only iterators.
</p>
<p>
Pablo: It doesn't make sense to reduce <tt>capacity()</tt> to <tt>size()</tt>, because <tt>deque</tt> doesn't have capacity!
</p>
<p>
STL: For <tt>vector</tt>, "effectively reduces the capacity" is unnecessary, the capacity there is observable.
</p>
<p>
STL: There is a strong reason to provide an optimal shrink to fit for <tt>deque</tt>, since only the library implementer can do this.
</p>
<p>
STL: The other thing I don't like the repeated definition of reallocation for <tt>vector</tt>, we define it once and use it in a bunch of places.
     At most we can lift it up to the <tt>vector</tt> synopsis.
</p>
<p>
STL: I'll write new wording.
</p>

<p><i>[2014-10-01, STL adds discussion and provides new wording]</i></p>

<p>
Compared to the previous proposed resolution:
</p>
<ul>
<li><p>
I'm changing <tt>basic_string</tt>'s wording because (1) we should guarantee that capacity won't increase, (2) we should mention 
that it's linear complexity, and (3) we can provide a better invalidation guarantee than 21.3.1.1 [string.require]/5.  
(As previously noted, we already have the strong exception guarantee.) This introduces the term "reallocation" into 
<tt>basic_string</tt>, but immediately explains what it means for iterator validity. As far as I can tell, the Small String 
Optimization doesn't complicate the wording here; it's a reason why an implementation might not honor the request, but if 
the capacity is reduced, we are definitely reallocating buffers and will invalidate everything (including when the destination 
is the small buffer).
</p></li>
<li><p>
Between N3485 and N3936, <tt>deque</tt>'s wording was updated to avoid talking about <tt>capacity()</tt> which it doesn't have.  
Since the container's capacity is unobservable, I'm saying that invalidation is unconditional.
</p></li>
<li><p>
In <tt>vector</tt>'s wording, I'm also guaranteeing that capacity won't increase, and that iterators/etc. remain valid if the 
capacity is unchanged.
</p></li>
</ul>
<p>
My wording doesn't directly say that <tt>shrink_to_fit()</tt> should be a no-op when called twice in a row. (Indirectly, 
if the first call reduces <tt>capacity()</tt> to <tt>size()</tt>, the second call must preserve iterators/etc.) I considered 
rewording the complexity to say "linear if reallocation happens", but that's potentially problematic (what if we copy almost 
all <tt>N</tt> elements, then one throws and we have to unwind? There are no effects, so reallocation didn't happen, yet we 
took longer than constant time). Implementers can always do better than the stated complexity bounds.
<p/>
I chose not to modify <tt>deque</tt>'s requirements, so implementations remain free to reallocate the elements themselves.
<p/>
I didn't attempt to centralize vector's reallocation wording. That can be done editorially, if someone is sufficiently motivated.
</p>

<p><strong>Previous resolution from Juan Soulie/Daniel [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Keep 21.3.1.4 [string.capacity] around p14 <em>unchanged</em>, because we don't speak about
reallocations and we give the strong exception guarantee in 21.3.1.1 [string.require] (Invalidation
specification also at that place):</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-14- <i>Remarks</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ].
</p>
</blockquote>
</li>

<li><p>Edit 23.3.8.3 [deque.capacity] around p7 as indicated:</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-5- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] Reallocation happens at this point if and only 
if the function effectively reduces the capacity. If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins> 
<p/>
-6- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-7- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</del><ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</li>

<li><p>Edit 23.3.11.3 [vector.capacity] around p7 as indicated:</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-7- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] Reallocation happens at this point if and only 
if the function effectively reduces the capacity. If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins> 
<p/>
-8- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-9- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</del><ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</li>

<li><p>Edit 23.3.11.5 [vector.modifiers] p1 as indicated:</p>
<blockquote><pre>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<p>
-1- <i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. <ins>Reallocation 
invalidates all the references, pointers, and iterators referring to the elements in the sequence.</ins> If 
no reallocation happens, all the iterators and references before the insertion point remain valid. If an 
exception is thrown other than by the copy constructor, move constructor, assignment operator, or move 
assignment operator of <tt>T</tt> or by any <tt>InputIterator</tt> operation there are no effects. If an 
exception is thrown by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</p>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2015-02, Cologne]</i></p>

<p>
GR: I'm concerned that <tt>shrink_to_fit</tt> may cause reallocation without changing the capacity. [&hellip;] 
It's about correctness. The statement about invalidation is useless if I cannot detect whether reallocation has happened?
<p/>
AM: It seems like the logic goes the other way round: It's the capacity change that causes reallocation, so if 
there's no capacity change, there's no reallocation. But that's not quite how I'd like to say it... maybe this, : 
"If capacity does not change, no reallocation occurs."
<p/>
GR: Where does it actually say that <tt>reserve()</tt> invalidates? AM: It should say that in the container requirements. 
VV: vector specifies in <tt>reserve</tt> that there's reallocation if and only if the capacity changes. GR: I can't find
anything in the container requirements about <tt>reserve</tt>. DK: No, it's specified for every container separately. 
GR: It isn't specified for string.
<p/>
GR: I'm noticing that the issue touches on <tt>shrink_to_fit</tt> for a bunch of containers. Anyway, I think the 
reserve issue [re string] is in scope for this issue. This change is touching on a lot of members.
<p/>
AM: Landing this change will provide clarity for what we should do with <tt>basic_string</tt>. GR: We're already asking 
for changes; we should fix string as well. AM: If one of the changes is ready before the other, I'd like to land the 
finished part first, but if both are ready for Lenexa, I'm equally happy to fix them in one go.
<p/>
DK will reword this. 
<p/>
<b>Conclusion</b>: Update wording, revisit in Lenexa. 
</p>
<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 21.3.1.4 [string.capacity] p14 as depicted:</p>

<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-14- <i><del>Remarks</del><ins>Effects</ins></i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce 
<tt>capacity()</tt> to <tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for 
implementation-specific optimizations. &mdash; <i>end note</i>] <ins>It does not increase <tt>capacity()</tt>, 
but may reduce <tt>capacity()</tt> by causing reallocation.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Linear in the size of the sequence.</ins>
<p/>
<ins>-?- <i>Remarks</i>: Reallocation invalidates all the references, pointers, and iterators referring to the 
elements in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.8.3 [deque.capacity] p5-p7 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-5- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change 
the size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i>] If an exception is thrown other than by the move constructor of a 
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-6- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-7- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change the
size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific
optimizations. &mdash; <i>end note</i>]</del><ins><tt>shrink_to_fit</tt> invalidates all the references, pointers, 
and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.3 [vector.capacity] p7-p9 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-7- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end note</i>] 
It does not increase <tt>capacity()</tt>, but may reduce <tt>capacity()</tt> by causing reallocation. If an exception is 
thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-8- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-9- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end 
note</i>] If an exception is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there 
are no effects.</del><ins>Reallocation invalidates all the references, pointers, and iterators referring to the elements 
in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.5 [vector.modifiers] p1 as depicted:</p>

<blockquote>
<p>
-1- <i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. <ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins> If no reallocation happens,
all the iterators and references before the insertion point remain valid. [&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2241" href="#2241">2241.</a> <tt>&lt;cstdalign&gt;</tt> and <tt>#define</tt> of <tt>alignof</tt></h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in [support.runtime].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 18.10 [support.runtime] p2:
</p>

<blockquote><p>
The contents of these headers are the same as the Standard C library headers [..], <tt>&lt;stdalign.h&gt;</tt>, [..]
</p></blockquote>

<p>
Since our base C standard is C99, which doesn't have a <tt>&lt;stdalign.h&gt;</tt>, the reference to a non-existing 
C header is irritating (In this context <tt>&lt;stdalign.h&gt;</tt> doesn't refer to the deprecated C++ header
<tt>&lt;stdalign.h&gt;</tt> described in D.4 [depr.c.headers]).
<p/>
Furthermore, it would be also important that it doesn not define a macro named <tt>alignof</tt>, which C11 also defines 
in this header. 
<p/>
Currently we only have the following guarantee as part of 18.10 [support.runtime] p7:
</p>

<blockquote><p>
The header <tt>&lt;cstdalign&gt;</tt> and the header <tt>&lt;stdalign.h&gt;</tt> shall not define a macro named 
<tt>alignas</tt>.
</p></blockquote>

<p>
It is unclear what the better strategy is: Striking the reference to <tt>&lt;stdalign.h&gt;</tt> in
18.10 [support.runtime] p2 or upgrading to C11 as new base C standard.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
STL: related to earlier issue on C4, <a href="lwg-active.html#2201">2201</a>, and now we get a C11 header<br/>
JY: find _Alignof as keyword C11 FDIS has four defines in stdalign.h<br/>
AM: need paper for C11 as base library we should really do that<br/>
STL: really need vendor input<br/>
STL: don't think we need to do anything right now not P1<br/>
AM: any objections to downscale to P2  (no objections)
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Walter: this is on track to go away if we adopt Clark's paper to rebase to C11<br/>
Room: tentatively resolved; revisit after C11 paper: <a href="http://wg21.link/P0063">P0063</a><br/>
</p>

<p><i>[2016-03 Oulu]</i></p>

<p><a href="http://wg21.link/P0063">P0063</a> was adopted.</p>
<p>Change status to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.11.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.11.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2343" href="#2343">2343.</a> Is the value of the ECMA-262 RegExp object's multiline property really false?</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nayuta Taga <b>Opened:</b> 2013-10-30 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the following "Multiline" is the value of the ECMA-262 RegExp object's multiline property.
<p/>
In <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMA-262</a>, 
there are some definitions that relate to Multiline:
</p>
<ul>
<li><p>
ECMA-262 15.10.2.6:
</p>
<blockquote>
<p>
If Multiline is true, ^ matches just after LineTerminator.
<p/>
If Multiline is false, ^ does not match just after LineTerminator.
<p/>
If Multiline is true, $ matches just before LineTerminator.
<p/>
If Multiline is false, $ does not match just before LineTerminator.
</p>
</blockquote>
</li>
<li>
<p>
ECMA-262 15.10.4.1, 15.10.7.4:
</p>
<blockquote><p>
By default, Multiline is false.
</p></blockquote>
</li>
</ul>
<p>
So, the C++11 standard says that Multiline is false. As it is false,
^ matches only the beginning of the string, and $ matches only the end
of the string.
<p/>
However, two flags are defined in 28.5.2 [re.matchflag] Table 139:
</p>
<blockquote>
<p>
<tt>match_not_bol</tt>: the character ^ in the regular expression shall not match <tt>[first,first)</tt>.
<p/>
<tt>match_not_eol</tt>: the character "$" in the regular expression shall not match <tt>[last,last)</tt>.
</p>
</blockquote>
<p>
As Multiline is false, the <tt>match_not_bol</tt> and the <tt>match_not_eol</tt> are
meaningless because they only make ^ and $ match none.
<p/>
In my opinion, Multiline should be true.
<p/>
FYI, Multiline of the existing implementations are as follows:
<p/>
<em>Multiline=false:</em>
</p>
<ul>
<li><p>
libstdc++ r206594
</p></li>
<li><p>
libc++ r199174
</p></li>
</ul>
<p>
<em>Multiline=true:</em>
</p>
<ul>
<li><p>
Visual Studio Express 2013
</p></li>
<li><p>
boost 1.55
</p></li>
</ul>

<p><i>[2015-05-22, Daniel comments]</i></p>

<p>
This issue interacts with LWG <a href="lwg-active.html#2503">2503</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Resolving <a href="lwg-active.html#2503">2503</a> will resolve this as well.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2358" href="#2358">2358.</a> Apparently-bogus definition of <tt>is_empty</tt> type trait</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 'Condition' for <tt>std::is_empty</tt> is listed as:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members other than bit-fields of length 0, 
no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> 
is false."
</p></blockquote>
<p>
This is incorrect: there is no such thing as a non-static data member that is a bit-field of length 0, since bit-fields of 
length 0 must be unnamed, and unnamed bit-fields are not members (see 9.2.4 [class.bit] p2).
<p/>
It also means that classes such as:
</p>
<blockquote><pre>
struct S {
 int : 3;
};
</pre></blockquote>
<p>
are empty (because they have no non-static data members). There's implementation divergence on the value of 
<tt>is_empty&lt;S&gt;::value</tt>.
<p/>
I'm not sure what the purpose of <tt>is_empty</tt> is (or how it could be useful), but if it's desirable for the above type to 
not be treated as empty, something like this could work:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members <del>other than</del><ins>, no unnamed</ins> 
bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class 
<tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>
<p>
and if the above type <em>should</em> be treated as empty, then this might be appropriate:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no <ins>(named)</ins> non-static data members <del>other than bit-fields of 
length 0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which 
<tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>

<p><i>[08 - 2016 Chicago]</i></p>

<p>Walter says: We want <tt>is_empty_v&lt;S&gt;</tt> to produce false as a result.  Therefore, we recommend adoption of the first of the issue's suggestions.</p>
<p>Tuesday AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>Modify Table 38 â€” Type property predicates for <tt>is_empty</tt> as follows:</p>
<blockquote><p>
<tt>T</tt> is a non-union class type with no non-static data members <del>other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty_v&lt;B&gt;</tt> is false.</p>
</blockquote>





<hr>
<h3><a name="2391" href="#2391">2391.</a> <tt>basic_string</tt> is missing non-<tt>const</tt> <tt>data()</tt></h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Michael Bradshaw <b>Opened:</b> 2014-05-27 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Regarding 21.3.1 [basic.string], <tt>std::basic_string&lt;charT&gt;::data()</tt> returns a <tt>const charT*</tt> 
21.3.1.7.1 [string.accessors]. While this method is convenient, it doesn't quite match <tt>std::array&lt;T&gt;::data()</tt> 
23.3.7.5 [array.data] or <tt>std::vector&lt;T&gt;::data()</tt> 23.3.11.4 [vector.data], both of which provide two 
versions (that return <tt>T*</tt> or <tt>const T*</tt>). An additional <tt>data()</tt> method can be added to 
<tt>std::basic_string</tt> that returns a <tt>charT*</tt> so it can be used in similar situations that <tt>std::array</tt> and 
<tt>std::vector</tt> can be used. Without a non-<tt>const</tt> <tt>data()</tt> method, <tt>std::basic_string</tt> has to be treated 
specially in code that is otherwise oblivious to the container type being used.
<p/>
Adding a <tt>charT*</tt> return type to <tt>data()</tt> would be equivalent to doing <tt>&amp;str[0]</tt> or <tt>&amp;str.front()</tt>.
<p/>
Small discussion on the issue can be found <a href="http://stackoverflow.com/questions/7518732/why-are-stdvectordata-and-stdstringdata-different">here</a>
and in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/ll9HuEML6zo/discussion">std-discussion thread</a>  
(which didn't get too much attention).
<p/>
This requires a small change to <tt>std::basic_string</tt>'s definition in 21.3.1 [basic.string] to add the method to 
<tt>std::basic_string</tt>, and another small change in 21.3.1.7.1 [string.accessors] to define the new method.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Back to LEWG.
</p>

<p><i>[2016-05-22]</i></p>

<p>
Marshall says: this issue has been resolved by P0272R1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change class template <tt>basic_string</tt> synopsis, 21.3.1 [basic.string], as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
  class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// 21.4.7, string operations:</i>
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    <ins>charT* data() noexcept;</ins>
    allocator_type get_allocator() const noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Add the following sequence of paragraphs following 21.3.1.7.1 [string.accessors] p3, as indicated:</p>
<blockquote>
<pre>
<ins>charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: A pointer <tt>p</tt> such that <tt>p + i == &amp;operator[](i)</tt> for each <tt>i</tt> in <tt>[0,size()]</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Constant time.</ins>
<p/>
<ins>-?- <i>Requires</i>: The program shall not alter the value stored at <tt>p + size()</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2468" href="#2468">2468.</a> Self-move-assignment of library types</h3>
<p><b>Section:</b> 17.6.4.9 [res.on.arguments], 17.6.3.1 [utility.arg.requirements], 17.6.5.15 [lib.types.movedfrom], 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-01-22 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.arguments">issues</a> in [res.on.arguments].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose we write
</p>
<blockquote>
<pre>
vector&lt;string&gt; v{"a", "b", "c", "d"};
v = move(v);
</pre>
</blockquote>
<p>
What should be the state of <tt>v</tt> be? The standard doesn't say anything specific about self-move-assignment. 
There's relevant text in several parts of the standard, and it's not clear how to reconcile them.
<p/>
17.6.4.9 [res.on.arguments] writes that, for all functions in the standard library, unless explicitly stated 
otherwise, "If a function argument binds to an rvalue reference parameter, the implementation may assume that this 
parameter is a unique reference to this argument." The <tt>MoveAssignable</tt> requirements table in 
17.6.3.1 [utility.arg.requirements] writes that, given <tt>t = rv</tt>, <tt>t</tt>'s state is equivalent to 
<tt>rv</tt>'s from before the assignment and <tt>rv</tt>'s state is unspecified (but valid). For containers 
specifically, the requirements table in 23.2.1 [container.requirements.general] says that, given <tt>a = rv</tt>, 
<tt>a</tt> becomes equal to what <tt>rv</tt> was before the assignment (and doesn't say anything about <tt>rv</tt>'s 
state post-assignment).
<p/>
Taking each of these pieces in isolation, without reference to the other two:
</p>
<ul>
<li><p>17.6.4.9 [res.on.arguments] would clearly imply that the effect of <tt>v = move(v)</tt> is undefined.</p></li>
<li><p>17.6.3.1 [utility.arg.requirements] would clearly imply that <tt>v = move(v)</tt> has defined behavior. 
It might be read to imply that this is a no-op, or might be read to imply that it leaves <tt>v</tt> in a valid but 
unspecified state; I'm not sure which reading is more natural.</p></li>
<li><p>23.2.1 [container.requirements.general] would clearly imply that <tt>v = move(v)</tt> is a no-op.</p></li>
</ul>
<p>
It's not clear from the text how to put these pieces together, because it's not clear which one takes precedence.  
Maybe 17.6.4.9 [res.on.arguments] wins (it imposes an implicit precondition that isn't mentioned in the 
<tt>MoveAssignable</tt> requirements, so <tt>v = move(v)</tt> is undefined), or maybe 
23.2.1 [container.requirements.general] wins (it explicitly gives additional guarantees for 
<tt>Container::operator=</tt> beyond what's guaranteed for library functions in general, so <tt>v = move(v)</tt> 
is a no-op), or maybe something else.
<p/>
On the existing implementations that I checked, for what it's worth, <tt>v = move(v)</tt> appeared to clear the vector; 
it didn't leave the vector unchanged and it didn't cause a crash.
<p/>
<em>Proposed wording</em>:
<p/>
Informally: change the <tt>MoveAssignable</tt> and Container requirements tables (and any other requirements tables 
that mention move assignment, if any) to make it explicit that <tt>x = move(x)</tt> is defined behavior and it leaves 
<tt>x</tt> in a valid but unspecified state. That's probably not what the standard says today, but it's probably what 
we intended and it's consistent with what we've told users and with what implementations actually do.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>JW: So far, the library forbids self-assignment since it assumes that anything bound to an rvalue reference has no aliases. But self-assignment can happen in real code, and it can be implemented. So I want to add an exception to the Standard that this should be allowed and leave the object in a valid-but-unspecified state.</p>
<p>STL: When this is resolved, I want to see a) VBU for library types after self-move, but also b) requirements on user types for self-moves. E.g. should algorithms be required to avoid self-assignments (since a user-defined type might blow up)? HH: In other words, should we require that you can assign from moved-from values.</p>
<p>WEB: What can one generally do with moved-from values?</p>
<p>VV: Call any member function that has no preconditions.</p>
<p>JW: That's certainly the library requirement, and it's also good guidance for user types.</p>
<p>JW: I'm writing wording. I care about this.</p>
<p>Move to Open; Jonathan to provide wording</p>

<p><i>[2016-08-01, Howard provided wording.]</i></p>

<p><i>[08-2016 - Chicago]</i></p>

<p>Tuesday AM: Move to Tentatively Ready</p>



<p><b>Proposed resolution:</b></p>

<p>
In [swappable.requirements], modify Table 23 &mdash; <code>MoveAssignable</code> requirements [moveassignable]:
</p>

<blockquote>

<table border="1">
<caption>Table 23 &mdash; <tt>MoveAssignable</tt> requirements [moveassignable]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>

<tr>
<td><tt>t = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td><tt>t</tt></td>
<td><ins>If <tt>addressof(t) != addressof(rv)</tt>,</ins> <tt>t</tt> is
equivalent to the value of <tt>rv</tt> before the assignment</td>
</tr>

<tr>
<td colspan=4>
<tt>rv</tt>'s state is unspecified. [<i>Note:</i> <tt>rv</tt> must
still meet the requirements of the library component that is using it<ins>,
whether or not <tt><tt>addressof(t) == addressof(rv)</tt></tt></ins>. The
operations listed in those requirements must work as specified whether
<tt>rv</tt> has been moved from or not. &mdash; <i>end note</i>] </td>
</tr>

</table>

</blockquote>






<hr>
<h3><a name="2503" href="#2503">2503.</a> multiline option should be added to <tt>syntax_option_type</tt></h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nozomu Kat&#x14d; <b>Opened:</b> 2015-05-22 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of ECMAScript defines the Multiline property for its
RegExp and the regular expressions ^ and $ behave differently according
to the value of this property. Thus, this property should be available
also in the ECMAScript compatible engine in <tt>std::regex</tt>.
</p>

<p><i>[2015-05-22, Daniel comments]</i></p>

<p>
This issue interacts somewhat with LWG <a href="lwg-active.html#2343">2343</a>.
</p>

<p><i>[Telecom 2015-07]</i></p>

<p>
Set the priority to match LWG <a href="lwg-active.html#2343">2343</a>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready. This also resolves <a href="lwg-active.html#2343">2343</a></p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li><p>Change 28.5.1 [re.synopt] as indicated:</p>

<blockquote><pre>
namespace std::regex_constants {
  typedef T1 syntax_option_type;
  constexpr syntax_option_type icase = <i>unspecified</i> ;
  constexpr syntax_option_type nosubs = <i>unspecified</i> ;
  constexpr syntax_option_type optimize = <i>unspecified</i> ;
  constexpr syntax_option_type collate = <i>unspecified</i> ;
  constexpr syntax_option_type ECMAScript = <i>unspecified</i> ;
  constexpr syntax_option_type basic = <i>unspecified</i> ;
  constexpr syntax_option_type extended = <i>unspecified</i> ;
  constexpr syntax_option_type awk = <i>unspecified</i> ;
  constexpr syntax_option_type grep = <i>unspecified</i> ;
  constexpr syntax_option_type egrep = <i>unspecified</i> ;
  <ins>constexpr syntax_option_type multiline = <i>unspecified</i> ;</ins>
}
</pre></blockquote>
</li>

<li><p>Change 28.5.2 [re.matchflag], Table 138 &mdash; "<tt>syntax_option_type</tt> effects" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<ins><tt>multiline</tt></ins>
</td>
<td>
<ins>Specifies that <tt>^</tt> shall match the beginning of a line
and <tt>$</tt> shall match the end of a line, if the ECMAScript engine is
selected.</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2510" href="#2510">2510.</a> Tag types should not be <tt>DefaultConstructible</tt></h3>
<p><b>Section:</b> 18.6 [support.dynamic], 20.2 [utility], 20.4.5 [pair.piecewise], 20.10.2 [memory.syn], 20.10.6 [allocator.tag], 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-06-13 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.dynamic">issues</a> in [support.dynamic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::experimental::optional</tt>, for certain reasons, specifies its <tt>nullopt</tt> type
to not be <tt>DefaultConstructible</tt>. It doesn't do so for its tag type <tt>in_place_t</tt>
and neither does the standard proper for any of its tag types. That turns
out to be very unfortunate, consider the following:
</p>
<blockquote><pre>
#include &lt;memory&gt;
#include &lt;array&gt;

void f(std::array&lt;int, 1&gt;, int) {} // #1
void f(std::allocator_arg_t, int) {} // #2

int main()
{
  f({}, 666); // #3
}
</pre></blockquote>
<p>
The call at #3 is ambiguous. What's even worse is that if the overload #1
is removed, the call works just fine. The whole point of a tag type is that
it either needs to mentioned in a call or it needs to be a forwarded argument,
so being able to construct a tag type like that makes no sense.
<p/>
Making the types have an <em>explicit default constructor</em> might have helped, but 
<a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1518">CWG 1518</a>
is going against that idea.
<p/>
[optional.nullopt]/3 solves this problem for <tt>nullopt</tt>:
</p>
<blockquote>
<p>
Type <tt>nullopt_t</tt> shall not have a default constructor. It shall be a
literal type. Constant <tt>nullopt</tt> shall be initialized with an argument
of literal type.
</p>
</blockquote>

<p><i>[2015-06, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Move back to Open</p>
<p>JW: The linked Core issue (CWG 1518) gives us a better tool to solve this (explicit default constructors). [The CWG Issue means that an explicit default constructor will no longer match "{}".] JW explains that it's important that tag types cannot be constructed from "{}" (e.g. the allocator tag in the tuple constructors).</p>
<p>WEB: Should we now go back and update our constructors? JW: For tag types, yes.</p>
<p>VV: The guideline is that anything that does not mention the type name explicitly should not invoke an explicit constructor.</p>
<p>Ville will provide wording.</p>
<p>Discussion about pair/tuple's default constructor - should they now be explicit?</p>

<p><i>[2016-01-31]</i></p>

<p>
Ville provides revised wording.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t <del>{}</del>; <ins><i>see below</i></ins>
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 18.6 [support.dynamic]/1 (<em>following</em> the header <tt>&lt;new&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>nothrow_t</tt> shall not have a default constructor.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.2 [utility]/2 (<em>following</em> the header <tt>&lt;utility&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>piecewise_construct_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>piecewise_construct</tt> shall be initialized with an argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.4.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t <del>{ }</del>;
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
</pre></blockquote>
</li>
<li><p>In 20.10.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.10.2 [memory.syn]/1 (<em>following</em> the header <tt>&lt;memory&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>allocator_arg_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>allocator_arg</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.10.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t <del>{ }</del>;
  constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.4.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.10.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>

</li>
<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct try_to_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct adopt_lock_t <del>{ }</del>; <ins><i>see below</i></ins>

constexpr defer_lock_t defer_lock { <ins><i>unspecified </i></ins> };
constexpr try_to_lock_t try_to_lock { <ins><i>unspecified </i></ins> };
constexpr adopt_lock_t adopt_lock { <ins><i>unspecified </i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add three new paragraphs after [thread.mutex]/1 (<em>following</em> the header <tt>&lt;mutex&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>defer_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>defer_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>try_to_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>try_to_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>adopt_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>adopt_lock</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
AM: should have note about compatibility in Annex C<br/>
HH: like this idiom well enough that I've started using it in my own code<br/>
AM: why are pair and tuple involved here?<br/>
GR: they are the only types which forward explicitness with EXPLICIT<br/>
AM: British spelling of behaviour<br/>
AM: happy to drop my issue about Annex C<br/>
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>This is waiting on Core issue 1518</p>
<p>Saturday: Core 1518 was resolved in Oulu</p>

<p><i>[07-16 - Chicago]</i></p>

<p>This is related to <a href="lwg-active.html#2736">2736</a></p>
<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t { <ins>explicit nothrow_t() = default;</ins> };
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.4.2 [pairs.pair], change the class template <tt>pair</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
pair(pair&amp;&amp;) = default;
<ins><i>EXPLICIT</i></ins> constexpr pair();
<i>EXPLICIT</i> constexpr pair(const T1&amp; x, const T2&amp; y);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.4.2 [pairs.pair] p3, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr pair();
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Value-initializes <tt>first</tt> and <tt>second</tt>.
<p/>
-4- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;first_type&gt;::value</tt> is <tt>true</tt> and 
<tt>is_default_constructible&lt;second_type&gt;::value</tt> is <tt>true</tt>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if either <tt>first_type</tt> or <tt>second_type</tt> 
is not implicitly default-constructible. 
[<i>Note</i>: This behaviour can be implemented with a trait 
that checks whether a <tt>const first_type&amp;</tt> or a <tt>const second_type&amp;</tt> can be 
initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.4.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
</li>

<li><p>In 20.5.2 [tuple.tuple], change the class template <tt>tuple</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
<i>// 20.4.2.1, tuple construction</i>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
<i>EXPLICIT</i> constexpr tuple(const Types&amp;...); <i>// only if sizeof...(Types) &gt;= 1</i>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.5.2.1 [tuple.cnstr] p4, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Value initializes each element.
<p/>
-5- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;<i>T<sub>i</sub></i>&gt;::value</tt> is <tt>true</tt> for all <i>i</i>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if <tt><i>T<sub>i</sub></i></tt> 
is not implicitly default-constructible for at least one <i>i</i>.
[<i>Note</i>: This behaviour can be implemented with a trait that checks whether
a <tt>const Ti&amp;</tt> can be initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.10.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
constexpr allocator_arg_t allocator_arg{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.10.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.4.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.10.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>
</li>

<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t { <ins>explicit defer_lock_t() = default;</ins> };
struct try_to_lock_t { <ins>explicit try_to_lock_t() = default;</ins> };
struct adopt_lock_t { <ins>explicit adopt_lock_t() = default;</ins> };

constexpr defer_lock_t defer_lock { };
constexpr try_to_lock_t try_to_lock { };
constexpr adopt_lock_t adopt_lock { };
[&hellip;]
</pre></blockquote>
</li>

</ol>





<hr>
<h3><a name="2519" href="#2519">2519.</a> Iterator <tt>operator-=</tt> has gratuitous undefined behaviour</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hubert Tong  <b>Opened:</b> 2015-07-15 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In subclause 24.2.7 [random.access.iterators], Table 110, the operational semantics for the expression "<tt>r -= n</tt>" 
are defined as
</p>
<blockquote><pre>
return r += -n;
</pre></blockquote>
<p>
Given a <tt>difference_type</tt> of a type <tt>int</tt> with range [-32768, 32767], if the value of <tt>n</tt> is -32768, 
then the evaluation of <tt>-n</tt> causes undefined behaviour (Clause 5 [expr] paragraph 4).
<p/>
The operational semantics may be changed such that the undefined behaviour is avoided.
<p/>
<b>Suggested wording:</b>
<p/>
Replace the operational semantics for "<tt>r -= n</tt>" with:
</p>
<blockquote><pre>
{ 
  difference_type m = n;
  if (m >= 0)
    while (m--)
      --r;
  else
    while (m++)
      ++r;
  return r; 
}
</pre></blockquote>
<p>
Jonathan Wakely:
<p/>
I'm now convinced we <em>don't</em> want to change the definition of <tt>-=</tt> and
instead we should explicitly state the (currently implicit)
precondition that <tt>n != numeric_limits&lt;difference_type&gt;::min()</tt>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Change Table 110 "Random access iterator requirements (in addition to
bidirectional iterator)" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements (in addition to
bidirectional iterator)</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational<br/>semantics</th>
<th align="center">Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>r -= n</tt>
</td>

<td>
<tt>X&amp;</tt>
</td>

<td>
<tt>return r += -n;</tt>
</td>

<td>
<ins>pre: the absolute value of <tt>n</tt> is in the range of representable values of <tt>difference_type</tt>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2529" href="#2529">2529.</a> Assigning to <tt>enable_shared_from_this::__weak_this</tt> twice</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-08-26 <b>Last modified:</b> 2016-05-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear what should happen if a pointer to an object with an
<tt>enable_shared_from_this</tt> base is passed to two different <tt>shared_ptr</tt>
constructors.
</p>
<blockquote><pre>
#include &lt;memory&gt;

using namespace std;

int main()
{
  struct X : public enable_shared_from_this&lt;X&gt; { };
  auto xraw = new X;
  shared_ptr&lt;X&gt; xp1(xraw);  // #1
  {
    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2
  }
  xraw-&gt;shared_from_this();  // #3
}
</pre></blockquote>
<p>
This is similar to LWG <a href="lwg-active.html#2179">2179</a>, but involves no undefined behaviour due
to the no-op deleter, and the question is not whether the second
<tt>shared_ptr</tt> should share ownership with the first, but which <tt>shared_ptr</tt>
shares ownership with the <tt>enable_shared_from_this::__weak_this</tt> member.
<p/>
With all three of the major <tt>std::shared_ptr</tt> implementations the <tt>xp2</tt>
constructor modifies the <tt>__weak_this</tt> member so the last line of the
program throws <tt>bad_weak_ptr</tt>, even though all the requirements on the 
<tt>shared_from_this()</tt> function are met (20.11.2.5 [util.smartptr.enab])/7:
</p>
<blockquote><p>
<i>Requires</i>: <tt>enable_shared_from_this&lt;T&gt;</tt> shall be an accessible base class
of <tt>T</tt>. <tt>*this</tt> shall be a subobject of an object <tt>t</tt> of type <tt>T</tt>. There shall
be at least one <tt>shared_ptr</tt> instance <tt>p</tt> that owns <tt>&amp;t</tt>.
</p></blockquote>
<p>
Boost doesn't update <tt>__weak_this</tt>, leaving it sharing with <tt>xp1</tt>, so the
program doesn't throw. That change was made to <tt>boost::enable_shared_from_this</tt> because 
someone reported exactly this issue as a bug, see <a href="https://svn.boost.org/trac/boost/ticket/2584">Boost issue 2584</a>.
<p/>
On the reflector Peter Dimov explained that there are real-world use
cases that rely on the Boost behaviour, and none which rely on the
behaviour of the current <tt>std::shared_ptr</tt> implementations. We should
specify the behaviour of <tt>enable_shared_from_this</tt> more precisely, and
resolve this issue one way or another.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2569" href="#2569">2569.</a> <tt>conjunction</tt> and <tt>disjunction</tt> requirements are too strict</h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-11 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.15.8 [meta.logical]/2 and /5 impose the following requirement on the arguments of <tt>conjunction</tt> and <tt>disjunction</tt>:
</p>
<blockquote><p>
Every template type argument shall be usable as a base class and shall have a static data member value which is convertible to 
<tt>bool</tt>, is not hidden, and is unambiguously available in the type.
</p></blockquote>
<p>
Since the requirement is unconditional, it applies even to type arguments whose instantiation is not required due to short circuiting. 
This seems contrary to the design intent, expressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>, 
that it is valid to write <tt>conjunction_v&lt;is_class&lt;T&gt;, is_foo&lt;T&gt;&gt;</tt> even if instantiating 
<tt>is_foo&lt;T&gt;::value</tt> is ill-formed for non-class types.
</p>
<p><i>[08-2016, Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2569">2569</a> and <a href="lwg-active.html#2570">2570</a></p>
<p>Tuesday AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p><i>[We recommend applying the proposed resolution for LWG issues 2567 and 2568 before this
proposed resolution, lest the poor editor gets confused.]</i></p>


<p>In [meta.logical],</p>

<p>- insert a new paragraph before paragraph 2:</p>

<p><ins>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</ins></p>

<p>- move paragraph 4 before paragraph 2, and edit
paragraph 2 as follows:</p>

<p><del>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>

<p>- insert a new paragraph before paragraph 5:</p>

<p><ins>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</ins></p>

<p>- move paragraph 7 before paragraph 5, and edit
paragraph 5 as follows:</p>

<p><del>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>





<hr>
<h3><a name="2570" href="#2570">2570.</a> [fund.ts.v2] <tt>conjunction</tt> and <tt>disjunction</tt> requirements are too strict</h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-11 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
99 [meta.logical]/2 and /5 impose the following requirement on the arguments of <tt>conjunction</tt> and <tt>disjunction</tt>:
</p>
<blockquote><p>
Every template type argument shall be usable as a base class and shall have a static data member value which is convertible to 
<tt>bool</tt>, is not hidden, and is unambiguously available in the type.
</p></blockquote>
<p>
Since the requirement is unconditional, it applies even to type arguments whose instantiation is not required due to short circuiting. 
This seems contrary to the design intent, expressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>, 
that it is valid to write <tt>conjunction_v&lt;is_class&lt;T&gt;, is_foo&lt;T&gt;&gt;</tt> even if instantiating 
<tt>is_foo&lt;T&gt;::value</tt> is ill-formed for non-class types.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Alisdair has a paper in progress addressing this</p>

<p><i>[08-2016 - Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2569">2569</a> and <a href="lwg-active.html#2570">2570</a></p>
<p>Tuesday AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2584" href="#2584">2584.</a> <tt>&lt;regex&gt;</tt> ECMAScript <tt>IdentityEscape</tt> is ambiguous</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-01-13 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Stephan and I are seeing differences in implementation for how non-special characters should be handled in the 
<tt>IdentityEscape</tt> part of the ECMAScript grammar. For example:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#ifdef USE_BOOST
#include &lt;boost/regex.hpp&gt;
using namespace boost;
#else
#include &lt;regex&gt;
#endif
using namespace std;

int main() {
  try {
    const regex r("\\z");
    cout &lt;&lt; "Constructed \\z." &lt;&lt; endl;
    if (regex_match("z", r))
      cout &lt;&lt; "Matches z" &lt;&lt; endl;
  } catch (const regex_error&amp; e) {
      cout &lt;&lt; e.what() &lt;&lt; endl;
  }
}
</pre></blockquote>
<p>
libstdc++, boost, and browsers I tested with (Microsoft Edge, Google Chrome) all happily interpret <tt>\z</tt>, which 
otherwise has no meaning, as an identity character escape for the letter <tt>z</tt>.
libc++ and msvc++ say that this is invalid, and throw <tt>regex_error</tt> with <tt>error_escape</tt>.
<p/>
ECMAScript 3 (which is what C++ currently points to) seems to agree with libc++ and msvc++:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SourceCharacter <b>but not</b> IdentifierPart

IdentifierPart ::
  IdentifierStart
  UnicodeCombiningMark
  UnicodeDigit
  UnicodeConnectorPunctuation
  \ UnicodeEscapeSequence

IdentifierStart ::
  UnicodeLetter
  $
  _
  \ UnicodeEscapeSequence
</pre>
</blockquote>
<p>
But this doesn't make any sense &mdash; it prohibits things like <tt>\$</tt> which users absolutely need to be able to escape. 
So let's look at ECMAScript 6. I believe this says much the same thing, but updates the spec to better handle Unicode by 
referencing what the Unicode standard says is an identifier character:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SyntaxCharacter
  /
  SourceCharacter <b>but not</b> UnicodeIDContinue
  
UnicodeIDContinue ::
  any Unicode code point with the Unicode property "ID_Continue", "Other_ID_Continue", or "Other_ID_Start"
</pre>
</blockquote>
<p>
However, ECMAScript 6 has an appendix B defining "additional features for web browsers" which says:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SourceCharacter <b>but not</b> c
</pre>
</blockquote>
<p>
which appears to agree with what libstdc++, boost, and browsers are doing.
<p/>
What should be the correct behavior here?
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Move to tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.13 [re.grammar]/3 as indicated:</p>

<blockquote>
<p>
-3- The following productions within the ECMAScript grammar are modified as follows:
</p>
<blockquote><pre>
ClassAtom ::
  -
  ClassAtomNoDash
  ClassAtomExClass
  ClassAtomCollatingElement
  ClassAtomEquivalence
  
<ins>IdentityEscape ::
  SourceCharacter <b>but not</b> c</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2692" href="#2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2696" href="#2696">2696.</a> Interaction between <tt>make_shared</tt> and <tt>enable_shared_from_this</tt> is underspecified</h3>
<p><b>Section:</b> 20.11.2.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2016-04-02 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For each public constructor of <tt>std::shared_ptr</tt>, the standard says that constructor <i>enables 
<tt>shared_from_this</tt></i> if that constructor is expected to initialize the internal <tt>weak_ptr</tt> 
of a contained <tt>enable_shared_from_this&lt;X&gt;</tt> object. But there are other ways to construct 
a <tt>shared_ptr</tt> than by using a public constructor. The template functions <tt>make_shared</tt> 
and <tt>allocate_shared</tt> both require calling a private constructor, since no public constructor 
can fulfill the requirement that at most one allocation is made. The standard does not specify that 
that private constructor enables <tt>shared_from_this</tt>; therefore in the following code:
</p>
<blockquote><pre>
struct Foo : public std::enable_shared_from_this&lt;Foo&gt; {};

int main() {
  auto p = std::make_shared&lt;Foo&gt;();
  assert(p == p-&gt;shared_from_this());
  return 0;
}
</pre></blockquote>
<p>
it is unspecified whether the assertion will fail.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan Wakely to provide updated wording.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 20.11.2.2.6 [util.smartptr.shared.create] indicated:</p>

<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks</i>: <ins>The <tt>shared_ptr</tt> constructor called by this function enables <tt>shared_from_this</tt> 
with the address of the newly constructed object of type <tt>T</tt>.</ins> Implementations should perform no more than 
one memory allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2717" href="#2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.13.4 [allocator.adaptor.members] p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2733" href="#2733">2733.</a> [fund.ts.v2] <tt>gcd</tt> / <tt>lcm</tt> and <tt>bool</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::numeric.ops.gcd], 99 [fund.ts.v2::numeric.ops.lcm] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-15 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
According to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>, <tt>gcd</tt> and 
<tt>lcm</tt> support <tt>bool</tt> as the operand type. The wording doesn't appear to cover the behavior for that case, 
since <tt>bool</tt> does not have a zero value and <tt>gcd</tt> / <tt>lcm</tt> are not normally mathematically defined 
over <tt>{false, true}</tt>.
<p/>
Presumably <tt>gcd</tt> and <tt>lcm</tt> shouldn't accept arguments of type <tt>bool</tt>.
</p>

<p><i>[2016-08-01, Walter Brown suggests wording]</i></p>

<p>
A corresponding issue has been added addressing the WP, see LWG <a href="lwg-active.html#2759">2759</a>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<ol>
<li><p>Adjust 99 [numeric.ops.gcd] p3 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Adjust 99 [numeric.ops.lcm] p3 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2739" href="#2739">2739.</a> Issue with <tt>time_point</tt> non-member subtraction with an unsigned duration</h3>
<p><b>Section:</b> 20.17.6.5 [time.point.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Winterberg <b>Opened:</b> 2016-06-23 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.point.nonmember">issues</a> in [time.point.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4594, 20.17.6.5 [time.point.nonmember], <tt>operator-(time_point, duration)</tt> is specified as:
</p>
<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt>lhs + (-rhs)</tt>.
</p>
</blockquote>
</blockquote>
<p>
When <tt>Rep2</tt> is an unsigned integral type, the behavior is quite different with arithmetic of the underlying 
integral types because of the requirement to negate the incoming duration and then add that. It also ends up 
producing different results than the underlying durations as well as the non-member <tt>time_point::operator-=</tt>.
<p/>
Consider this program:
</p>
<blockquote>
<pre>
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;

using namespace std;
using namespace std::chrono;

int main()
{
  const duration&lt;uint32_t&gt; unsignedSeconds{5};

  auto someValue = system_clock::from_time_t(200);
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';
  cout &lt;&lt; system_clock::to_time_t(someValue - unsignedSeconds) &lt;&lt; '\n';
  someValue -= unsignedSeconds;
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';

  std::chrono::seconds signedDur{200};
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
  cout &lt;&lt; (signedDur - unsignedSeconds).count() &lt;&lt; '\n';
  signedDur -= unsignedSeconds;
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
}
</pre>
</blockquote>
<p>
The goal of the program is to compare the behavior of <tt>time_point</tt> non-member <tt>operator-</tt>, 
<tt>time_point</tt> member <tt>operator-=</tt>, <tt>duration</tt> non-member <tt>operator-</tt>, and 
<tt>duration</tt> member <tt>operator-=</tt> with basically the same inputs.
<p/>
libc++ produces this output, which appears mandated by the standard:
</p>
<blockquote>
<pre>
200
4294967491
195
200
195
195
</pre>
</blockquote>
<p>
On the other hand, libstdc++ produces this output, which is what I "intuitively" expect and behaves more consistently:
</p>
<blockquote>
<pre>
200
195
195
200
195
195
</pre>
</blockquote>
<p>
Given the seemingly brief coverage of durations with unsigned representations in the standard, this seems to be an 
oversight rather than a deliberate choice for this behavior. Additionally, there may be other "unexpected" behaviors 
with durations with an unsigned representation, this is just the one that I've come across.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.17.6.5 [time.point.nonmember] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <del><tt>lhs + (-rhs)</tt></del><ins><tt><i>CT</i>(lhs.time_since_epoch() - rhs)</tt>, where 
<tt><i>CT</i></tt> is the type of the return value</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2740" href="#2740">2740.</a> <tt>constexpr optional&lt;T&gt;::operator-&gt;</tt></h3>
<p><b>Section:</b> 20.6.3.5 [optional.object.observe] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-02 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional&lt;T&gt;::operator-&gt;</tt>s are constrained to be <tt>constexpr</tt> functions
only when <tt>T</tt> is not a type with an overloaded unary <tt>operator&amp;</tt>. This
constrain comes from the need to use <tt>addressof</tt> (or a similar
mechanism), and the inability to do so in a constant expression in
C++14. Given that <tt>addressof</tt> is now <tt>constexpr</tt>, this constrain is no
longer needed.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Modify 20.6.3.5 [optional.object.observe] as indicated:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>*this</tt> contains a value.
<p/>
-2- <i>Returns:</i> <tt>val</tt>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> <del>Unless <tt>T</tt> is a user-defined type with overloaded unary <tt>operator&amp;</tt>, 
t</del><ins>T</ins>hese functions shall be <tt>constexpr</tt> functions.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2744" href="#2744">2744.</a> <tt>any</tt>'s <tt>in_place</tt> constructors</h3>
<p><b>Section:</b> 20.8.3.1 [any.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.cons">active issues</a> in [any.cons].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.cons">issues</a> in [any.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place</tt> constructor that takes an <tt>initializer_list</tt> has both a <i>Requires:</i>
for <tt>is_constructible</tt> and a <i>Remarks:</i> for <tt>is_constructible</tt>. The one
that takes just a pack has just a <i>Requires:</i> for <tt>is_constructible</tt>.
<p/>
I think both of those should be <i>Remarks:</i>, i.e. SFINAEable constraints.
Otherwise querying is_constructible for an any with <tt>in_place_t</tt> will
not give a reasonable answer, and I utterly fail to see any implementation
burden in SFINAEing those constructors.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.
<p/>
-8- <i>Effects:</i> Constructs an object of type <tt>any</tt> that contains an object of type <tt>T</tt> 
direct-initialized with <tt>std::forward&lt;ValueType&gt;(value)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution if <tt>decay_t&lt;ValueType&gt;</tt> is the
same type as <tt>any</tt> <ins>or if <tt>ValueType</tt> is a specialization of <tt>in_place_type_t</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></ins>
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2745" href="#2745">2745.</a> [fund.ts.v2] Implementability of LWG 2451</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::optional.object">issues</a> in [fund.ts.v2::optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds conditionally explicit converting constructors to <tt>optional&lt;T&gt;</tt> that accept:
</p>
<ol>
<li>Types convertible to <tt>T</tt>: <tt>template &lt;class U&gt; constexpr optional(T&amp;&amp;);</tt></li>
<li>Rvalue <tt>optional&lt;U&gt;</tt> when <tt>U&amp;&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(optional&lt;U&gt;&amp;&amp;);</tt></li>
<li>Lvalue <tt>const optional&lt;U&gt;</tt> when <tt>const U&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(const optional&lt;U&gt;&amp;);</tt></li>
</ol>
<p>
All three of these constructors are required to be <tt>constexpr</tt> "If <tt>T</tt>'s selected constructor is a 
<tt>constexpr</tt> constructor". While this is not problematic for #1, it is not possible in the current language 
to implement signatures #2 and #3 as <tt>constexpr</tt> functions for the same reasons that <tt>optional</tt>'s 
<em>non-converting</em> constructors from <tt>optional&lt;T&gt;&amp;&amp;</tt> and <tt>const optional&lt;T&gt;&amp;</tt> 
cannot be <tt>constexpr</tt>.
<p/>
We should remove the "<tt>constexpr</tt>" specifier from the declarations of the conditionally explicit converting 
constructors that accept <tt>optional&lt;U&gt;&amp;&amp;</tt> and <tt>const optional&lt;U&gt;&amp;</tt>, and strike 
the remarks requiring these constructors to be <tt>constexpr</tt>.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>
<p>This needs to be considered for C++17 as well</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>Edit 99 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  // 5.3.1, Constructors
  [&hellip;]
  template &lt;class U&gt; constexpr optional(U&amp;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(const optional&lt;U&gt;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(optional&lt;U&lt;&amp;&amp;);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>In 99 [optional.object.ctor], modify the new signature specifications added by LWG <a href="lwg-defects.html#2451">2451</a></p>

<blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-48- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-53- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2747" href="#2747">2747.</a> Possibly redundant <tt>std::move</tt> in [alg.foreach]</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-15 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.4 [alg.foreach] p3 says <i>Returns:</i> <tt>std::move(f)</tt>.
<p/>
12.8 [class.copy] says that since <tt>f</tt> is a function parameter overload resolution to select the constructor 
for the return value is first performed as if for an rvalue, so the <tt>std::move</tt> is redundant.
<p/>
It could be argued that it isn't entirely redundant, because it says that implementations can't do something slightly different like return an lvalue reference that is bound to <tt>f</tt>, which would prevent it being treated as an rvalue. We should discuss it.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 25.3.4 [alg.foreach] as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns:</i> <tt><del>std::move(</del>f<del>)</del></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2748" href="#2748">2748.</a> <tt>swappable</tt> traits for <tt>optional</tt>s</h3>
<p><b>Section:</b> 20.6.3.4 [optional.object.swap], 20.6.9 [optional.specalg] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-19 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional</tt> didn't benefit from the wording modifications by P0185 "Adding [<tt>nothrow_</tt>]<tt>swappable</tt> 
traits"; as such, it suffers from LWG <a href="lwg-defects.html#2456">2456</a>, and does not play nice with swappable traits.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3.4 [optional.object.swap] as indicated:</p>

<blockquote>
<pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote>
<pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.9 [optional.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2750" href="#2750">2750.</a> [fund.ts.v2] LWG 2451 conversion constructor constraint</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.ctor] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-20 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds a converting constructor to <tt>optional</tt> with signature:
</p>
<blockquote>
<pre>
template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);
</pre>
</blockquote>
<p>
and specifies that "This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>U</tt> is not the same type as <tt>T</tt>." 
This suffices to avoid this constructor being selected by overload resolution for arguments that should match the 
move constructor, but not for arguments that should match the copy constructor. The recent churn around tuple's 
constructors suggests that we want this constructor to not participate in overload resolution if 
<tt>remove_cv_t&lt;remove_reference_t&lt;U&gt;&gt;</tt> is the same type as <tt>T</tt>.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>In 99 [optional.object.ctor], modify as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt;
  constexpr optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-43- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt><ins>decay_t&lt;</ins>U<ins>&gt;</ins></tt> 
is not the same type as <tt>T</tt>. The constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> 
is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2753" href="#2753">2753.</a> Optional's constructors and assignments need constraints</h3>
<p><b>Section:</b> 20.6.3.1 [optional.object.ctor], 20.6.3.3 [optional.object.assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-22 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To use <tt>optional&lt;T&gt;</tt> as if it were a <tt>T</tt> in generic contexts, <tt>optional&lt;T&gt;</tt>'s "generic" 
operations must behave as do those of <tt>T</tt> under overload resolution. At minimum, <tt>optional</tt>'s constructors 
and assignment operators should not participate in overload resolution with argument types that cannot be used to 
construct/assign the contained <tt>T</tt> so that <tt>is_constructible_v&lt;optional&lt;T&gt;, Args...&gt;</tt> 
(respectively <tt>is_assignable_v&lt;optional&lt;T&gt;&amp;, RHS&gt;</tt>) is equivalent to 
<tt>is_constructible_v&lt;T, Args...&gt;</tt> (respectively <tt>is_assignable_v&lt;T&amp;, RHS&gt;</tt>).
</p>
<p>
In passing, note that the Requires element for <tt>optional</tt>'s in-place <tt>initializer_list</tt> constructor 
unnecessarily duplicates its Remarks element; it should be removed.
</p>
<p>
It should also be noted that the resolution of LWG <a href="lwg-defects.html#2451">2451</a> adds constructors to <tt>optional</tt> with 
appropriate constraints, but does not constrain the additional assignment operators. If LWG chooses to apply the 
resolution of 2451 to the WP, the Requires elements of the additional assignment operators should also be converted 
to constraints as the wording herein does for the assignment operators in N4606.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Remove 20.6.3.1 [optional.object.ctor] p3, and add a new paragraph after p6:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <em>Remarks:</em> The function shall not participate in overload resolution unless 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p7, and change p11 to:</p>

<blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <em>Remarks:</em> The expression inside <tt>noexcept</tt> is equivalent to 
<tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>. <ins>The function shall not participate in 
overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p12, and change p16 to:</p>

<blockquote>
<pre>
constexpr optional(const T&amp; v);
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-16- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p17, and change p21 to:</p>

<blockquote>
<pre>
constexpr optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-21- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p22, and change p26 to:</p>

<blockquote>
<pre>
template &lt;class... Args&gt; 
  constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <em>Remarks:</em> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload 
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p27.</p>

<blockquote>
<pre>
template &lt;class U, class... Args&gt; 
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p4, and change p8 to:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown 
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception 
safety guarantee of <tt>T</tt>'s copy assignment. <ins>The function shall not participate in overload resolution 
unless <tt>is_copy_constructible_v&lt;T&gt; &amp;&amp; is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p9, and add a new paragraph after p14:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-14- <i>Remarks:</i> [&hellip;] If an exception is thrown during the call to <tt>T</tt>'s move
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety 
guarantee of <tt>T</tt>'s move assignment.
<p/>
<ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt; &amp;&amp; is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins></p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p15, and change p19 to (yes, this wording is odd - the intent 
is that it will "do the right thing" after incorporation of LWG <a href="lwg-defects.html#2451">2451</a>):</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>v</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless <tt>is_same_v&lt;decay_t&lt;U&gt;, 
T&gt;<ins> &amp;&amp; is_constructible_v&lt;T, U&gt; &amp;&amp; is_assignable_v&lt;T&amp;, U&gt;</ins></tt> is 
<tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2755" href="#2755">2755.</a> string.view.io uses non-existent <tt>basic_string_view::to_string</tt> function</h3>
<p><b>Section:</b> 21.4.4 [string.view.io], 21.3.2.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Baker <b>Opened:</b> 2016-07-26 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In looking at N4606, [string.view.io] has an <i>Effects</i> clause that references <tt>basic_string_view::to_string</tt> 
which no longer exists after the application of <a href="http://wg21.link/p0254r2">P0254R2</a>.
</p>

<p><i>[2016-07-26, Marshall suggests concrete wording]</i></p>

<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 21.3.2.9 [string.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT, traits, Allocator&gt;&amp; str);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Equivalent to: <tt>return os &lt;&lt; basic_string_view&lt;charT, 
traits&gt;(str);</tt></ins><del>Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) 
of <tt>os</tt>. Forms a character sequence <tt>seq</tt>, initially consisting of the elements defined by the 
range <tt>[str.begin(), str.end())</tt>. Determines padding for <tt>seq</tt> as described in 
27.7.3.6.1 [ostream.formatted.reqmts]. Then inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, 
where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</del>
<p/>
<del>-6- <i>Returns:</i> <tt>os</tt></del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 21.4.4 [string.view.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> <del>Equivalent to: <tt>return os &lt;&lt; str.to_string();</tt></del><ins>Behaves 
as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>os</tt>. Forms a character 
sequence <tt>seq</tt>, initially consisting of the elements defined by the range <tt>[str.begin(), 
str.end())</tt>. Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Then 
inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</ins>
<p/>
<ins>-?- <i>Returns:</i> <tt>os</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2759" href="#2759">2759.</a> <tt>gcd</tt> / <tt>lcm</tt> and <tt>bool</tt> for the WP</h3>
<p><b>Section:</b> 26.8.13 [numeric.ops.gcd], 26.8.14 [numeric.ops.lcm] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2016-08-01 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the acceptance of <tt>gcd</tt> and <tt>lcm</tt> in the working draft, the same problem as pointed out by
LWG <a href="lwg-active.html#2733">2733</a> exists here as well and should be fixed accordingly.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Adjust 26.8.13 [numeric.ops.gcd] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Adjust 26.8.14 [numeric.ops.lcm] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
