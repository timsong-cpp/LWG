<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2011-12-06 at 21:12:16 UTC</p>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a 
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>&#xB1HUGE_VALF</code>,
<code>&#xB1HUGE_VAL</code> and <code>&#xB1HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Some concern that this is changing the specification for an existing C++03 function, but it was 
pointed out that this was underspecified as resolved by issue 23.  This is clean-up for that 
issue in turn. Some concern that we are trying to solve the same problem in both clause 22 and 27.
</p>
<p>
Bill: There's a change here as to whether val is stored to in an error case.
</p>
<p>
Pablo: Don't think this changes whether val is stored to or not, but changes the value that is stored.
</p>
<p>
Bill: Remembers having skirmishes with customers and testers as to whether val is stored to, and the resolution was not to store in error cases.
</p>
<p>
Howard: Believes since C++03 we made a change to always store in overflow.
</p>
<p>
Everyone took some time to review the issue.
</p>
<p>
Pablo: C++98 definitely did not store any value during an error condition.
</p>
<p>
Dietmar: Depends on the question of what is considered an error, and whether overflow is an error or not, which was the crux of LWG 23.
</p>
<p>
Pablo: Yes, but given the "zero, if the conversion function fails to convert the entire field", we are requiring every error condition to store.
</p>
<p>
Bill: When did this happen?
</p>
<p>
Alisdair: One of the last two or three meetings.
</p>
<p>
Dietmar: To store a value in case of failure is a very bad idea.
</p>
<p>
Move to Open, needs more study.
</p>
</blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good, no-one sure why this was held back before.  Move to Review.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good.  Move to Review.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.4.2 [unord.map.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.5.2 [unord.multimap.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 [unord.set.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 [unord.multiset.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2011-11-21</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.6.12 [specialized.algorithms]/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consider to await the paper.
</p>





<hr>
<h3><a name="1450"></a>1450. [FCD] Contradiction in regex_constants</h3>
<p><b>Section:</b> 28.5.2 [re.matchflag] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-127</b></p>

<p>
The Bitmask Type requirements in 17.5.2.1.3 [bitmask.types] p.3 say that
all elements on a bitmask type have distinct values, but
28.5.2 [re.matchflag] defines <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> as elements of the
bitmask type <tt>regex_constants::match_flag_type</tt>, both with
value 0. This is a contradiction.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
One of the bitmask elements should be removed
from the declaration and should be defined
separately, in the same manner as
<tt>ios_base::adjustfield</tt>, <tt>ios_base::basefield</tt> and
<tt>ios_base::floatfield</tt> are defined by 27.5.3.1.2 [ios::fmtflags] p.2
and Table 120. These are constants of a bitmask
type, but are not distinct elements, they have
more than one value set in the bitmask.
<tt>regex_constants::format_default</tt> should be
specified as a constant with the same value as
<tt>regex_constants::match_default</tt>.
</p></blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>

<p>
Strictly speaking, a bitmask type cannot have any element of value 0 at all, because
any such value would contradict the requirement expressed in 17.5.2.1.3 [bitmask.types] p. 3:
</p>
<blockquote><p>
for any pair <em>Ci</em> and <em>Cj</em>, <em>Ci</em> &amp; <em>Ci</em> is nonzero
</p></blockquote>
<p>
So, actually <em>both</em> <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> are only constants of the type
<tt>regex_constants::match_flag_type</tt>, and no bitmask elements.
</p>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The proposed resolution is written against N3126 and considered as a further improvement
of the fixes suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.
</p>

<blockquote>
<p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
</p>
<blockquote><p>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
Matching a regular expression against a sequence of characters [first,last) proceeds according to the
rules of the grammar specified for the regular expression object, modified according to the effects listed in
Table 136 for any bitmask elements set. <ins>Type <tt>regex_constants::match_flag_type</tt> also defines the 
constants <tt>regex_constants::match_default</tt> and <tt>regex_constants::format_default</tt>.</ins>
</p></blockquote>
</blockquote>

<p><i>[
2011 Bloomington
]</i></p>


<p>
It appears the key problem is the phrasing of the bitmask requirements.  Jeremiah supplies updated wording.
</p>

<p>
Pete Becker has also provided an alternative resolution.
</p>

<p>
Ammend 17.5.2.1.3 [bitmask.types]:
</p>
<p>
Change the list of values for "enum bit mask" in p2 from
</p>
<p>
<tt><i>V0</i> = 1 &lt;&lt; 0, <i>V1</i> = 1 &lt;&lt; 1, <i>V2</i> = 1 &lt;&lt; 2, <i>V3</i> = 1 &lt;&lt; 3, ...</tt>.
</p>
<p>
to
</p>
<p>
<tt><i>V0</i> = 0, <i>V1</i> = 1 &lt;&lt; 0, <i>V2</i> = 1 &lt;&lt; 1, <i>V3</i> = 1 &lt;&lt; 2,  ...</tt>.
</p>
<p>
Here, the names <i>C0</i>, <i>C1</i>, etc. represent <i>bitmask elements</i> for this particular
bitmask type. All such <ins>non-zero</ins> elements have distinct values such that, for any pair
<i>Ci</i> and <i>Cj</i> <ins>where <i>i</i> != <i>j</i></ins>, <del><i>Ci &amp; Ci</i> is nonzero
and</del> <i>Ci &amp; Cj</i> is zero.
</p>
<p>
Change bullet 3 of paragraph 4:
</p>
<p>
<del>The</del><ins>A non-zero</ins> value Y is set in the object X if the expression X &amp; Y is nonzero.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Ammend 17.5.2.1.3 [bitmask.types] p3:
</p>
<p>
Here, the names <i>C0</i>, <i>C1</i>, etc. represent <i>bitmask elements</i> for this particular
bitmask type. All such elements have distinct<ins>, non-zero</ins> values such that, for any pair
<i>Ci</i> and <i>Cj</i> <ins>where <i>i</i> != <i>j</i>,</ins> <i>Ci &amp; Ci</i> is nonzero
and <i>Ci &amp; Cj</i> is zero. <ins>Additionally, the value 0 is used to represent an
<i>empty bitmask</i>, in which no bitmask elements are set.</ins>
</p>

<p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
</p>
<blockquote><p>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
<ins>The constants of that type, except for <tt>match_default</tt> and <tt>format_default</tt>, are bitmask
elements. The <tt>match_default</tt> and <tt>format_default</tt> constants are empty bitmasks.</ins> Matching
a regular expression against a sequence of characters [first,last) proceeds according to the rules of the
grammar specified for the regular expression object, modified according to the effects listed in Table 136
for any bitmask elements set.
</p></blockquote>





<hr>
<h3><a name="1526"></a>1526. [FCD] C++ should not impose thread safety requirements on C99 library implementations</h3>
<p><b>Section:</b> 17.6.5.9 [res.on.data.races] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2011-03-24 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-111</b></p>

<p>Section 17.6.5.9 [res.on.data.races], Data Race Avoidance, requires the C++ Standard Library to avoid data races 
that might otherwise result from two threads making calls to C++ Standard Library functions on 
distinct objects. The C standard library is part of the C++ Standard Library and some C++ Standary library 
functions (parts of the Localization library, as well as Numeric Conversions in 21.5), are specified 
to make use of the C standard library. Therefore, the C++ standard indirectly imposes a requirement 
on the thread safety of the C standard library. However, since the C standard does not address the 
concept of thread safety conforming C implementations exist that do no provide such guarantees. 
This conflict needs to be reconciled.</p>

<p>Suggested resolution by national body comment:</p>

<blockquote><p>
remove the requirement to make use of <tt>strtol()</tt> and <tt>sprintf()</tt> since these functions depend on the 
global C locale and thus cannot be made thread safe.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Deferred</p>

<p><i>[
2011 Bloomington
]</i></p>

<p>
Alisdair: PJ, does this cause a problem in C?
</p>
<p>
PJ: Every implementation know of is thread safe.
</p>
<p>
Pete: There a couple of effects that are specified on strtol() and sprintf() which is a problem.
</p>
<p>
PJ: When C++ talks about C calls it should be "as if" calling the function.
</p>
<p>
Pete: Culprit is to string stuff. My fault.
</p>
<p>
PJ: Not your fault. You did what you were told. Distinct resolution to change wording.
</p>
<p>
Dietmar: What would we break if we change it back?
</p>
<p>
Pete: Nothing. If implemented on top of thread safe C library you are just fine.
</p>
<p>
Alisdair: Anyone want to clean up wording and put it back to what Pete gave us?
</p>
<p>
Alisdair: No volunteers. Do we want to mark as NAD? We could leave it as deferred.
</p>
<p>
Stefanus: Did original submitter care about this?
</p>
<p>
Lawrence: There is some work to make local calls thread safe. The resolution would be to call those thread safe version.
</p>
<p>
Pete: "As if called under single threaded C program"
</p>
<p>
<b>Action Item</b> (Alisdair): Write wording for this issue.
</p>



<p><b>Rationale:</b></p><p>No consensus to make a change at this time</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2003"></a>2003. String exception inconsistency in erase.</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jos&eacute; Daniel Garc&iacute;a S&aacute;nchez <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 21.4.1 [string.require]p3 states:
</p>
<blockquote><p>
No <tt>erase()</tt> or <tt>pop_back()</tt> member function shall throw
any exceptions.
</p></blockquote>
<p>
However in 21.4.6.5 [string::erase] p2 the first version of <tt>erase</tt> has
</p>
<blockquote><p>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos > size()</tt>.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Beman: Don't want to just change this, can we just say "unless otherwise specified"?
<p/>
Alisdair: Leave open, but update proposed resolution to say something like "unless otherwise specified".
<p/>
General agreement that it should be corrected but not a stop-ship.
<p/>
Action: Update proposed wording for issue 2003 as above, but leave Open. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update [string.require]p/3:
</p>
<blockquote><p>
3 No <del><tt>erase()</tt> or</del> <tt>pop_back()</tt> member function
shall throw any exceptions.
</p></blockquote>





<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.4.4.4 [map.modifiers], 23.4.5.3 [multimap.modifiers], X [unord.map.modifiers], X [unord.multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2011-11-25</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
</p>
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
<p>
now has an added Remarks paragraph:
</p>
<blockquote><p>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</p></blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
<p/>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
<p/>
Daniel's Proposed resolution (not current):
</p>

<blockquote class="note">
<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We need <tt>is_convertible</tt>, not <tt>is_constructible</tt>, both in ordered and unordered containers. 
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The effects of these inserts can be concisely stated in terms of emplace().
Also, the correct term is "EmplaceConstructible", not "constructible".
</p>

<p>
New wording by Pablo, eliminating duplicate requirements already implied by the effects clause.  Move to Review.
</p>

<p><i>[
2011-10-02 Daniel comments and refines the proposed wording
]</i></p>


<blockquote><p>
Unfortunately the template constraints expressed as "<tt>P</tt> is implicitly convertible to <tt>value_type</tt>"
reject the intended effect to support move-only key types, which was the original intention when
the library became move-enabled through the rvalue-reference proposals by Howard (This can clearly be deduced
from existing carefully selected wording that emphasizes that <tt>CopyConstructible</tt> is only required
for special situations involving lvalues or const rvalues as arguments). The root of the problem is based
on current core rules, where an "implicitly converted" value has copy-initialization semantics. Consider
a move-only key type <tt>KM</tt>, some mapped type <tt>T</tt>, and a source value <tt>p</tt> of type <tt>P</tt> 
equal to <tt>std::pair&lt;KM, T&gt;</tt>, this is equivalent to:
</p>
<blockquote><pre>
std::pair&lt;const KM, T&gt; dest = std::move(p);
</pre></blockquote>
<p>
Now 8.5 [dcl.init] p16 b6 sb2 says that the effects of this heterogeneous copy-initialization (<tt>p</tt>
has a different type than <tt>dest</tt>) are as-if a temporary of the target type <tt>std::pair&lt;const KM, T&gt;</tt>
is produced from the rvalue <tt>p</tt> of type <tt>P</tt> (which is fine), and this temporary is used to initialize 
<tt>dest</tt>. This second step cannot succeed, because we cannot move from <tt>const KM</tt> to <tt>const KM</tt>. This 
means that <tt>std::is_convertible&lt;P, std::pair&lt;const KM, T&gt;&gt;::value</tt> is false.
<p/>
But the actual code that is required (with the default allocator) is simply a direct-initialization
from <tt>P</tt> to <tt>value_type</tt>, so imposing an implicit conversion is more than necessary. Therefore
I strongly recommend to reduce the "overload participation" constraint to  
<tt>std::is_constructible&lt;std::pair&lt;const KM, T&gt;, P&gt;::value</tt> instead. This change is the
only change that has been performed to the previous proposed wording from Pablo shown below. 
</p></blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
<del>1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.</del>
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: The first form is equivalent to
<tt>return emplace(std::forward&lt;P&gt;(x))</tt>.
The second form is equivalent to
<tt>return emplace_hint(position, std::forward&lt;P&gt;(x))</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless 
<tt>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</tt> is true.</ins>
<p/>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
<del>1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.</del>
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: The first form is equivalent to
<tt>return emplace(std::forward&lt;P&gt;(x))</tt>.
The second form is equivalent to
<tt>return emplace_hint(position, std::forward&lt;P&gt;(x))</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless 
<tt>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</tt> is true.</ins>
<p/>
</blockquote></blockquote>
</li>
<li>Change 23.5.4.4 [unord.map.modifers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt;
pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre>
<blockquote>
<del>1 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
2 <em>Effects</em>:
<ins>equivalent to <tt>return emplace(std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>3 <em>Returns</em>: The bool component of the returned pair object indicates whether the insertion took place
and the iterator component points to the element with key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>4 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>5</del><ins>3</ins> <em>Remarks</em>: This signature shall not participate in overload resolution unless 
<del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
<p/>
</blockquote>
<pre>template &lt;class P&gt;
iterator insert(const_iterator hint, P&amp;&amp; obj);
</pre>
<blockquote>
<del>6 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
<del>7</del><em>?</em> <em>Effects</em>:
<ins>equivalent to <tt>return emplace_hint(hint, std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(obj)</tt>. The iterator hint is a hint pointing to where the
search should start.</del>
<p/>
<del>8 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of 
<tt>value_type(obj)</tt>.</del>
<p/>
<del>9 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>10</del><em>?</em> <em>Remarks</em>: This signature shall not participate in overload resolution unless 
<del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote></blockquote>
</li>
<li>Change 23.5.5.3 [unord.multimap.modifers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt;
iterator insert(P&amp;&amp; obj);
</pre>
<blockquote>
<del>1 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
2 <em>Effects</em>:
<ins>equivalent to <tt>return emplace(std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt>.</del>
<p/>
<del>3 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>4 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>5</del><ins>3</ins> <em>Remarks</em>: This signature shall not participate in overload resolution 
unless <del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote>
<pre>
template &lt;class P&gt;
iterator insert(const_iterator hint, P&amp;&amp; obj);
</pre>
<blockquote>
<del>6 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
<del>7</del><em>?</em> <em>Effects</em>:
<ins>equivalent to <tt>return emplace_hint(hint, std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt>. The iterator hint is a hint pointing to where the search
should start.</del>
<p/>
<del>8 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type</tt>(obj).</del>
<p/>
<del>9 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>10</del><ins><em>?</em></ins> <em>Remarks</em>: This signature shall not participate in overload resolution 
unless <del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2011"></a>2011. Unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]&#47;5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
<i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]). After constructing 
a <tt>sentry</tt> object, if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, 
determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]&#47;5: 
</p>

<blockquote>
<p>
[&hellip;] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>

<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Consensus that all known implementations are consistent, and disagree with the
standard. Preference is to fix the standard before implementations start trying
to conform to the current spec, as the current implementations have the preferred
form. Howard volunteered to drught for Madrid, move to Open.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel Kr&uuml;gler volunteered to provide wording, interacting with Dietmar and
Bill. 
</p>

<p><i>[2011-06-24 Daniel comments and provides wording]</i></p>


<p>
The same problem applies to the output provided by <tt>const char*</tt> and similar
character sequences as of 27.7.3.6.4 [ostream.inserters.character] p. 5. and even for
single character output (!) as described in 27.7.3.6.4 [ostream.inserters.character] p. 1,
just consider the character value '-' where '-' is the sign character. In this case
Table 91 &mdash; "Fill padding" requires to pad after the sign, i.e. the output
for the program
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   char c = '-'; 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(2) &lt;&lt; c &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
According to the current wording this program should output "<tt>-*</tt>", but
all tested implementations output "<tt>*-</tt>" instead.

<p/>
I suggest to replace the reference to 22.4.2.2.2 [facet.num.put.virtuals] in all three places. 
It is not very complicated to describe the padding rules for simple character sequences "inline". 
A similar approach is used as for the <tt>money_put</tt> functions.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Move to Review, the resolution seems correct but it would be nice if some factoring of the common words were proposed.
</p>



<p><b>Proposed resolution:</b></p>
<p>
The new wording refers to the FDIS numbering.
</p>
<ol>
<li><p>Change 21.4.8.9 [string.io]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
-5- <i>Effects</i>: Behaves as a formatted output function ([ostream.formatted.reqmts]). After constructing a sentry object,
if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, determines padding as <del>described
in [facet.num.put.virtuals],</del><ins>follows: A <tt>charT</tt> character sequence is produced, initially consisting of 
the elements defined by the range <tt>[str.begin(), str.end())</tt>. If <tt>str.size()</tt> is less than <tt>os.width()</tt>, 
then enough copies of <tt>os.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>os.width()</tt> 
characters. If <tt>(os.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters 
are placed after the character sequence; otherwise, they are placed before the character sequence. T</ins><del>t</del>hen 
inserts the resulting sequence of characters <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where 
<tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;1 as indicated (An additional editorial
fix is suggested for the first prototype declaration):</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c<del>}</del><ins>)</ins>;
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         unsigned char c);
</pre><blockquote><p>
-1- <i>Effects</i>: Behaves like a formatted inserter (as described in [ostream.formatted.reqmts]) of <tt>out</tt>. 
After a sentry object is constructed it inserts characters. In case <tt>c</tt> has type <tt>char</tt> and the 
character type of the stream is not <tt>char</tt>, then the character to be inserted is <tt>out.widen(c)</tt>; 
otherwise the character is <tt>c</tt>. Padding is determined as <del>described in [facet.num.put.virtuals]</del><ins>follows: 
A character sequence is produced, initially consisting of the insertion character. If <tt>out.width()</tt> is greater
than one, then enough copies of <tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of 
<tt>out.width()</tt> characters. If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, 
the fill characters are placed after the insertion character; otherwise, they are placed before the insertion 
character</ins>. <del><tt>width(0)</tt> is called.</del> The insertion character and any required padding are 
inserted into <tt>out</tt><ins>; then calls <tt>os.width(0)</tt></ins>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote><p>
[&hellip;]
<p/>
-5- Padding is determined as <del>described in [facet.num.put.virtuals]. The <tt>n</tt> characters starting at <tt>s</tt> 
are widened using <tt>out.widen</tt> ([basic.ios.members])</del><ins>follows: A character sequence is produced, initially 
consisting of the elements defined by the <tt>n</tt> characters starting at <tt>s</tt> widened using 
<tt>out.widen</tt> ([basic.ios.members]). If <tt>n</tt> is less than <tt>out.width()</tt>, then enough copies of 
<tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>out.width()</tt> characters. 
If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters are 
placed after the character sequence; otherwise, they are placed before the character sequence</ins>. The 
widened characters and any required padding are inserted into <tt>out</tt>. Calls <tt>width(0)</tt>.
</p></blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2012"></a>2012. Associative maps should insert <tt>pair</tt>, not <tt>tuple</tt></h3>
<p><b>Section:</b> 23.4 [associative] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-10-29 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something strange in the paragraphs 23.4.4.4 [map.modifiers] and 23.4.5.3 [multimap.modifiers]:
they both talk about <tt>tuple&lt;const key_type, mapped_type&gt;</tt> but I think they
should be talking about <tt>pair&lt;const key_type, mapped_type&gt;</tt> because, among
other reasons, a <tt>tuple</tt> is not convertible to a <tt>pair</tt>. If I replace <tt>tuple</tt>
with <tt>pair</tt> everything makes sense to me.
<p/>
The proposed resolution is obvious. 
</p>

<p><i>[
2010-11-07 Daniel comments
]</i></p>


<p>
This is by far not the only necessary fix within both sub-clauses. For details see the 2010-10-29 comment in 
<a href="lwg-active.html#2005">2005</a>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Paolo: Don't think we can do it now.
<p/>
Daniel K: Agrees. 
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus that this issue will be resolved by <a href="lwg-active.html#2005">2005</a>, but held open until that issue is resolved.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Apply the resolution proposed by the 2010-10-29 comment in <a href="lwg-active.html#2005">2005</a>.
</p>





<hr>
<h3><a name="2016"></a>2016. <tt>Allocators</tt> must be no-throw <i>swappable</i></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-11-17 <b>Last modified:</b> 2011-11-19</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Batavia meeting it turned out that there is a definition
hole for types satisfying the <tt>Allocators</tt> requirements: The problem
became obvious when it was discussed whether all <tt>swap</tt> functions 
of <tt>Containers</tt> with internal data handles can be safely tagged
with <tt>noexcept</tt> or not. While it is correct that the implicit
<tt>swap</tt> function of an allocator is required to be a no-throw
operation (because move/copy-constructors and assignment operators are
required to be no-throw functions), there are no such requirements
for specialized <tt>swap</tt> overloads for a particular allocator.
<p/>
But this requirement is essential because the <tt>Containers</tt> are
required to support <i>swappable</i> <tt>Allocators</tt>, when the value
<tt>allocator_traits&lt;&gt;::propagate_on_container_swap</tt> evaluates
to <tt>true</tt>.
</p>
<p><i>[2011-02-10 Alberto, Daniel, and Pablo collaborated on the proposed wording]</i></p>

<p>
The proposed resolution (based on N3225) attempts to solve the following problems:
</p>
<ol>
<li>Table 44 &mdash; Allocator requirements, expression rows 
<tt>X::propagate_on_container_copy_assignment</tt>, <tt>X::propagate_on_container_move_assignment</tt>, and
<tt>X::propagate_on_container_swap</tt> only describe operations, but no requirements. In fact, if and only
if these compile-time predicates evaluate to <tt>true</tt>, the <em>additional</em> requirements
<tt>CopyAssignable</tt>,  no-throw <tt>MoveAssignable</tt>, and no-throw lvalue <tt>Swappable</tt>, 
respectively, are imposed on the allocator types.</li>
<li>23.2.1 [container.requirements.general] p. 9 misses to refer to the correct swap conditions: The current wording does not relate to
17.6.3.2 [swappable.requirements] as it should and omits to mention that lvalues shall be swapped. Additional there is one
situation described twice in p. 8 and p. 9 (undefined behaviour unless <tt>a.get_allocator() == b.get_allocator()</tt>
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value == true</tt>), which should be cleaned up.</li>
</ol>

<p><i>[2011-04-08 Pablo comments]</i></p>

<p>
I'm implementing a version of list now and I actually do find it impossible to write an exception-safe assignment 
operator unless I can assume that allocator assignment does not throw.  (The problem is that I use a sentinel node 
and I need to allocate a new sentinel using the new allocator without destroying the old one -- then swap the 
allocator and sentinel pointer in atomically, without risk of an exception leaving one inconsistent with the other.
<p/>
Please update the proposed resolution to add the nothrow requirement to copy-assignment.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Adapt the following three rows from Table 44 &mdash; Allocator requirements:
</p>

<blockquote>
<table border="1">
<caption>Table 44 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td><tt>X::propagate_on_container_copy_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be copied<br/> 
when the client container is copy-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_move_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be moved<br/>
when the client container is move-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_swap</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be swapped<br/>
when the client container is swapped. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

</table>
</blockquote>


</li>

<li>
<p>Following 17.6.3.5 [allocator.requirements] p. 3 insert a new normative paragraph:</p>

<blockquote><p>
<ins>Note B: If <tt>X::propagate_on_container_copy_assignment::value</tt> is true, <tt>X</tt> shall 
satisfy the <tt>CopyAssignable</tt> requirements (Table 39  [copyassignable]) and the copy 
operation shall not throw exceptions. If <tt>X::propagate_on_container_move_assignment::value</tt> is 
true, <tt>X</tt> shall satisfy the <tt>MoveAssignable</tt> requirements (Table 38  [moveassignable]) 
and the move operation shall not throw exceptions. If <tt>X::propagate_on_container_swap::value</tt> is 
true, lvalues of <tt>X</tt> shall be swappable (17.6.3.2 [swappable.requirements]) and the <tt>swap</tt> 
operation shall not throw exceptions.</ins>
</p></blockquote>
</li>

<li>
<p>Modify 23.2.1 [container.requirements.general] p. 8 and p. 9 as indicated:</p>

<blockquote><p>
8 - [..] The allocator may be replaced only via assignment or <tt>swap()</tt>. Allocator replacement is 
performed by copy assignment, move assignment, or swapping of the allocator only if 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</tt>,
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt>, 
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true 
within the implementation of the corresponding container operation. <del>The behavior of a call to 
a container's <tt>swap</tt> function is undefined unless the objects being swapped have allocators that compare 
equal or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true</del>. In all 
container types defined in this Clause, the member <tt>get_allocator()</tt> returns a copy of the allocator 
used to construct the container or, if that allocator has been replaced, a copy of the most recent replacement.
<p/>
9 - The expression <tt>a.swap(b)</tt>, for containers <tt>a</tt> and <tt>b</tt> of a standard container type 
other than <tt>array</tt>, shall exchange the values of <tt>a</tt> and <tt>b</tt> without invoking any move, 
copy, or swap operations on the individual container elements. <ins>Lvalues of a</ins><del>A</del>ny <tt>Compare</tt>, 
<tt>Pred</tt>, or <tt>Hash</tt> object<del>s</del> belonging to <tt>a</tt> and <tt>b</tt> shall be swappable 
and shall be exchanged by <del>unqualified calls to non-member</del> <ins>calling</ins> <tt>swap</tt> 
<ins>as described in 17.6.3.2 [swappable.requirements]</ins>. If <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> 
is <tt>true</tt>, then <ins>lvalues of <tt>allocator_type</tt> shall be swappable and</ins> the allocators of <tt>a</tt> and 
<tt>b</tt> shall also be exchanged using <ins>a</ins> <del>an unqualified call to non-member</del> 
<tt>swap</tt> <ins>call</ins> <ins>as described in 17.6.3.2 [swappable.requirements]</ins>. Otherwise, 
<del>they</del><ins>the allocators</ins> shall not be swapped, and the behavior is undefined unless
<tt>a.get_allocator() == b.get_allocator()</tt>. Every iterator referring to an element in one container before
the swap shall refer to the same element in the other container after the swap. It is unspecified whether an
iterator with value <tt>a.end()</tt> before the swap will have value <tt>b.end()</tt> after the swap.
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2018"></a>2018. <tt>regex_traits::isctype</tt> Returns clause is wrong</h3>
<p><b>Section:</b> 28.7 [re.traits] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>28.7 [re.traits] p. 12 says:</p>

<blockquote><p>
returns true if <tt>f</tt> bitwise or&#39;ed with the result of calling
<tt>lookup_classname</tt> with an iterator pair that designates the character
sequence &quot;w&quot; is not equal to <tt>0</tt> and <tt>c == '_'</tt>
</p></blockquote>

<p>
If the bitmask value corresponding to &quot;w&quot; has a non-zero value (which
it must do) then the bitwise or with any value is also non-zero, and
so <tt>isctype('_', f)</tt> returns true for any <tt>f</tt>. Obviously this is wrong,
since <tt>'_'</tt> is not in every <tt>ctype</tt> category.
</p>

<p>
There&#39;s a similar problem with the following phrases discussing the
&quot;blank&quot; char class.
</p>

<p><i>[2011-05-06: Jonathan Wakely comments and provides suggested wording]</i></p>


<p>
DR <a href="lwg-defects.html#2019">2019</a> added <tt>isblank</tt> support to <tt>&lt;locale&gt;</tt> which simplifies the
definition of <tt>regex_traits::isctype</tt> by removing the special case for the "blank" class.
<p/>
My suggestion for 2018 is to add a new table replacing the lists of
recognized names in the Remarks clause of <tt>regex_traits::lookup_classname</tt>. 
I then refer to that table in the Returns clause of <tt>regex_traits::isctype</tt> 
to expand on the "in an unspecified manner" wording which is too vague. The conversion 
can now be described using the "is set" term defined by 17.5.2.1.3 [bitmask.types] and
the new table to convey the intented relationship between e.g.
[[:digit:]] and <tt>ctype_base::digit</tt>, which is not actually stated in the
FDIS.
<p/>
The effects of <tt>isctype</tt> can then most easily be described in code,
given an "exposition only" function prototype to do the not-quite-so-unspecified conversion 
from <tt>char_class_type</tt> to <tt>ctype_base::mask</tt>.
<p/>
The core of LWG 2018 is the "bitwise or'ed" wording which gives the
wrong result, always evaluating to true for all values of <tt>f</tt>. That is
replaced by the condition <tt>(f&amp;x) == x</tt> where <tt>x</tt> is the result of calling
<tt>lookup_classname</tt> with "w".  I believe that's necessary, because the
"w" class could be implemented by an internal "underscore" class i.e.
<tt>x = _Alnum|_Underscore</tt> in which case <tt>(f&amp;x) != 0</tt> would give the wrong
result when <tt>f==_Alnum</tt>.
<p/>
The proposed resolution also makes use of <tt>ctype::widen</tt> which addresses
the problem that the current wording only talks about "w" and '_' which assumes 
<tt>charT</tt> is char.  There's still room for improvement here:
the regex grammar in 28.13 [re.grammar] says that the class names in the
table should always be recognized, implying that e.g. U"digit" should
be recognized by <tt>regex_traits&lt;char32_t&gt;</tt>, but the specification of
<tt>regex_traits::lookup_classname</tt> doesn't cover that, only mentioning
<tt>char</tt> and <tt>wchar_t</tt>.  Maybe the table should not distinguish narrow and
wide strings, but should just have one column and add wording to say
that <tt>regex_traits</tt> widens the name as if by using <tt>use_facet&lt;ctype&lt;charT&gt;&gt;::widen()</tt>.
<p/>
Another possible improvement would be to allow additional
implementation-defined extensions in <tt>isctype</tt>. An implementation is
allowed to support additional class names in <tt>lookup_classname</tt>, e.g.
[[:octdigit:]] for [0-7] or [[:bindigit:]] for [01], but the current
definition of isctype provides no way to use them unless <tt>ctype_base::mask</tt> 
also supports them.
</p>

<p><i>[2011-05-10: Alberto and Daniel perform minor fixes in the P&#47;R]</i></p>


<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus that this looks to be a correct solution, and the presentation as a table is a big improvement.
</p>

<p>
Concern that the middle section wording is a little muddled and confusing, Stefanus volunteered to reword.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify 28.7 [re.traits] p. 10 as indicated:</p>
<blockquote><pre>
template &lt;class ForwardIterator&gt;
  char_class_type lookup_classname(
    ForwardIterator first, ForwardIterator last, bool icase = false) const;
</pre><blockquote><p>
-9- <i>Returns</i>: an unspecified value that represents the character classification named by the character
sequence designated by the iterator range [<tt>first</tt>,<tt>last</tt>). If the parameter <tt>icase</tt> is true then the
returned mask identifies the character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being matched.(footnote 335) The value returned shall
be independent of the case of the characters in the character sequence. If the name is not recognized
then returns a value that compares equal to 0.
<p/>
-10- <i>Remarks</i>: For <tt>regex_traits&lt;char&gt;</tt>, at least the <del>names "d", "w", "s", "alnum", "alpha", "blank",
"cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper" and "xdigit"</del><ins>narrow character
names in Table X</ins> shall be recognized. For <tt>regex_traits&lt;wchar_t&gt;</tt>, at least the <del>names L"d", L"w", 
L"s", L"alnum", L"alpha", L"blank", L"cntrl", L"digit", L"graph", L"lower", L"print", L"punct", L"space", L"upper" and 
L"xdigit"</del><ins>wide character names in Table X</ins> shall be recognized.
</p></blockquote></blockquote>
</li>

<li><p>Modify 28.7 [re.traits] p. 12 as indicated:</p>
<blockquote><pre>
bool isctype(charT c, char_class_type f) const;
</pre><blockquote><p>
-11- <i>Effects</i>: Determines if the character <tt>c</tt> is a member of the character classification represented by <tt>f</tt>.
<p/>
-12- <i>Returns</i>: Converts <tt>f</tt> into a value <tt>m</tt> of type <tt>std::ctype_base::mask</tt> in an unspecified manner, <del>and
returns true if <tt>use_facet&lt;ctype&lt;charT&gt; &gt;(getloc()).is(m, c)</tt> is true. Otherwise returns true
if <tt>f</tt> bitwise or'ed with the result of calling <tt>lookup_classname</tt> with an iterator pair that designates
the character sequence "w" is not equal to <tt>0</tt> and <tt>c == '_'</tt>, or if <tt>f</tt> bitwise or'ed with the result of
calling <tt>lookup_classname</tt> with an iterator pair that designates the character sequence "blank" is not
equal to <tt>0</tt> and <tt>c</tt> is one of an implementation-defined subset of the characters for which 
<tt>isspace(c, getloc())</tt> returns true, otherwise returns false.</del><ins>except that when <tt>f</tt> represents 
membership of a character class named in Table X, the corresponding <tt>ctype_base::mask</tt> value shall be set in <tt>m</tt>. 
Given the function prototype</ins>
</p><blockquote><pre>
<ins>template&lt;class C&gt;
   ctype_base::mask convert(typename regex_traits&lt;C&gt;::char_class_type);</ins>
</pre></blockquote>
<p><ins>the result is determined as if by</ins>
</p><blockquote><pre><ins>
ctype_base::mask m = convert&lt;charT&gt;(f);
const ctype&lt;charT&gt;&amp; ct = use_facet&lt;ctype&lt;charT&gt; &gt;(getloc());
if (ct.is(m, c))
  return true;
charT w[1] = { ct.widen('w') };
char_class_type x = lookup_classname(w, w+1);
if ((f&amp;x) == x &amp;&amp; c == ct.widen('_'))
  return true;
return false;
</ins></pre></blockquote>
<p><ins>[<i>Example</i>:</ins>
</p><blockquote><pre><ins>
regex_traits&lt;char&gt; t;
string d("d");
string u("upper");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert&lt;char&gt;(f); // m == ctype_base::digit|ctype_base::upper
</ins></pre></blockquote>
<p><ins>&mdash; <i>end example</i>]</ins></p>
<p><ins>[<i>Example</i>:</ins>
</p><blockquote><pre><ins>
regex_traits&lt;char&gt; t;
string w("w");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f); // returns true
t.isctype('_', f); // returns true
t.isctype(' ', f); // returns false
</ins></pre></blockquote>
<p><ins>&mdash; <i>end example</i>]</ins>
</p></blockquote></blockquote>
</li>

<li><p>At the end of [re.traits] add a new Table X &mdash; Character class names and corresponding ctype masks:</p>

<blockquote>
<table border="1">
<caption>Table X &mdash; Character class names and corresponding ctype masks</caption>

<tr>
<th>Narrow character name</th>
<th>Wide character name</th>
<th>Corresponding <tt>ctype_base::mask</tt> value</th>
</tr>
 
<tr>
<td><tt>"alnum"</tt></td>
<td><tt>L"alnum"</tt></td>
<td><tt>ctype_base::alnum</tt></td>
</tr>

<tr>
<td><tt>"alpha"</tt></td>
<td><tt>L"alpha"</tt></td>
<td><tt>ctype_base::alpha</tt></td>
</tr>

<tr>
<td><tt>"blank"</tt></td>
<td><tt>L"blank"</tt></td>
<td><tt>ctype_base::blank</tt></td>
</tr>

<tr>
<td><tt>"cntrl"</tt></td>
<td><tt>L"cntrl"</tt></td>
<td><tt>ctype_base::cntrl</tt></td>
</tr>

<tr>
<td><tt>"digit"</tt></td>
<td><tt>L"digit"</tt></td>
<td><tt>ctype_base::digit</tt></td>
</tr>

<tr>
<td><tt>"d"</tt></td>
<td><tt>L"d"</tt></td>
<td><tt>ctype_base::digit</tt></td>
</tr>

<tr>
<td><tt>"graph"</tt></td>
<td><tt>L"graph"</tt></td>
<td><tt>ctype_base::graph</tt></td>
</tr>

<tr>
<td><tt>"lower"</tt></td>
<td><tt>L"lower"</tt></td>
<td><tt>ctype_base::lower</tt></td>
</tr>

<tr>
<td><tt>"print"</tt></td>
<td><tt>L"print"</tt></td>
<td><tt>ctype_base::print</tt></td>
</tr>

<tr>
<td><tt>"punct"</tt></td>
<td><tt>L"punct"</tt></td>
<td><tt>ctype_base::punct</tt></td>
</tr>

<tr>
<td><tt>"space"</tt></td>
<td><tt>L"space"</tt></td>
<td><tt>ctype_base::space</tt></td>
</tr>

<tr>
<td><tt>"s"</tt></td>
<td><tt>L"s"</tt></td>
<td><tt>ctype_base::space</tt></td>
</tr>

<tr>
<td><tt>"upper"</tt></td>
<td><tt>L"upper"</tt></td>
<td><tt>ctype_base::upper</tt></td>
</tr>

<tr>
<td><tt>"w"</tt></td>
<td><tt>L"w"</tt></td>
<td><tt>ctype_base::alnum</tt></td>
</tr>

<tr>
<td><tt>"xdigit"</tt></td>
<td><tt>L"xdigit"</tt></td>
<td><tt>ctype_base::xdigit</tt></td>
</tr>

</table>
</blockquote> 
</li>
</ol>





<hr>
<h3><a name="2035"></a>2035. Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-11-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="lwg-active.html#2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.2.1 [iterator.requirements.general] and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="lwg-defects.html#2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus this is the correct direction, but there are (potentially) missing <i>incrementable</i>
preconditions on some table rows, and the Remarks on when an output iterator becomes dereferencable
are probably better handled outside the table, in a manner similar to the way we word for input
iterators.
</p>

<p>
There was some concern about redundant pre-conditions when the operational semantic is defined in
terms of operations that have preconditions, and a similar level of concern over dropping such
redundancies vs. applying a consistent level of redundant specification in all the iterator tables.
Wording clean-up in either direction would be welcome.
</p>

<p><i>[2011-08-18: Daniel adapts the proposed resolution to honor the Bloomington request]</i></p>


<p>
There is only a small number of further changes suggested to get rid of superfluous 
requirements and essentially non-normative assertions. Operations should not have extra 
pre-conditions, if defined by "in-terms-of" semantics, see e.g. <tt>a != b</tt> or <tt>a-&gt;m</tt> 
for Table 107. Further, some remarks, that do not impose anything or say nothing new have been removed, 
because I could not find anything helpful they provide.
E.g. consider the remarks for Table 108 for the operations dereference-assignment and
preincrement: They don't provide additional information say nothing surprising. With the
new pre-conditions <em>and</em> post-conditions it is implied what the remarks intend to say.
</p>

<p><i>[
2011-11-03: Some observations from Alexander Stepanov via c++std-lib-31405
]</i></p>


<p>
The following sentence is dropped from the standard section on OutputIterators:
<p/>
"In particular, the following two conditions should hold: first, any
iterator value should be assigned through before it is incremented
(this is, for an output iterator <tt>i, i++; i++;</tt> is not a valid code
sequence); second, any value of an output iterator may have at most
one active copy at any given time (for example, <tt>i = j; *++i = a; *j = b;</tt> 
is not a valid code sequence)."
</p>

<p><i>[
2011-11-04: Daniel comments and improves the wording
]</i></p>


<p>
In regard to the first part of the comment, the intention of the newly proposed wording 
was to make clear that for the expression
</p>
<blockquote><pre>
*r = o
</pre></blockquote>
<p>
we have the precondition dereferenceable and the post-condition
incrementable. And for the expression
</p>
<blockquote><pre>
++r
</pre></blockquote>
<p>
we have the precondition incrementable and the post-condition dereferenceable 
or past-the-end. This <em>should not</em>  allow for a sequence like <tt>i++; i++;</tt> 
but I agree that it doesn't exactly say that.
<p/>
In regard to the second point: To make this point clearer, I suggest to
add a similar additional wording as we already have for input iterator to the 
"Assertion&#47;note" column of the expression <tt>++r</tt>:
<p/>
"Post: any copies of the previous value of <tt>r</tt> are no longer 
required to be dereferenceable or incrementable."
<p/>
The proposed has been updated to honor the observations of Alexander Stepanov.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.2.1 [iterator.requirements.general] to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.5 [unord.req] on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>17.6.3.2 [swappable.requirements] p5:</p>

<blockquote><p>
-5- A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>17.6.3.5 [allocator.requirements], Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>20.6.3.2 [pointer.traits.functions]:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>21.4.3 [string.iterators] p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote>
</li>

<li><p>22.4.5.1.2 [locale.time.get.virtuals] p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.1 [container.requirements.general] p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(24.2.1 [iterator.requirements.general])</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.3 [sequence.reqmts] p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 [associative.reqmts] p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.5 [unord.req] p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.2.1 [iterator.requirements.general] p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
-5- Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.2.2 [iterator.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.2.3 [input.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*a</tt> and <tt>++r</tt>, and 
to specify the semantics of the remaining ones. This approach seems to be in agreement with the 
original <a href="http://www.sgi.com/tech/stl/InputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td><del>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.</del>
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td><del>pre: <tt>a</tt> is dereferenceable.</del></td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.2.4 [output.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*r = o</tt> and <tt>++r</tt>,
and to specify the semantics of the remaining ones. This approach seems to be in agreement with
the original <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/></del>
<ins><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
incrementable and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is <ins>dereferenceable<br/>
or <tt>r</tt> is past-the-end</ins><del>incrementable</del>.<br/>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.2.5 [forward.iterators], as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.2.6 [bidirectional.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2038"></a>2038. Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-11-21</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 17.6.3.2 [swappable.requirements] there is a mention of "dereferenceable object"; in 
17.6.3.5 [allocator.requirements] the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.6.3.2 [pointer.traits.functions] refers to a 
"dereferenceable pointer"; in 22.4.5.1.2 [locale.time.get.virtuals]&#47;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="lwg-active.html#2035">2035</a> solves this
issue as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Agree with Daniel, this will be handled by the resolution of <a href="lwg-active.html#2035">2035</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2048"></a>2048. Unnecessary <tt>mem_fn</tt> overloads</h3>
<p><b>Section:</b> 20.8 [function.objects], 20.8.10 [func.memfn] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>mem_fn</tt> overloads for member functions are redundant and misleading
and should be removed from the post-C++11 WP.
<p/>
I believe the history of the overloads is as follows:
<p/>
In TR1 and in C++0x prior to the N2798 draft, <tt>mem_fn</tt> was specified by
a single signature:
</p>
<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);
</pre></blockquote>
<p>
and was accompanied by the remark "Implementations may implement <tt>mem_fn</tt> 
as a set of overloaded function templates." This remark predates variadic templates 
and was presumably to allow implementations to provide overloads for a limited 
number of function parameters, to meet the implementation-defined limit on numbers of
template parameters.
<p/>
N2770 "Concepts for the C++0x Standard Library: Utilities" added
separate overloads for pointers to member functions, apparently so
that function parameters would require the <tt>CopyConstructible</tt> concept
(those overloads first appeared in N2322.) The overloads failed to
account for varargs member functions (i.e. those declared with an
ellipsis in the parameter-declaration-clause) e.g.
</p>
<blockquote><pre>
struct S {
 int f(int, ...);
};
</pre></blockquote>
<p>
Syntactically such a function would be handled by the original
<tt>mem_fn(R T::* pm)</tt> signature, the only minor drawback being that there
would be no <tt>CopyConstructible</tt> requirement on the parameter list. (Core
DR 547 clarifies that partial specializations can be written to match
cv-qualified and ref-qualified functions to support the case where <tt>R T::*</tt> 
matches a pointer to member function type.)
<p/>
LWG issue <a href="lwg-defects.html#920">920</a> pointed out that additional overloads were missing for
member functions with ref-qualifiers. These were not strictly
necessary, because such functions are covered by the <tt>mem_fn(R T::* pm)</tt> signature.
<p/>
Concepts were removed from the draft and N3000 restored the original
single signature and accompanying remark.
<p/>
LWG <a href="lwg-closed.html#1230">1230</a> was opened to strike the remark again and to add an overload
for member functions (this overload was unnecessary for syntactic reasons and 
insufficient as it didn't handle member functions with cv-qualifiers and&#47;or 
ref-qualifiers.)
<p/>
<a href="lwg-defects.html#920">920</a> (and <a href="lwg-closed.html#1230">1230</a>) were resolved by restoring a full set of
(non-concept-enabled) overloads for member functions with cv-qualifiers and ref-qualifiers,
but as in the concept-enabled draft there were no overloads for member functions with 
an ellipsis in the parameter-declaration-clause. This is what is present in the FDIS.
<p/>
Following the thread beginning with message c++std-lib-30675, it is my
understanding that all the <tt>mem_fn</tt> overloads for member functions are
unnecessary and were only ever added to allow concept requirements.
I'm not aware of any reason implementations cannot implement <tt>mem_fn</tt> as
a single function template. Without concepts the overloads are
redundant, and the absence of overloads for varargs functions can be
interpreted to imply that varargs functions are not intended to work
with <tt>mem_fn</tt>. Clarifying the intent by adding overloads for varargs
functions would expand the list of 12 redundant overloads to 24, it
would be much simpler to remove the 12 redundant overloads entirely.
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Move to Review.
</p>

<p>
The issue and resolution appear to be correct, but there is some concern that the wording of INVOKE may be different depending on whether you pass a pointer-to-member-data or pointer-to-member-function.  That might make the current wording necessary after all, and then we might need to add the missing elipsis overloads.
</p>

<p>
There was some concern that the Remark confirming implementors had freedom to implement this as a set of overloaded functions may need to be restored if we delete the specification for these overloads.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the <tt>&lt;functional&gt;</tt> synopsis 20.8 [function.objects] p. 2 as follows:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  // <i>[func.memfn], member function adaptors:</i>
  template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...));
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 20.8.10 [func.memfn] as follows:</p>

<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...));
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2049"></a>2049. <tt>is_destructible</tt> is underspecified</h3>
<p><b>Section:</b> 20.9.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2011-11-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>The conditions for the type trait <tt>is_destructible</tt> to be true
are described in Table 49 &mdash; Type property predicates:</p>
<blockquote><p>
For a complete type <tt>T</tt> and given<br/>
<tt>template &lt;class U&gt;
struct test { U u; };</tt>,<br/>
<tt>test&lt;T&gt;::~test()</tt> is not deleted.
</p></blockquote>

<p>This specification does not say what the result would be for function
types or for abstract types:</p>
<ol>
<li>For an abstract type <tt>X</tt> the instantiation <tt>test&lt;X&gt;</tt>
is already ill-formed, so we cannot say anything about whether the destructor
would be deleted or not.</li>
<li>In regard to function types, there exists a special rule in the core language, 14.3.1 [temp.arg.type] p. 3,
which excludes member functions to be declared via the type of the template parameter:
<blockquote><p>
If a declaration acquires a function type through a type dependent on a <i>template-parameter</i>
and this causes a declaration that does not use the syntactic form of a function declarator 
to have function type, the program is ill-formed. 
<p/>
[ <i>Example</i>:</p>
<blockquote><pre>
template&lt;class T&gt; struct A {
  static T t;
};
typedef int function();
A&lt;function&gt; a; // ill-formed: would declare A&lt;function&gt;::t
               // as a static member function
</pre></blockquote>
<p>
&mdash; <i>end example</i> ]
</p></blockquote>
which has the same consequence as for abstract types, namely that the corresponding
instantiation of <tt>test</tt> is already ill-formed and we cannot say anything
about the destructor.
</li>
</ol>
<p>To solve this problem, I suggest to specify function types as trivially and nothrowing
destructible, because above mentioned rule is very special for templates. For non-templates,
a typedef can be used to introduce a member as member function as clarified in 8.3.5 [dcl.fct]
p. 10.</p>
<p>For abstract types, two different suggestions have been brought to my attention:
Either declare them as unconditionally non-destructible or check whether the expression
</p>
<blockquote><pre>
std::declval&lt;T&amp;&gt;().~T()
</pre></blockquote>
<p>is well-formed in an unevaluated context. The first solution is very easy to specify,
but the second version has the advantage for providing more information to user-code. This 
information could be quite useful, if generic code is supposed to invoke the destructor
of a reference to a base class indirectly via a delete expression, as suggested by
Howard Hinnant:</p>
<blockquote><pre>
template &lt;class T&gt;
my_pointer&lt;T&gt;::~my_pointer() noexcept(is_nothrow_destructible&lt;T&gt;::value)
{
   delete ptr_;
}
</pre></blockquote>
<p>Additional to the <tt>is_destructible</tt> traits, its derived forms <tt>is_trivially_destructible</tt>
and <tt>is_nothrow_destructible</tt> are similarly affected, because their wording refers to "the indicated
destructor" and probably need to be adapted as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
After discussion about to to handle the exceptional cases of reference types, function types (available by defererencing a function pointer)
and <tt>void</tt> types, Howard supplied proposed wording.
</p>

<p><i>[
2011-08-20 Daniel comments and provides alternatives wording
]</i></p>


<p>
The currently proposed wording would have the consequence that 
<em>every</em> array type is not destructible, because the pseudo-destructor
requires a scalar type with the effect that the expression
</p><blockquote><pre>
std::declval&lt;T&amp;&gt;().~T()
</pre></blockquote><p>
is not well-formed for e.g. <tt>T</tt> equal to <tt>int[3]</tt>. The intuitive
solution to fix this problem would be to adapt the object type case to refer to 
the expression
</p><blockquote><pre>
std::declval&lt;U&amp;&gt;().~U()
</pre></blockquote><p>
with <tt>U</tt> equal to <tt>remove_all_extents&lt;T&gt;::type</tt>, but that
would have the effect that arrays of unknown bounds would be destructible, if 
the element type is destructible, which was not the case before (This was 
intentionally covered by the special "For a complete type T" rule in
the FDIS).
<p/>
Suggestion: Use the following definition instead:
</p>
<blockquote><p>
Let <tt>U</tt> be <tt>remove_all_extents&lt;T&gt;::type</tt>.<br/>
For incomplete types and function types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>false</tt>.<br/>
For object types, if the expression <tt>std::declval&lt;U&amp;&gt;().~U()</tt> is well-formed<br/>
when treated as an unevaluated operand (Clause 5), then <tt>is_destructible&lt;T&gt;::value</tt><br/>
is <tt>true</tt>, otherwise it is <tt>false</tt>.<br/>
For reference types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>.
</p></blockquote>
<p>
This wording also harmonizes with the "unevaluated operand" phrase
used in other places, there does not exist the definition of an
"unevaluated context"
<p/>
<em>Note:</em> In the actually proposed wording this wording has been slightly reordered with the same effects. 
</p>

<p><strong>Howard's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>
Update 20.9.4.3 [meta.unary.prop], table 49:
</p>

<table border="1">
<tr>
<td><tt>template &lt;class T&gt;
struct is_destructible;</tt></td>
<td>
<del>For a complete type <tt>T</tt> and given <tt>template &lt;class U&gt; struct test { U u; };</tt>, <tt>test&lt;T&gt;::~test()</tt> is not deleted.
</del>
<br/>
<ins>
For object types, if the expression: <tt>std::declval&lt;T&amp;>().~T()</tt> is well-formed in an unevaluated context then
<tt>is_destructible&lt;T>::value</tt> is <tt>true</tt>, otherwise it is <tt>false</tt>.
<br/>
For <tt>void</tt> types, <tt>is_destructible&lt;T>::value</tt> is <tt>false</tt>.
<br/>
For reference types, <tt>is_destructible&lt;T>::value</tt> is <tt>true</tt>.
<br/>
For function types, <tt>is_destructible&lt;T>::value</tt> is <tt>false</tt>.
</ins>
</td>
<td><tt>T</tt> shall be a complete type, (possibly cv-qualified) <tt>void</tt>, or an array of unknown bound.</td>
</tr>
</table>
</blockquote>
<p>
</p>


<p><b>Proposed resolution:</b></p>

<p>
Update 20.9.4.3 [meta.unary.prop], table 49:
</p>

<table border="1">
<tr>
<td><tt>template &lt;class T&gt;
struct is_destructible;</tt></td>
<td>
<del>For a complete type <tt>T</tt> and given <tt>template &lt;class U&gt; struct test { U u; };</tt>, <tt>test&lt;T&gt;::~test()</tt> is not deleted.
</del>
<br/>
<ins>
For reference types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>.<br/>
For incomplete types and function types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>false</tt>.<br/>
For object types and given <tt>U</tt> equal to <tt>remove_all_extents&lt;T&gt;::type</tt>,<br/> 
if the expression <tt>std::declval&lt;U&amp;&gt;().~U()</tt> is well-formed when treated as an<br/>
unevaluated operand (Clause 5 [expr]), then <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>,<br/>
otherwise it is <tt>false</tt>.<br/>
</ins>
</td>
<td><tt>T</tt> shall be a complete type, (possibly cv-qualified) <tt>void</tt>, or an array of unknown bound.</td>
</tr>
</table>






<hr>
<h3><a name="2052"></a>2052. Mixup between <tt>mapped_type</tt> and <tt>value_type</tt> for associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2011-05-04 <b>Last modified:</b> 2011-11-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(this is basically reopening the first part of issue <a href="lwg-closed.html#2006">2006</a>, as discussed in the thread 
starting at c++std-lib-30698 )
<p/>
Section 23.2.4 [associative.reqmts]
<p/>
In Table 102, several uses of <tt>T</tt> (which means <tt>mapped_type</tt> here) should
be <tt>value_type</tt> instead. This is almost editorial. For instance:
</p>
<blockquote><pre>
a_uniq.emplace(args)
</pre><p>
<i>Requires</i>: <tt>T</tt> shall be <tt>EmplaceConstructible</tt> into <tt>X</tt> from args.
<p/>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in the
container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of
the returned pair is true if and only if the insertion takes place, and the iterator component 
of the pair points to the element with key equivalent to the key of <tt>t</tt>.
</p></blockquote>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Not even an exhaustive list of problem locations. No reason to doubt issue.
</p>
<p>
Pablo agrees to provide wording.
</p>

<p><i>[
2011-09-04 Pablo Halpern provides improved wording
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In both section 23.2.4 [associative.reqmts] Table 102 and 23.2.5 [unord.req], Table 103, make the following text replacements:
</p>

<table border="1">
<tr> <td>Original text, in FDIS</td> <td>Replacement text</td> </tr>

<tr> 
<td><tt>T</tt> is CopyInsertable into <tt>X</tt> and <tt>CopyAssignable</tt>.</td>
<td><tt>value_type</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>, <tt>key_type</tt> is <tt>CopyAssignable</tt>, and
<tt>mapped_type</tt> is <tt>CopyAssignable</tt> (for containers having a <tt>mapped_type</tt>)</td>    
</tr>

<tr> 
<td><tt>T</tt> is <tt>CopyInsertable</tt></td>                                                
<td><tt>value_type</tt> is CopyInsertable</td> 
</tr>

<tr> 
<td><tt>T</tt> shall be <tt>CopyInsertable</tt></td>                                          
<td><tt>value_type</tt> shall be CopyInsertable</td> 
</tr>

<tr> 
<td><tt>T</tt> shall be <tt>MoveInsertable</tt></td>                                          
<td><tt>value_type</tt> shall be MoveInsertable</td> 
</tr>

<tr> 
<td><tt>T</tt> shall be <tt>EmplaceConstructible</tt></td>                                    
<td><tt>value_type</tt> shall be EmplaceConstructible</td> 
</tr>

<tr> 
<td><tt>T</tt> object</td>                                                                    
<td><tt>value_type</tt> object</td> 
</tr>
</table>

<p><i>[
<b>Notes to the editor</b>: The above are carefully selected 
phrases that can be used for global search-and-replace within 
the specified sections without accidentally making changes to 
correct uses <tt>T</tt>.
]</i></p>






<hr>
<h3><a name="2054"></a>2054. <tt>time_point</tt> constructors need to be <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.11.6 [time.point] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2011-05-13 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.11.6 [time.point], <tt>time_point::min()</tt> and <tt>time_point::max()</tt> 
are listed as <tt>constexpr</tt>. However, <tt>time_point</tt> has no <tt>constexpr</tt> constructors, 
so is not a literal type, and so these functions cannot be <tt>constexpr</tt> without adding a 
<tt>constexpr</tt> constructor for implementation purposes.
<p/>
Proposed resolution: Add <tt>constexpr</tt> to the constructors of <tt>time_point</tt>. The effects of
the constructor template basically imply that the member function <tt>time_since_epoch()</tt> is
intended to be <tt>constexpr</tt> as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Alter the class template definition in 20.11.6 [time.point] as follows:</p>
<blockquote><pre>
template &lt;class Clock, class Duration = typename Clock::duration&gt;
class time_point {
  [&hellip;]
public:
  <i>// 20.11.6.1, construct:</i>
  <ins>constexpr</ins> time_point(); <i>// has value epoch</i>
  <ins>constexpr</ins> explicit time_point(const duration&amp; d); <i>// same as time_point() + d</i>
  template &lt;class Duration2&gt;
    <ins>constexpr</ins> time_point(const time_point&lt;clock, Duration2&gt;&amp; t);

  <i>// 20.11.6.2, observer:</i>
  <ins>constexpr</ins> duration time_since_epoch() const;
  [&hellip;]
};
</pre></blockquote>
</li>

<li><p>Alter the declarations in 20.11.6.1 [time.point.cons]:</p>
<blockquote><pre>
<ins>constexpr</ins> time_point();
</pre><blockquote><p>
-1- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>duration::zero()</tt>. Such a
<tt>time_point</tt> object represents the epoch.
</p></blockquote></blockquote>
<blockquote><pre>
<ins>constexpr explicit</ins> time_point(const duration&amp; d);
</pre><blockquote><p>
-2- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>d</tt>. Such a 
<tt>time_point</tt> object represents the epoch <tt>+ d</tt>.
</p></blockquote></blockquote>
<blockquote><pre>
template &lt;class Duration2&gt;
  <ins>constexpr</ins> time_point(const time_point&lt;clock, Duration2&gt;&amp; t);
</pre><blockquote><p>
-3- <i>Remarks</i>: This constructor shall not participate in overload resolution unless <tt>Duration2</tt> is implicitly
convertible to <tt>duration</tt>.
<p/>
-4- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>t.time_since_epoch()</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Alter the declaration in 20.11.6.2 [time.point.observer]:</p>
<blockquote><pre>
<ins>constexpr</ins> duration time_since_epoch() const;
</pre><blockquote><p>
-1- <i>Returns</i>: d_.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2056"></a>2056. <tt>future_errc</tt> enums start with value 0 (invalid value for <tt>broken_promise</tt>)</h3>
<p><b>Section:</b> 30.6.1 [futures.overview] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2011-11-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.overview">active issues</a> in [futures.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.overview">issues</a> in [futures.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.6.1 [futures.overview] <tt>enum class future_errc</tt> is defined as follows:
</p><blockquote><pre>
enum class future_errc {
  broken_promise,
  future_already_retrieved,
  promise_already_satisfied,
  no_state
};
</pre></blockquote><p>
With this declaration <tt>broken_promise</tt> has value 0, which means that
for a <tt>future_error f</tt> with this code
</p><blockquote><pre>
f.code().operator bool()
</pre></blockquote><p>
yields false, which makes no sense. 0 has to be reserved for "no error".
So, the enums defined here have to start with 1.
<p/>
Howard, Anthony, and Jonathan have no objections.
</p>
<p>[Discussion in Bloomington 2011-08-16]
</p>
<p>
Previous resolution:
</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, fix 
the declaration of <tt>future_errc</tt> as follows:</p>
<blockquote><pre>
namespace std {
  enum class future_errc {
    <del>broken_promise,</del>
    future_already_retrieved<ins> = 1</ins>,
    promise_already_satisfied,
    no_state<ins>,
    broken_promise</ins>
  };
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>
</blockquote>
<p>
Is this resolution overspecified? These seem to be all implementation-defined. How do users add new values and not conflict with established error codes?
</p><p>
PJP proxy says: over-specified. boo.
</p><p>
Other error codes: look for <tt>is_error_code_enum</tt> specializations. Only one exists <tt>io_errc</tt>
</p><p>
Peter: I don't see any other parts of the standard that specify error codes where we have to do something similar.
</p><p>
Suggest that for every place where we add an error code, the following:
</p>
<ol>
   <li> no zero values
   </li><li> all implementation defined values, so future_already_retrieved = implementation_defined
   </li><li> values are distinct
</li></ol>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, fix 
the declaration of <tt>future_errc</tt> as follows:</p>

<blockquote><pre>
namespace std {
  enum class future_errc {
    broken_promise<ins> = <var>implementation defined</var></ins>,
    future_already_retrieved<ins> = <var>implementation defined</var></ins>,
    promise_already_satisfied<ins> = <var>implementation defined</var></ins>,
    no_state<ins> = <var>implementation defined</var></ins>
  };
  [&hellip;]
}
</pre></blockquote>
<p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, add a paragraph after paragraph 2 as follows:</p>

<ins>The enum values of <tt>future_errc</tt> are distinct and not zero.</ins>




<hr>
<h3><a name="2057"></a>2057. <tt>time_point + duration</tt> semantics should be made <tt>constexpr</tt> conforming</h3>
<p><b>Section:</b> 20.11.6.5 [time.point.nonmember] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-05-21 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been observed by LWG <a href="lwg-active.html#2054">2054</a> that the specification of some <tt>time_point</tt> member functions
already imply that <tt>time_point</tt> needs to be a literal type and suggests to specify the constructors
and the member function <tt>time_since_epoch()</tt> as <tt>constexpr</tt> functions at the
minimum necessary. Adding further <tt>constexpr</tt> specifier to other operations should
clearly be allowed and should probably be done as well. But to allow for further <tt>constexpr</tt> 
functions in the future requires that their semantics is compatible to operations allowed in <tt>constexpr</tt> 
functions. This is already fine for all operations, except this binary plus operator:
</p>
<blockquote><pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
time_point&lt;Clock, typename common_type&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;::type&gt;
operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
-1- <i>Returns</i>: <tt>CT(lhs) += rhs</tt>, where <tt>CT</tt> is the type of the return value.
</p></blockquote></blockquote>
<p>
for similar reasons as those mentioned in <a href="lwg-defects.html#2020">2020</a>. The semantics should be fixed to allow
for making them <tt>constexpr</tt>. This issue should also be considered as a placeholder for a request
to make the remaining <tt>time_point</tt> operations similarly <tt>constexpr</tt> as had been done for 
<tt>duration</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>In 20.11.6.5 [time.point.nonmember], p.1 change the <i>Returns</i> element semantics as indicated:</p>
<blockquote><pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
time_point&lt;Clock, typename common_type&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;::type&gt;
operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
-1- <i>Returns</i>: <tt><del>CT(lhs) += rhs</del><ins>CT(lhs.time_since_epoch() + rhs)</ins></tt>, where <tt>CT</tt> 
is the type of the return value.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2058"></a>2058. <tt>valarray</tt> and <tt>begin&#47;end</tt></h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2011-05-17 <b>Last modified:</b> 2011-11-22</p>
<p><b>View all other</b> <a href="lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was just brought to my attention that the pair of functions
<tt>begin&#47;end</tt> were added to <tt>valarray</tt> component.
Those additions strike me as counter to the long standing agreement
that <tt>valarray&lt;T&gt;</tt> is not yet another container. Valarray values
are in general supposed to be treated as a whole, and as such
has a loose specification allowing expression template techniques.
<p/>
The addition of these functions sound to me as making it much harder
(or close to impossible) to effectively use expression templates
as implementation techniques, for no clear benefits.
<p/>
My recommendation would be to drop <tt>begin&#47;end</tt> - or at least for the
<tt>const valarray&lt;T&gt;&amp;</tt> version. I strongly believe those 
are defects.
</p>
<p><i>[This issue was discussed on the library reflector starting from c++std-lib-30761.
Some of the key conclusions of this discussion were:]</i></p>

<ol>
<li>The <tt>begin&#47;end</tt> members were added to allow <tt>valarray</tt> to participate
in the new range-based for-loop by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">n2930</a>
and not to make them container-like.</li>
<li>It is currently underspecified when the iterator values returned from
<tt>begin&#47;end</tt> become invalidated. To fix this, these invalidation rules need at
least to reflect the invalidation rules of the references returned by the
<tt>operator[]</tt> overloads of <tt>valarray</tt> (26.6.2.4 [valarray.access]).
</li>
<li>A further problem is that the requirements expressed in 26.6.1 [valarray.syn] p.3-5
enforce an implementation to provide further overloads of <tt>begin&#47;end</tt>, if the
replacement type technique is used (which was clearly part of the design of <tt>valarray</tt>).
Providing such additional overloads would also lead to life-time problems in examples like 
<tt>begin(x + y)</tt> where <tt>x</tt> and <tt>y</tt> are expressions involving <tt>valarray</tt> 
objects. To fix this, the <tt>begin&#47;end</tt> overloads could be explicitly excluded from the 
general statements of 26.6.1 [valarray.syn] p.3-5. This would make it unspecified
whether the expression <tt>begin(x + y)</tt> would be well-formed, portable code would
need to write this as <tt>begin(std::valarray&lt;T&gt;(x + y))</tt>.</li>
</ol>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The intent of these overloads is entirely to support the new for syntax, and not to create
new containers.
</p>

<p>
Stefanus provides suggested wording.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 26.6.1 [valarray.syn]&#47;4, make the following <ins>insertion</ins>:
</p>

<p>
4 Implementations introducing such replacement types shall provide additional functions and operators as
follows:
</p>
<ul>
<li>for every function taking a <tt>const valarray&lt;T&gt;&amp;</tt> <ins>other than <tt>begin</tt> and <tt>end</tt>
(26.6.10 [valarray.range])</ins>, identical functions taking the replacement types shall be added;
</li>
<li>
for every function taking two <tt>const valarray&lt;T&gt;&amp;</tt> arguments, identical functions taking every combination
of <tt>const valarray&lt;T&gt;&amp;</tt> and replacement types shall be added.
</li>
</ul>

<p>
In 26.6.10 [valarray.range], make the following <ins>insertion</ins>:
</p>
<p> 
1 In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified</i>1 is a type that meets
the requirements of a mutable random access iterator (24.2.7) whose <tt>value_type</tt> is the template parameter
<tt>T</tt> and whose <tt>reference</tt> type is <tt>T&amp;</tt>. <i>unspecified</i>2 is a type that meets the
requirements of a constant random access iterator (24.2.7) whose <tt>value_type</tt> is the template parameter
<tt>T</tt> and whose <tt>reference</tt> type is <tt>const T&amp;</tt>.
</p>
<p><ins>
2 The iterators  returned by <tt>begin</tt> and <tt>end</tt> for an array are guaranteed to be valid until the
member function <tt>resize(size_t, T)</tt> (26.6.2.8 [valarray.members]) is called for that array or until
the lifetime of that array ends, whichever happens first.
</ins></p>





<hr>
<h3><a name="2059"></a>2059. C++0x ambiguity problem with <tt>map::erase</tt></h3>
<p><b>Section:</b> 23.4.4 [map] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>map::erase</tt> (and several related methods) took an iterator in C++03, but take a <tt>const_iterator</tt> 
in C++0x. This breaks code where the map's <tt>key_type</tt> has a constructor which accepts an iterator 
(for example a template constructor), as the compiler cannot choose between <tt>erase(const key_type&amp;)</tt> 
and <tt>erase(const_iterator)</tt>.</p>
<blockquote><pre>
#include &lt;map&gt;

struct X
{
  template&lt;typename T&gt;
  X(T&amp;) {}
};

bool operator&lt;(const X&amp;, const X&amp;) { return false; }

void erasor(std::map&lt;X,int&gt;&amp; s, X x)
{
  std::map&lt;X,int&gt;::iterator it = s.find(x);
  if (it != s.end())
    s.erase(it);
}
</pre></blockquote>

<p><i>[
2011 Bloomington
]</i></p>


<p>
This issue affects only associative container <tt>erase</tt> calls, and is not more general, as these are the
only functions that are also overloaded on another single arguement that might cause confusion - the <tt>erase</tt>
by key method.  The complete resolution should simply restore the <tt>iterator</tt> overload in addition to the
<tt>const_iterator</tt> overload for all eight associative containers. 
</p>

<p>
Proposed wording supplied by Alan Talbot, and moved to Review.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Editorial note: The following things are different between 23.2.4 [associative.reqmts] p.8 and
23.2.5 [unord.req] p.10. These should probably be reconciled.
</p>
<blockquote>
<ol>
<li>First uses the convention "denotes";  second uses the convention "is".</li>
<li>First redundantly says: "If no such element exists, returns a.end()." in erase table entry, second does not.</li>
</ol>
</blockquote>

<p>
23.2.4 [associative.reqmts] Associative containers
</p>
<p>
8 In Table 102, <tt>X</tt> denotes an associative container class, <tt>a</tt> denotes a value of <tt>X</tt>, <tt>a_uniq</tt>
denotes a value of <tt>X</tt> when <tt>X</tt> supports unique keys, <tt>a_eq</tt> denotes a value of <tt>X</tt> when
<tt>X</tt> supports multiple keys, <tt>u</tt> denotes an identifier, <tt>i</tt> and <tt>j</tt> satisfy input iterator
requirements and refer to elements implicitly convertible to <tt>value_type</tt>, <tt>[i,j)</tt> denotes a valid range,
<tt>p</tt> denotes a valid const iterator to <tt>a</tt>, <tt>q</tt> denotes a valid dereferenceable const iterator to <tt>a</tt>,
<ins><tt>r</tt> denotes a valid dereferenceable iterator to a,</ins> <tt>[q1, q2)</tt> denotes a valid range of const iterators
in <tt>a</tt>, <tt>il</tt> designates an object of type <tt>initializer_list&lt;value_type></tt>, <tt>t</tt> denotes a value of
<tt>X::value_type</tt>, <tt>k</tt> denotes a value of <tt>X::key_type</tt> and <tt>c</tt> denotes a value of type
<tt>X::key_compare</tt>. <tt>A</tt> denotes the storage allocator used by <tt>X</tt>, if any, or
<tt>std::allocator&lt;X::value_type></tt> otherwise, and <tt>m</tt> denotes an allocator of a type convertible to <tt>A</tt>.
</p>

<p>
23.2.4 [associative.reqmts] Associative containers Table 102
</p>
<p>
Add row:
</p>
<ins>
<table border="1">
<tr>
<td><tt>a.erase(r)</tt></td>
<td><tt>iterator</tt></td>
<td>
erases the element pointed to by <tt>r</tt>. Returns an iterator pointing to the element immediately following <tt>r</tt>
prior to the element being erased. If no such element exists, returns <tt>a.end()</tt>.
</td>
<td>amortized constant</td>
</tr>
</table>
</ins>

<p>
23.2.5 [unord.req] Unordered associative containers</p>
<p>
10 In table 103: <tt>X</tt> is an unordered associative container class, <tt>a</tt> is an object of type <tt>X</tt>,
<tt>b</tt> is a possibly const object of type <tt>X</tt>, <tt>a_uniq</tt> is an object of type <tt>X</tt> when
<tt>X</tt> supports unique keys, <tt>a_eq</tt> is an object of type <tt>X</tt> when <tt>X</tt> supports equivalent keys,
<tt>i</tt> and <tt>j</tt> are input iterators that refer to <tt>value_type</tt>, <tt>[i, j)</tt> is a valid range,
<tt>p</tt> and <tt>q2</tt> are valid const iterators to <tt>a</tt>, <tt>q</tt> and <tt>q1</tt> are valid dereferenceable
const iterators to <tt>a</tt>, <ins><tt>r</tt> is a valid dereferenceable iterator to a,</ins> <tt>[q1,q2)</tt> is a
valid range in <tt>a</tt>, <tt>il</tt> designates an object of type <tt>initializer_list&lt;value_type></tt>,
<tt>t</tt> is a value of type <tt>X::value_type</tt>, <tt>k</tt> is a value of type <tt>key_type</tt>, <tt>hf</tt> is a
possibly const value of type <tt>hasher</tt>, <tt>eq</tt> is a possibly const value of type <tt>key_equal</tt>,
<tt>n</tt> is a value of type <tt>size_type</tt>, and <tt>z</tt> is a value of type <tt>float</tt>.
</p>

<p>
23.2.5 [unord.req] Unordered associative containers Table 103
</p>
<p>
Add row:
</p>
<ins>
<table border="1">
<tr>
<td><tt>a.erase(r)</tt></td>
<td><tt>iterator</tt></td>
<td>
Erases the element pointed to by <tt>r</tt>. Returns the iterator immediately following <tt>r</tt> prior to the erasure.
</td>
<td>Average case O(1), worst case O(<tt>a.size()</tt>).</td>
</tr>
</table>
</ins>

<p>
23.4.4.1 [map.overview] Class template map overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.5.1 [multimap.overview] Class template multimap overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.6.1 [set.overview] Class template set overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.7.1 [multiset.overview] Class template multiset overview 
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.4.1 [unord.map.overview] Class template unordered_map overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.5.1 [unord.multimap.overview] Class template unordered_multimap overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.6.1 [unord.set.overview] Class template unordered_set overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>


<p>
23.5.7.1 [unord.multiset.overview] Class template unordered_multiset overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
 [diff.cpp03.containers] C.2.12 Clause 23: containers library 
</p>
<p>
23.2.3, 23.2.4
</p>
<p>
Change: Signature changes: from iterator to const_iterator parameters
</p>
<p>
Rationale: Overspecification. Effects: The signatures of the following member functions changed from
taking an iterator to taking a const_iterator:
</p>
<ul>
<li>insert(iter, val) for vector, deque, list, set, multiset, map, multimap</li>
<li>insert(pos, beg, end) for vector, deque, list, forward_list</li>
<li><del>erase(iter) for set, multiset, map, multimap</del></li>
<li>erase(begin, end) for set, multiset, map, multimap</li>
<li>all forms of list::splice</li>
<li>all forms of list::merge</li>
</ul>
<p>
Valid C++ 2003 code that uses these functions may fail to compile with this International Standard.
</p>





<hr>
<h3><a name="2062"></a>2062. Effect contradictions w&#47;o no-throw guarantee of <tt>std::function</tt> swaps</h3>
<p><b>Section:</b> 20.8.11.2 [func.wrap.func], 20.8.11.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-05-28 <b>Last modified:</b> 2011-11-21</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Howard Hinnant observed in reflector message c++std-lib-30841 that 20.8.11.2 [func.wrap.func] 
makes the member swap <tt>noexcept</tt>, even though the non-member swap is not <tt>noexcept</tt>. 
<p/>
The latter was an outcome of the discussions during the Batavia meeting and the Madrid meeting 
involving LWG <a href="lwg-defects.html#1349">1349</a>, which seems to indicate that the remaining <tt>noexcept</tt> 
specifier at the member swap is incorrect and should be removed.
<p/>
But if we allow for a potentially throwing member swap of <tt>std::function</tt>, this causes 
another conflict with the exception specification for the following member function:
</p>
<blockquote><pre>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f) <span style="color:#C80000;font-weight:bolder">noexcept</span>;
</pre><blockquote><p>
<i>Effects</i>: <tt>function(f).<span style="color:#C80000;font-weight:bolder">swap</span>(*this);</tt>
</p>
</blockquote></blockquote>
<p>
Note that in this example the sub-expression <tt>function(f)</tt> does not cause any problems,
because of the nothrow-guarantee given in 20.8.11.2.1 [func.wrap.func.con] p. 10. The problem
is located in the usage of the swap which could potentially throw given the general latitude. 
<p/>
So, either the Madrid meeting decision need to be revised (and both member and free swap of 
<tt>std::function</tt> should be noexcept), or this function needs to be adapted as well,
e.g. by taking the exception-specification away or by changing the semantics.
<p/>
One argument for "swap-may-throw" would be to allow for small-object optimization techniques
where the copy of the target may throw. But given the fact that the swap function has been guaranteed 
to be "Throws: Nothing" from TR1 on, it seems to me that that there would still be opportunities to 
perform small-object optimizations just restricted to the set of target copies that cannot throw. 
<p/>
In my opinion member swap of <tt>std::function</tt> has always been intended to be no-throw, because
otherwise there would be no good technical reason to specify the effects of several member 
functions in terms of the "construct-swap" idiom (There are three functions that are defined
this way), which provides the strong exception safety in this case. I suggest to enforce that both 
member swap and non-member swap of <tt>std::function</tt> are nothrow functions as it had been guaranteed 
since TR1 on.
</p>

<p><i>[
2011 Bloomington
]</i></p>

<p>
Dietmar: May not be swappable in the first place.
</p>
<p>
Alisdair: This is wide contact. Then we should be taking noexcept off instead of putting it on. This is preferred resolution.
</p>
<p>
Pablo: This is bigger issue. Specification of assignment in terms of swap is suspect to begin with. It is over specification.
How this was applied to string is a better example to work from.
</p>
<p>
Pablo: Two problems: inconsistency that should be fixed (neither should have noexcept), the other issues is that assignment
should not be specified in terms of swap. There are cases where assignment should succeed where swap would fail. This is easier
with string as it should follow container rules.
</p>
<p>
<b>Action Item</b> (Alisdair): There are a few more issues found to file.
</p>
<p>
Dave: This is because of allocators? The allocator makes this not work.
</p>
<p>
Howard: There is a type erased allocator in shared_ptr. There is a noexcept allocator in shared_ptr.
</p>
<p>
Pablo: shared_ptr is a different case. There are shared semantics and the allocator does move around.
A function does not have shared semantics.
</p>
<p>
Alisdair: Function objects think they have unique ownership.
</p>
<p>
Howard: In function we specify semantics with copy construction and swap.
</p>
<p>
<b>Action Item</b> (Pablo): Write this up better (why assignment should not be defined in terms of swap)
</p>
<p>
Howard: Not having trouble making function constructor no throw.
</p>
<p>
Dietmar: Function must allocate memory.
</p>
<p>
Howard: Does not put stuff that will throw on copy or swap in small object optimization. Put those on heap.
Storing allocator, but has to be no throw copy constructable.
</p>
<p>
Pablo: Are you allowed to or required to swap or move allocators in case or swap or move.
</p>
<p>
Dave: An allocator that is type erased should be different...
</p>
<p>
Pablo: it is
</p>
<p>
Dave: Do you need to know something about allocator types? But only at construction time.
</p>
<p>
Pablo: You could have allocators that are different types.
</p>
<p>
Dave: Swap is two ended operation.
</p>
<p>
Pablo: Opinion is that both have to say propagate on swap for them to swap.
</p>
<p>
John: It is not arbitrary. If one person says no. No is no.
</p>
<p>
Howard: Find noexcept swap to be very useful. Would like to move in that direction and bring container design along.
</p>
<p>
Dave: If you have something were allocator must not propagate you can detect that at construction time.
</p>
<p>
...
</p>
<p>
Pablo: Need to leave this open and discuss in smaller group.
</p>
<p>
Alisdair: Tried to add boost::any as TR2 proposal and ran into this issue. Only the first place where we run into
issues with type erased allocators. Suggest we move it to open.
</p>
<p>
<b>Action Item</b>: Move to open.
</p>
<p>
<b>Action Item</b> (Pablo works with Howard and Daniel): Address the more fundamental issue
(which may be multiple issues) and write up findings.
</p>

<p><i>[
<b>Original resolution</b>:
]</i></p>

<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the header <tt>&lt;functional&gt;</tt> synopsis in 20.8 [function.objects] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>function</tt> synopsis in 20.8.11.2 [func.wrap.func] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  <i>// [func.wrap.func.alg], specialized algorithms:</i>
  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.8.11.2.7 [func.wrap.func.alg] as indicated:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2) <ins>noexcept</ins>;
</pre><blockquote><p>
-1- <i>Effects</i>: <tt>f1.swap(f2);</tt>
</p></blockquote></blockquote>
</li>

</ol>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2063"></a>2063. Contradictory requirements for string move assignment</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-05-29 <b>Last modified:</b> 2011-11-21</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.4.1 [string.require]&#47;p4 says that <tt>basic_string</tt> is an "allocator-aware" 
container and behaves as described in 23.2.1 [container.requirements.general].
<p/>
23.2.1 [container.requirements.general] describes move assignment in p7 and Table 99.
<p/>
If <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt> 
is false, and if the allocators stored in the lhs and rhs sides are not equal, then move 
assigning a string has the same semantics as copy assigning a string as far as resources are 
concerned (resources can not be transferred). And in this event, the lhs may have to acquire 
resources to gain sufficient capacity to store a copy of the rhs.
<p/>
However 21.4.2 [string.cons]&#47;p22 says:
</p><blockquote><pre>
basic_string&lt;charT,traits,Allocator&gt;&amp;
operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</pre><blockquote><p>
<i>Effects</i>: If <tt>*this</tt> and <tt>str</tt> are not the same object, modifies <tt>*this</tt> 
as shown in Table 71. [<i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]
</p></blockquote></blockquote><p>
These two specifications for <tt>basic_string::operator=(basic_string&amp;&amp;)</tt> are in conflict with 
each other. It is not possible to implement a <tt>basic_string</tt> which satisfies both requirements.
<p/>
Additionally assign from an rvalue <tt>basic_string</tt> is defined as:
</p><blockquote><pre>
basic_string&amp; assign(basic_string&amp;&amp; str) noexcept;
</pre><blockquote><p>
<i>Effects</i>: The function replaces the string controlled by <tt>*this</tt> with a string of length 
<tt>str.size()</tt> whose elements are a copy of the string controlled by <tt>str</tt>. [ <i>Note</i>: A valid 
implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]
</p></blockquote></blockquote><p>
It seems contradictory that this member can be sensitive to <tt>propagate_on_container_swap</tt> instead 
of <tt>propagate_on_container_move_assignment</tt>.  Indeed, there is a very subtle chance for undefined 
behavior here:  If the implementation implements this in terms of <tt>swap</tt>, and if 
<tt>propagate_on_container_swap</tt> is false, and if the two allocators are unequal, the behavior 
is undefined, and will likely lead to memory corruption.  That's a lot to go wrong under a member 
named "assign".
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Alisdair: Can this be conditional noexcept?
</p>
<p>
Pablo: We said we were not going to put in many conditional noexcepts. Problem is not allocator, but non-normative definition. It says swap is a valid operation which it is not.
</p>
<p>
Dave: Move assignment is not a critical method.
</p>
<p>
Alisdair: Was confusing assignment and construction.
</p>
<p>
Dave: Move construction is critical for efficiency.
</p>
<p>
Kyle: Is it possible to test for noexcept.
</p>
<p>
Alisdair: Yes, query the noexcept operator.
</p>
<p>
Alisdair: Agreed there is a problem that we cannot unconditionally mark these operations as noexcpet.
</p>
<p>
Pablo: How come swap is not defined in alloc
</p>
<p>
Alisdair: It is in utility.
</p>
<p>
Pablo: Swap has a conditional noexcept. Is no throw move constructable, is no throw move assignable.
</p>
<p>
Pablo: Not critical for strings or containers.
</p>
<p>
Kyle: Why?
</p>
<p>
Pablo: They do not use the default swap.
</p>
<p>
Dave: Important for deduction in other types.
</p>
<p>
Alisdair: Would change the policy we adopted during FDIS mode.
</p>
<p>
Pablo: Keep it simple and get some vendor experience.
</p>
<p>
Alisdair: Is this wording correct? Concerned with bullet 2.
</p>
<p>
Pablo: Where does it reference containers section.
</p>
<p>
Alisdair: String is a container.
</p>
<p>
Alisdair: We should not remove redundancy piecemeal.
</p>
<p>
Pablo: I agree. This is a deviation from rest of string. Missing forward reference to containers section.
</p>
<p>
Pablo: To fix section 2. Only the note needs to be removed. The rest needs to be a forward reference to containers.
</p>
<p>
Alisdair: That is a new issue.
</p>
<p>
Pablo: Not really. Talking about adding one sentence, saying that basic string is a container.
</p>
<p>
Dave: That is not just a forward reference, it is a semantic change.
</p>
<p>
PJ: We intended to make it look like a container, but it did not satisfy all the requirements.
</p>
<p>
Pablo: Clause 1 is correct. Clause 2 is removing note and noexcept (do not remove the rest). Clause 3 is correct.
</p>
<p>
Alisdair: Not sure data() is correct (in clause 2).
</p>
<p>
Conclusion: Move to open, Alisdair and Pablo volunteered to provide wording
</p>

<p><i>[
originally proposed wording:
]</i></p>


<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the class template <tt>basic_string</tt> synopsis in 21.4 [basic.string]:</p>
<blockquote><pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    basic_string&amp; operator=(basic_string&amp;&amp; str) <del>noexcept</del>;
    [&hellip;]
    basic_string&amp; assign(basic_string&amp;&amp; str) <del>noexcept</del>;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Remove the definition of the <tt>basic_string</tt> move assignment operator from 21.4.2 [string.cons] 
entirely, including Table 71 &mdash; <tt>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;&amp;)</tt>.
This is consistent with how we define move assignment for the containers in Clause 23:</p>
<blockquote><pre>
<del>basic_string&lt;charT,traits,Allocator&gt;&amp;
operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;</del>
</pre><blockquote><p>
<del>-22- <i>Effects</i>: If <tt>*this</tt> and <tt>str</tt> are not the same object, modifies <tt>*this</tt> as shown 
in Table 71. [ <i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]</del>
<p/>
<del>-23- If <tt>*this</tt> and <tt>str</tt> are the same object, the member has no effect.</del>
<p/>
<del>-24- <i>Returns</i>: <tt>*this</tt></del>
</p></blockquote></blockquote>
<blockquote>
<table border="1">
<caption><del>Table 71 &mdash; <tt>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;&amp;)</tt></del></caption>

<tr>
<th><del>Element</del></th>
<th><del>Value</del></th>
</tr>

<tr>
<td><del><tt>data()</tt></del></td>
<td><del>points at the array whose first element was pointed
at by <tt>str.data()</tt></del></td>
</tr>

<tr>
<td><del><tt>size()</tt></del></td>
<td><del>previous value of <tt>str.size()</tt></del></td>
</tr>

<tr>
<td><del><tt>capacity()</tt></del></td>
<td><del>a value at least as large as <tt>size()</tt></del></td>
</tr>

</table> 
</blockquote>
</li>

<li><p>Modify the paragraphs prior to 21.4.6.3 [string::assign] p.3 as indicated (The
first insertion recommends a separate paragraph number for the indicated paragraph):</p>
<blockquote><pre>
basic_string&amp; assign(basic_string&amp;&amp; str) <del>noexcept</del>;
</pre><blockquote><p>
<ins>-?-</ins> <i>Effects</i>: <ins>Equivalent to <tt>*this = std::move(str)</tt>.</ins>
<del>The function replaces the string controlled by <tt>*this</tt> with a string of length 
<tt>str.size()</tt> whose elements are a copy of the string controlled by <tt>str</tt>. 
[ <i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]</del>
<p/>
-3- <i>Returns</i>: <tt>*this</tt>
</p></blockquote></blockquote>

</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2070"></a>2070. <tt>allocate_shared</tt> should use <tt>allocator_traits&lt;A&gt;::construct</tt></h3>
<p><b>Section:</b> 20.7.2.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-07-11 <b>Last modified:</b> 2011-12-05</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.7.2.2.6 [util.smartptr.shared.create] says:
</p>
<blockquote><p>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in that memory
via the placement new expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template
<tt>allocate_shared</tt> uses a copy of a to allocate memory. If an exception is thrown, the functions have
no effect.
</p></blockquote>
<p>
This explicitly requires placement new rather than using
<tt>allocator_traits&lt;A&gt;::construct(a, (T*)pv, std::forward&lt;Args&gt;(args)...)</tt>
In most cases that would result in the same placement new expression,
but would allow more control over how the object is constructed e.g.
using <tt>scoped_allocator_adaptor</tt> to do uses-allocator construction, or
using an allocator declared as a friend to construct objects with no
public constructors.
</p>

<p><i>[
2011-08-16 Bloomington:
]</i></p>

<p>
Agreed to fix in principle, but believe that <tt>make_shared</tt> and
<tt>allocate_shared</tt> have now diverged enough that their descriptions
should be separated.  Pablo and Stefanus to provide revised wording.
</p>

<p><strong>Daniel's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.7.2.2.6 [util.smartptr.shared.create] as indicated (The suggested
removal of the last sentence of p1 is not strictly required to resolve this issue, but is still recommended,
because it does not say anything new but may give the impression that it says something new):
</p><blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-1- <i>Requires</i>: <ins>For the template <tt>make_shared</tt>, t</ins><del>T</del>he expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <ins>For the template <tt>allocate_shared</tt>, the expression 
<tt>allocator_traits&lt;A&gt;::construct(a, pt, std::forward&lt;Args&gt;(args)...)</tt>,
where <tt>pt</tt> has type <tt>T*</tt> and points to storage suitable to hold an object
of type <tt>T</tt>, shall be well formed.</ins> <tt>A</tt> shall be an allocator ([allocator.requirements]). 
<del>The copy constructor and destructor of  <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in 
that memory<ins>. The template <tt>make_shared</tt> constructs the object</ins> via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory<ins> and constructs the object by calling <tt>allocator_traits&lt;A&gt;::construct(a, pt,
std::forward&lt;Args&gt;(args)...)</tt></ins>. If an exception is thrown, the functions have no effect.
<p/>
-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.
<p/>
-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-5- <i>Throws</i>: <tt>bad_alloc</tt>, or<ins>, for the template <tt>make_shared</tt>, an exception thrown from
the constructor of <tt>T</tt>, or, for the template <tt>allocate_shared</tt>,</ins> an exception thrown from 
<tt>A::allocate</tt> or <ins>from <tt>allocator_traits&lt;A&gt;::construct</tt></ins><del>from the constructor of 
<tt>T</tt></del>.
<p/>
-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [ <i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i> ]
<p/>
-7- [ <i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2011-12-04: Jonathan and Daniel improve wording]</i></p>


<p>See also c++std-lib-31796</p>






<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.7.2.2.6 [util.smartptr.shared.create] as indicated:
</p>
<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
<del>template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);</del>
</pre></blockquote>
<p>
<del>-1- <i>Requires</i>: The expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <tt>A</tt> shall be an allocator (17.6.3.5 [allocator.requirements]). The copy constructor 
and destructor of <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: <ins>Equivalent to</ins>
</p>
<blockquote><pre> 
<ins>return allocate_shared&lt;T&gt;(allocator&lt;T&gt;(), std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<del>Allocates memory suitable for an object of type <tt>T</tt> 
and constructs an object in that memory via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory. If an exception is thrown, the functions have no effect.</del>
<p/>
<ins>-?- <i>Remarks</i>: An implementation may meet the effects (and the implied guarantees) without 
creating the allocator object [<i>Note</i>: That is, user-provided specializations of <tt>std::allocator</tt>
may not be instantiated, the expressions <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt> and 
<tt>pv-&gt;~T()</tt> may be evaluated directly &mdash; <i>end note</i>].</ins>
<p/>
<del>-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.</del>
<p/>
<del>-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt></del>
<p/>
<del>-5- <i>Throws</i>: <tt>bad_alloc</tt>, or an exception thrown from <tt>A::allocate</tt> or from the 
constructor of <tt>T</tt>.</del>
<p/>
<del>-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i>]</del>
<p/>
<del>-7- [<i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow 
for internal bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]</del>
</p>
</li>
<li><p>
Add the following set of <ins>new paragraphs</ins> immediately following the previous paragraph 7 of
20.7.2.2.6 [util.smartptr.shared.create]:
</p>
<blockquote><pre>
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-?- <i>Requires</i>: The expressions 
<tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt> and
<tt>allocator_traits&lt;A&gt;::destroy(b, pt)</tt> shall be well-formed and well-defined, 
where <tt>b</tt> has type <tt>A</tt> and is a copy of <tt>a</tt> and where <tt>pt</tt> 
has type <tt>T*</tt> and points to storage suitable to hold an object of type <tt>T</tt>. 
<tt>A</tt> shall meet the allocator requirements (17.6.3.5 [allocator.requirements]). 
<p/>
-?- <i>Effects</i>: Uses an object <tt>a2</tt> 
of type <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to allocate memory suitable for an object of type <tt>T</tt>. 
Uses a copy <tt>b</tt> of type <tt>A</tt> from <tt>a</tt> to construct an object of type <tt>T</tt> in 
that memory by calling <tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt>. 
If an exception is thrown, the function has no effect.
<p/>
-?- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>. When ownership is given up, the effects are as follows: Uses a copy <tt>b2</tt> 
of type <tt>A</tt> from <tt>a</tt> to destruct an object of type <tt>T</tt> by calling 
<tt>allocator_traits&lt;A&gt;::destroy(b2, pt2)</tt> where <tt>pt2</tt> has type <tt>T*</tt> 
and refers to the newly constructed object. Then uses an object of type
<tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to deallocate the allocated memory.
<p/>
-?- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-?- <i>Throws</i>: Nothing unless memory allocation or <tt>allocator_traits&lt;A&gt;::construct</tt> 
throws an exception.
<p/>
-?- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory 
allocation. [<i>Note</i>: Such an implementation provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
<p/>
-?- [<i>Note</i>: This function will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2071"></a>2071. <tt>std::valarray</tt> move-assignment</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.assign] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2011-05-05 <b>Last modified:</b> 2011-11-22</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.assign">issues</a> in [valarray.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Yesterday I noticed that the language we have in the FDIS about <tt>std::valarray</tt> move assignment 
is inconsistent with the resolution of LWG 675. Indeed, we guarantee constant complexity (vs linear 
complexity). We also want it to be noexcept, that is more subtle, but again it's at variance with all 
the containers.
<p/>
Also, even if we suppose that LWG <a href="lwg-defects.html#675">675</a> applies only to the containers proper, I don't think the current 
"as if by calling resize(v.size())" is internally consistent with the noexcept requirement.
<p/>
So, what do we really want for <tt>std::valarray</tt>? Shall we maybe just strike or fix the as-if, consider it 
some sort of pasto from the copy-assignment text, thus keep the noexcept and constant complexity requirements 
(essentially the whole operation would boild down to a swap of POD data members). Or LWG <a href="lwg-defects.html#675">675</a> should be 
explicitly extended to <tt>std::valarray</tt> too? In that case both noexcept and constant complexity 
would go, I think, and the operation would boil down to the moral equivalent of <tt>clear()</tt> (which 
doesn't really exist in this case) + <tt>swap</tt>?
</p>

<p>
Howard: I agree the current wording is incorrect.  The complexity should be linear in <tt>size()</tt> (not 
<tt>v.size()</tt>) because the first thing this operator needs to do is <tt>resize(0)</tt> (or <tt>clear()</tt> 
as you put it).
<p/>
I think we can keep the <tt>noexcept</tt>.
<p/>
As for proper wording, here's a first suggestion:
</p><blockquote><p>
<i>Effects</i>: <tt>*this</tt> obtains the value of <tt>v</tt>. The value of <tt>v</tt> after the assignment 
is not specified.
<p/>
<i>Complexity</i>: linear.
</p></blockquote><p>
</p>

<p>
See also reflector discussion startin with c++std-lib-30690.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>In 26.6.2.3 [valarray.assign] update as follows:</p>

<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(valarray&lt;T&gt;&amp;&amp; v) noexcept;
</pre><blockquote><p>
3 <i>Effects</i>: <tt>*this</tt> obtains the value of <tt>v</tt>. <del>If the length of <tt>v</tt> 
is not equal to the length of <tt>*this</tt>, resizes <tt>*this</tt> to make the two arrays the 
same length, as if by calling <tt>resize(v.size())</tt>, before performing the assignment.</del><ins>The 
value of <tt>v</tt> after the assignment is not specified.</ins>
<p/>
4 <i>Complexity</i>: <del>Constant</del><ins>Linear</ins>.
</p></blockquote></blockquote>






<hr>
<h3><a name="2072"></a>2072. Unclear wording about capacity of temporary buffers</h3>
<p><b>Section:</b> 20.6.11 [temporary.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2011-08-10 <b>Last modified:</b> 2011-11-22</p>
<p><b>View all other</b> <a href="lwg-index.html#temporary.buffer">issues</a> in [temporary.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 20.6.11 [temporary.buffer] p1+2:

</p><blockquote><pre>
template &lt;class T&gt;
pair&lt;T*, ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t n) noexcept;
</pre><blockquote><p>
-1- <i>Effects</i>: Obtains a pointer to storage sufficient to store up to <tt>n</tt> adjacent <tt>T</tt> 
objects. It is implementation-defined whether over-aligned types are supported (3.11).
<p/>
-2- <i>Returns</i>: A pair containing the buffer's address and capacity (in the units of <tt>sizeof(T)</tt>), 
or a pair of 0 values if no storage can be obtained or if <tt>n &lt;= 0</tt>.
</p></blockquote></blockquote>
<p>
I read this as prohibiting to return a buffer of which capacity is less than <tt>n</tt>, because 
such a buffer is not sufficient to store <tt>n</tt> objects.
<p/>
The corresponding description in <a href="http://www.sgi.com/tech/stl/get_temporary_buffer.html">SGI STL</a> 
is clear on this point, but I think it is a bit too verbose:
</p>

<blockquote class="note"><p>
(for the return value, a pair <tt>P</tt>) [...] the buffer pointed to by <tt>P.first</tt> is large enough 
to hold <tt>P.second</tt> objects of type <tt>T</tt>. <tt>P.second</tt> is greater than or equal to 0, 
and less than or equal to <tt>len</tt>.
</p></blockquote>

<p>
There seems to be two different targets of the "up to n" modification:
The capacity of obtained buffer, and the actual number that the caller
will store into the buffer.
<p/>
First I read as the latter, and got surprised seeing that libstdc++
implementation can return a smaller buffer. I started searching about
<tt>get_temporary_buffer()</tt>. After reading a quote from TC++PL at
<a href="http://stackoverflow.com/questions/3264299/why-do-i-need-stdget-temporary-buffer">stackoverflow</a>, 
I realized that the former is intended.
<p/>
Such misinterpretation seems common:
</p>
<ul>
<li>The above question is likely started from same misinterpretation.</li>
<li><p>JIS standard (Japanese translation of ISO&#47;IEC standard) says nothing
    like "up to". I think the editor misinterpreted the original wording,
    and omitted words for "up to" as it is redundant. (If a buffer is
    sufficient to store <tt>n</tt> objects, it is also sufficient to store
    up to <tt>n</tt> objects.)</p></li>
<li><p>Rogue Wave implementation doesn't return smaller buffer, instead, it
    can return larger buffer on some circumstances. Apache 
	<a href="http://stdcxx.apache.org/">STDCXX</a> is a derived version of that
    implementation, and <a href="https://stdcxx.apache.org/doc/stdlibref/get-temporary-buffer.html">publicly accessible</a>:
</p>
<blockquote class="note"><p>
Specializations of the <tt>get_temporary_buffer()</tt> function template
attempt to allocate a region of storage sufficiently large to store at
least <tt>n</tt> adjacent objects of type <tt>T</tt>.
</p></blockquote>
<p>
I know one commercial compiler package based on Rogue Wave implementation, 
and its implementation is essentially same as the above.
</p>
</li>
</ul>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2073"></a>2073. Library exceptions that take string arguments</h3>
<p><b>Section:</b> 19.2 [std.exceptions], 19.5.6 [syserr.syserr], 27.5.3.1.1 [ios::failure] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eelis van der Weegen <b>Opened:</b> 2011-08-16 <b>Last modified:</b> 2011-11-22</p>
<p><b>View all other</b> <a href="lwg-index.html#std.exceptions">issues</a> in [std.exceptions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This is an extension issue for LWG to add constructor overloads that take a 
<tt>string</tt> by an rvalue reference in order to move the string into the 
exception.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2074"></a>2074. Off by one error in <tt>std::reverse_copy</tt></h3>
<p><b>Section:</b> 25.3.10 [alg.reverse] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Miller <b>Opened:</b> 2011-08-17 <b>Last modified:</b> 2011-11-22</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.reverse">issues</a> in [alg.reverse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The output of the program below should be:
</p>
<blockquote><pre>
"three two one null \n"
</pre></blockquote>
<p>
But when <tt>std::reverse_copy</tt> is implemented as described in N3291 25.3.10 [alg.reverse] 
it's:
</p>
<blockquote><pre>
"null three two one \n"
</pre></blockquote>
<p>
because there's an off by one error in 25.3.10 [alg.reverse]&#47;4; the definition should read:
</p>
<blockquote><pre>
*(result + (last - first) <span style="color:#C80000;font-weight:bold">- 1</span> - i) = *(first + i)
</pre></blockquote>
<p>
Test program:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

template &lt;typename BiIterator, typename OutIterator&gt;
auto
reverse_copy_as_described_in_N3291(
  BiIterator first, BiIterator last, OutIterator result )
-&gt; OutIterator
{
  // 25.3.10&#47;4 [alg.reverse]:
  // "...such that for any non-negative integer i &lt; (last - first)..."
  for ( unsigned i = 0; i &lt; ( last - first ); ++i )
    // "...the following assignment takes place:"
    *(result + (last - first) - i) = *(first + i);

  // 25.3.10&#47;6
  return result + (last - first);
}

int main()
{
  using std::begin;
  using std::end;
  using std::cout;

  static const char*const in[3]  { "one", "two", "three" };
  const char*             out[4] { "null", "null", "null", "null" };

  reverse_copy_as_described_in_N3291( begin( in ), end( in ), out );

  for ( auto s : out )
    cout &lt;&lt; s &lt;&lt; ' ';

  cout &lt; std::endl;

  return 0;
}
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>
Change 25.3.10 [alg.reverse] p4 as follows:
</p> 
<blockquote><pre>
template&lt;class BidirectionalIterator, class OutputIterator&gt;
  OutputIterator
    reverse_copy(BidirectionalIterator first,
                 BidirectionalIterator last, OutputIterator result);
</pre><blockquote><p>
-4- <i>Effects</i>: Copies the range [<tt>first,last</tt>) to the range [<tt>result,result+(last-first)</tt>) 
such that for any non-negative integer <tt>i &lt; (last - first)</tt> the following assignment takes place: 
<tt>*(result + (last - first) <ins>- 1</ins> - i) = *(first + i)</tt>.
<p/>
-5- <i>Requires</i>: The ranges [<tt>first,last</tt>) and [<tt>result,result+(last-first)</tt>) shall not overlap.
<p/>
-6- <i>Returns</i>: <tt>result + (last - first)</tt>.
<p/>
-7- <i>Complexity</i>: Exactly <tt>last - first</tt> assignments.
</p></blockquote></blockquote>





<hr>
<h3><a name="2075"></a>2075. Progress guarantees, lock-free property, and scheduling assumptions</h3>
<p><b>Section:</b> 1.10 [intro.multithread], 29.4 [atomics.lockfree], 29.6.5 [atomics.types.operations.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Torvald Riegel <b>Opened:</b> 2011-08-18 <b>Last modified:</b> 2011-12-02</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 1.10 [intro.multithread] p2: 
</p>
<blockquote><p>
"Implementations should ensure that all unblocked threads eventually make progress."
</p></blockquote>
<ul>
<li>If taken literally, this cannot be achieved with lock-free atomics in
 general because they only guarantee that some thread makes progress
 (i.e., minimal progress, whereas 1.10 [intro.multithread] p2 seems to 
 require maximal progress).
</li>
<li>What does it mean precisely to "make progress"? Does "unblocked
 threads" exclude live-locked threads (if so, lock-free atomics would
 be sufficient I suppose)?
</li>
<li><p>Which assumptions can an implementation make about the thread
 scheduling? This is relevant for how implementations implement
 compare-exchange with load-linked &#47; store conditional (LL-SC), and
 atomic read-modifiy-write operations with load...compare-exchange-weak
 loops.
</p>
<ul>
<li>Do threads run long enough without being descheduled (e.g.,
   OS timeslices are long enough, interrupt frequency is not too
   high, etc.)?
</li>
<li>Or is this implementation-defined, and the sentence is just about
   stating that the progress guarantees will not hold on, for example,
   systems with unfair scheduling or thread priorities?
</li>
</ul>
</li>
</ul>

<p>
29.4 [atomics.lockfree] p2 declares the lock-free property for a
particular object. However, "lock-free" is never defined, and in discussions 
that I had with committee members it seemed as if the standard's lock-free would be
different from what lock-free means in other communities (eg, research,
text books on concurrent programming, etc.).
</p>
<ul>
<li>Originally, lock-freedom for an object requires minimal progress (ie,
 some thread makes progress, but other threads might never do) without
 any assumptions about the scheduling (threads could be stopped
 executing (so it is "nonblocking"), and threads are not guaranteed to
 execute in isolation, even for very small intervals of cycles).
</li>
<li>In contrast, obstruction-freedom, another nonblocking progress
 condition, guarantees progress for all threads that eventually get
 executed long enough in isolation (ie, without interference by other
 threads).
</li>
<li>Simple load...compare-exchange-weak loops (or LL-SC loops) to
 implement atomic read-modify-write operations can be just
 obstruction-free but not lock-free because they can livelock
 (depending on the hardware's LL-SC implementation, though). However,
 they effectively guarantee the same as lock-free iff threads will
 eventually run in isolation for long enough (that can be an assumption
 about the OS scheduler), or if the implementation adds this (e.g.,
 probabilistically by employing randomized exponential back-off when
 contention is detected, in all operations that can create contention).
</li>
<li>Does the particular object has to be lock-free, or is it only required
 that threads make progress irrespective on which object? Again
 considering compare-exchange-weak or LL-SC here, what happens if the
 compare-exchange object shares a cacheline with an integer counter
 object that is constantly updated by other threads? The
 compare-exchange-weak can always fail, so the object would not be
 lock-free. However, if we consider progress to be overall progress for
 threads, it would be lock-free because other threads succeed updating
 the integer counter. I would have assumed the lock-free property is
 strictly about the atomic object, but in discussions with committee
 members it seemed as if progress for any object could be the intended
 guarantee.
</li>
</ul>

<p>
Following 29.6.5 [atomics.types.operations.req] p7 <tt>is_lock_free()</tt> 
returns "true if the object is lock-free". What is returned if the object is only 
sometimes lock-free?
</p>

<p>
Basically, I would like to see clarifications for the progress
guarantees so that users know what they can expect from implementations
(and what they cannot expect!), and to give implementors a clearer
understanding of which user expectations they have to implement.
</p>
<ol>
<li><p>Elaborate on the intentions of the progress guarantee in 
1.10 [intro.multithread] p2. As I don't know about your intentions, 
it's hard to suggest a resolution.
</p>
<ul>
<li>Is it for straightforward, non-synchronizing code only?</li>
<li>Is it for blocking code only? (Is "unblocked" more than blocked on
 external I/O or on deadlocks?)
</li>
<li>What does it mean to "make progress"?</li>
<li>Is this meant to only waive any progress guarantees if there are
 thread priorities?
</li>
<li>Can an implementation make any assumptions about thread scheduling?
</li>
</ul>
</li>
<li><p>Define the lock-free property. The definition should probably include
the following points:
</p>
<ul>
<li>Is it just nonblocking, or what is the distinction to just being nonblocking?</li>
<li>Does it make any assumptions about the scheduler?</li>
<li>What are the progress guarantees, minimal or maximal (some or all threads finish eventually).</li>
<li>Is progress guaranteed for all operations on the particular object, or
 do operations on other objects also count as "making progress"?
</li>
</ul>
</li>
<li>Add a note explaining that compare-exchange-weak is not necessarily
lock-free (but is nonblocking)? Or is it indeed intended to be lock-free
(only allowed to fail spuriously but guaranteed to not fail eventually)?
Implementing the latter might be a challenge on LL-SC machines or lead
to space overheads I suppose, see the cacheline sharing example above.
</li>
</ol>

<p><i>[2011-12-01: Hans comments]</i></p>


<p>
1.10 [intro.multithread] p2 was an intentional compromise, and it was understood at the 
time that it was not a precise statement.  The wording was introduced by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3209.htm">N3209</a>, which 
discusses some of the issues. There were additional reflector discussions.
<p/>
This is somewhat separable from the question of what lock-free means, which is probably a more 
promising question to focus on.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2076"></a>2076. Bad <tt>CopyConstructible</tt> requirement in set constructors</h3>
<p><b>Section:</b> 23.4.6.2 [set.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2011-11-23</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.4.6.2 [set.cons] paragraph 4 says: 
</p>

<blockquote><p>
<i>Requires</i>: If the iterators dereference operator returns an lvalue or a non-const rvalue, 
then <tt>Key</tt> shall be <tt>CopyConstructible</tt>.
</p></blockquote>

<p>
I'm confused why a "non-const rvalue" for the return value of the iterator
would require <tt>CopyConstructible</tt>; isn't that exactly the situation 
when you'd want to apply the move constructor?
<p/>
The corresponding requirement for <tt>multimap</tt> seems better in that regard
([multimap.cons] paragraph 3):
</p>
<blockquote><p>
Requires: If the iterators dereference operator returns an lvalue or a const rvalue 
<tt>pair&lt;key_type, mapped_type&gt;</tt>, then both <tt>key_type</tt> and mapped_type 
shall be <tt>CopyConstructible</tt>.
</p></blockquote>
<p>
Obviously, if I have a const rvalue, I can't apply the move constructor (which will 
likely attempt modify its argument).
<p/>
Dave Abrahams:
<p/>
I think you are right.
Proposed resolution: drop "non-" from 23.4.6.2 [set.cons] paragraph 3.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>
Change 23.4.6.2 [set.cons] p3 as follows:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  set(InputIterator first, InputIterator last,
    const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
</pre><blockquote><p>
-3- Effects: Constructs an empty set using the specified comparison object and allocator, and inserts
elements from the range [<tt>first,last</tt>).
<p/>
-4- <i>Requires</i>: If the iterators dereference operator returns an lvalue or a <del>non-</del>const rvalue, 
then <tt>Key</tt> shall be <tt>CopyConstructible</tt>.
<p/>
-5- <i>Complexity</i>: Linear in <tt>N</tt> if the range [<tt>first,last</tt>) is already sorted using 
<tt>comp</tt> and otherwise <tt>N logN</tt>, where <tt>N</tt> is <tt>last - first</tt>.
</p></blockquote></blockquote>





<hr>
<h3><a name="2077"></a>2077. Further incomplete constraints for type traits</h3>
<p><b>Section:</b> 20.9.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2011-11-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The currently agreed on proposed wording for <a href="lwg-active.html#2015">2015</a> using 
<tt>remove_all_extents&lt;T&gt;::type</tt> instead of the "an array of 
unknown bound" terminology in the precondition should be extended to 
some further entries especially in Table 49, notably the 
<tt>is_*constructible</tt>, <tt>is_*assignable</tt>, and 
<tt>is_*destructible</tt> entries. To prevent ODR violations, incomplete
element types of arrays must be excluded for value-initialization and
destruction for example. Construction and assignment has to be honored, 
when we have array-to-pointer conversions or pointer conversions of
incomplete pointees in effect.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2078"></a>2078. Throw specification of <tt>async()</tt> incomplete</h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-08-29 <b>Last modified:</b> 2011-11-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The current throw specification of <tt>async()</tt> does state:
</p>
<blockquote><p>
-6- <i>Throws</i>: <tt>system_error</tt> if policy is <tt>launch::async</tt> and 
the implementation is unable to start a new thread.
</p></blockquote>
<p>
First it seems not clear whether this only applies if policy equals 
<tt>launch::async</tt> of if the <tt>async</tt> launch mode flag is set 
(if <tt>policy|launch::async!=0</tt>)
<p/>
In the discussion Lawrence Crowl also wrote:
</p>
<blockquote><p>
    More generally, I think what we want to say is that if the
    implementation cannot successfully execute on one of the policies
    allowed, then it must choose another. The principle would apply
    to implementation-defined policies as well.
</p></blockquote>

<p>
Peter Sommerlad:
</p>
<blockquote><p>
Should not throw. That was the intent. "is async" meat exactly.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2079"></a>2079. Required <tt>pow()</tt> overloads</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2011-08-29 <b>Last modified:</b> 2011-11-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
LWG issue <a href="lwg-defects.html#550">550</a> removed the functions:
</p>
<blockquote><pre>
float       pow(float, int);
double      pow(double, int);
long double pow(long double, int);
</pre></blockquote>
<p>
from header <tt>&lt;cmath&gt;</tt>. This change does not seem to be mentioned in Annex C, C.2.14.
<p/>
Howard:
</p>
<blockquote><p>
N3290 26.8 [c.math]&#47;p11 says:
</p><blockquote>
<p>
Moreover, there shall be additional overloads sufficient to ensure:
</p>
<ol>
<li>If any argument corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, 
then all arguments corresponding to <tt>double</tt> parameters are effectively cast to 
<tt>long double</tt>.
</li>
<li>Otherwise, if any argument corresponding to a <tt>double</tt> parameter has type <tt>double</tt> 
or an integer type, then all arguments corresponding to <tt>double</tt> parameters are effectively 
cast to <tt>double</tt>.
</li>
<li>Otherwise, all arguments corresponding to <tt>double</tt> parameters are effectively cast to 
<tt>float</tt>.
</li>
</ol>
</blockquote>
<p>
From C99 7.12.7.4 we have:
</p>
<blockquote><pre>
double pow(double, double);
</pre></blockquote>
<p>
26.8 [c.math]&#47;p11&#47;b2 says that if the client calls <tt>pow(2.0f, 2)</tt>, then the 
<tt>int</tt> for second argument causes the following effective call to be made:
</p>
<blockquote><pre>
pow(static_cast&lt;double&gt;(2.0f), static_cast&lt;double&gt;(2)) -&gt; double
</pre></blockquote>
<p>
The first sentence of p11 implies that this is done by supplying the following additional overload:
</p>
<blockquote><pre>
double pow(float, int);
</pre></blockquote>
<p>
If the client calls <tt>pow(2.0, 2)</tt>, then the same reasoning (b2 again) implies the following 
additional overload:
</p>
<blockquote><pre>
double pow(double, int);
</pre></blockquote>
<p>
If the client calls <tt>pow(2.0l, 2)</tt>, then b1 implies the following additional overload:
</p>
<blockquote><pre>
long double pow(long double, int);
</pre></blockquote>
<p>
In all, p11 implies hundreds (perhaps thousands?) of extra overloads.  All but one of which is a superset 
of the overloads required by C++98&#47;03 (that one being <tt>pow(float, int)</tt> which had its return 
type changed from <tt>float</tt> to <tt>double</tt>).
<p/>
In practice, at least some vendors implement p11 by using templated overloads as opposed to ordinary overloads.
</p></blockquote>

<p>
Steve Clamage:
</p>
<blockquote><p>
Thanks. I didn't see that those extra overloads were actually implied by p11, despite the first sentence. 
Without examples, the point is a bit subtle (at least for me).
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2080"></a>2080. Specify when <tt>once_flag</tt> becomes invalid</h3>
<p><b>Section:</b> 30.4.4 [thread.once] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-08-30 <b>Last modified:</b> 2011-11-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In function <tt>call_once</tt> 30.4.4.2 [thread.once.callonce]
paragraph 4 and 5 specify for <tt>call_once()</tt>:
</p>

<blockquote>
<p>
<i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception]), 
or any exception thrown by <tt>func</tt>.
<p/>
<i>Error conditions</i>:
</p>
<ul>
<li><tt>invalid_argument</tt> &mdash; if the <tt>once_flag</tt> object is no longer valid.</li>
</ul>
</blockquote>

<p>
However, nowhere in 30.4.4 [thread.once] is specified, when a once-flag becomes invalid.
<p/>
As far as I know this happens if the flag is used for different functions. So we either have to have 
to insert a sentence&#47;paragraph in
</p>
<blockquote><p>
30.4.4.2 Function call_once [thread.once.callonce]
</p></blockquote>
<p>
or
</p>
<blockquote><p>
30.4.4 Call once [thread.once]
</p></blockquote>
<p>
explaining when a <tt>once_flag</tt> becomes invalidated or we should state as error condition something like:
</p>

<ul>
<li><tt>invalid_argument</tt> &mdash; if the <tt>func</tt> used in combination with the <tt>once_flag</tt> is different 
from a previously passed <tt>func</tt> for the same <tt>once_flag</tt>
</li>
</ul>

<p>
Anthony Williams:
</p>
<blockquote>
<p>
A <tt>once_flag</tt> is invalidated if you destroy it (e.g. it is an automatic object, or heap 
allocated and deleted, etc.)
<p/>
If the library can detect that this is the case then it will throw this exception. If it cannot 
detect such a case then it will never be thrown.
</p>
</blockquote>

<p>
Jonathan Wakely:
</p>
<blockquote>
<p>
I have also wondered how that error can happen in C++, where the type
system will reject a non-callable type being passed to <tt>call_once()</tt> and
should prevent a <tt>once_flag</tt> being used after its destructor runs.
<p/>
If a <tt>once_flag</tt> is used after its destructor runs then it is indeed
undefined behaviour, so implementations are already free to throw any
exception (or set fire to a printer) without the standard saying so.
<p/>
My assumption was that it's an artefact of basing the API on pthreads,
which says:
</p>
<blockquote>
<p>
The <tt>pthread_once()</tt> function may fail if:
<p/>
<tt>[EINVAL]</tt>  If either <tt>once_control</tt> or <tt>init_routine</tt> is invalid.
</p>
</blockquote>
</blockquote>

<p>
Pete Becker:
</p>
<blockquote><p>
Yes, probably. We had to clean up several UNIXisms that were in the original design.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2081"></a>2081. <tt>Allocator</tt> requirements should include <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-08-30 <b>Last modified:</b> 2011-12-06</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
As discussed in c++std-lib-31054 and c++std-lib-31059, the <tt>Allocator</tt>
requirements implicitly require <tt>CopyConstructible</tt> because
<tt>a.select_on_container_copy_construction()</tt> and
<tt>container.get_allocator()</tt> both return a copy by value, but the
requirement is not stated explicitly anywhere.
<p/>
In order to clarify that allocators cannot have 'explicit' copy
constructors, the requirements should include <tt>CopyConstructible</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 28 &mdash; Allocator requirements in 17.6.3.5 [allocator.requirements]:</p>

<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr> 
<tr>
<td>
<tt>X a1(a);<br/>
<ins>X a1 = a;</ins></tt>
</td>
<td>
</td>
<td>
Shall not exit via an exception.<br/>
post: <tt>a1 == a</tt>
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X a1(move(a));<br/>
<ins>X a1 = move(a);</ins></tt>
</td>
<td>
</td>
<td>
Shall not exit via an exception.<br/>
post: <tt>a1</tt> equals the prior value<br/>
of <tt>a</tt>.
</td>
<td>
</td>
</tr>
</table>

</li>

<li><p>Change 17.6.3.5 [allocator.requirements] paragraph 4:</p>

<blockquote><p>
<ins>An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> 
(17.6.3.1 [utility.arg.requirements]).</ins> The <tt>X::pointer</tt>, <tt>X::const_pointer</tt>, 
<tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> types shall satisfy the requirements of 
<tt>NullablePointer</tt> (17.6.3.3 [nullablepointer.requirements]). No constructor, comparison 
operator, copy operation, move operation, or swap operation on these types shall exit via an 
exception. <tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements 
for a random access iterator (24.2 [iterator.requirements]).
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2082"></a>2082. Misleading complexity requirements in <tt>&lt;algorithm&gt;</tt></h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-09-02 <b>Last modified:</b> 2011-11-24</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>partition_point()</tt> algorithm is specified with:
</p>
<blockquote><p>
<i>Complexity</i>: <i>O(log(last - first))</i> applications of <tt>pred</tt>.
</p></blockquote>
<p>
While this is correct, it gives the impression that this is a logarithmic algorithm.
But unless random access iterators are used it is not logarithmic because for advancing 
the iterator we have last-first steps, which means that the complexity becomes linear here.
<p/>
Shouldn't we clarify the complexity here to something like:
</p>
<blockquote><p>
<i>Complexity</i>: logarithmic for random-access iterators and linear otherwise
            (in any case <i>O(log(last - first)</i>) applications of <tt>pred</tt>).
</p></blockquote>
<p>
Or should we even require <i>O(log(last - first)</i> for random-access iterators only because 
for other iterators just iterating over all elements, while calling <tt>pred</tt> for each element, 
might often be faster.
</p>

<p>
Daniel Kr&uuml;gler:
</p>
<blockquote><p>
I agree that especially this description is a bit misleading. I'm not
convinced that this is a real defect, because the whole bunch of
templates within <tt>&lt;algorithm&gt;</tt> document the complexity solely of
<em>applications*</em> of predicates, assignment, or swaps, but never the
complexity of traversal operations (e.g. increment or iterator
equality tests). This means, the standard is consistent for this
function template, even though it could say a bit more.
<p/>
I would like to see a wording improvement, but I would rather think that
the complexity of the predicate should be mentioned first (as in other
algorithms) and that a non-normative note could be added for
specifically this algorithm to point out that this does not imply
a logarithmic traversal complexity. The note could give more details,
by explicity pointing out the linear traversal complexity for
non-random-Access iterators.
</p></blockquote>
<p>
Howard Hinnant:
</p>
<blockquote><p>
If we are going to make such improvements, they should be made across the 
board in <tt>&lt;algorithm&gt;</tt>, not to just <tt>partition_point</tt>.  
For example all 4 algorithms in 25.4.3 [alg.binary.search] have the 
same issue, and have since C++98.
<p/>
<tt>stable_partition</tt> and <tt>inplace_merge</tt> should be inspected as well.
<p/>
Perhaps a new paragraph in 25.1 [algorithms.general], similar to 
p12 would be a better place to address this issue.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2083"></a>2083. const-qualification on <tt>weak_ptr::owner_before</tt></h3>
<p><b>Section:</b> 20.7.2.3 [util.smartptr.weak], 20.7.2.3.5 [util.smartptr.weak.obs] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ai Azuma <b>Opened:</b> 2011-09-06 <b>Last modified:</b> 2011-11-24</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.weak">issues</a> in [util.smartptr.weak].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Is there any reason why <tt>weak_ptr::owner_before</tt> member function templates are not const-qualified?
</p>

<p>
Daniel Kr&uuml;gler:
</p>
<blockquote><p>
I don't think so. To the contrary, without these to be const member function templates, the
semantics of the specializations <tt>owner_less&lt;weak_ptr&lt;T&gt;&gt;</tt>  and
<tt>owner_less&lt;shared_ptr&lt;T&gt;&gt;</tt> described in 20.7.2.3.7 [util.smartptr.ownerless] 
is unclear.
<p/>
It is amusing to note that this miss has remain undetected from the accepted paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2637.pdf">n2637</a> 
on. For the suggested wording changes see below. 
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the class template <tt>weak_ptr</tt> synopsis in 20.7.2.3 [util.smartptr.weak]
as indicated:</p>
<blockquote><pre>
namespace std {
  template&lt;class T&gt; class weak_ptr {
  public:
    typedef T element_type;
    [&hellip;]
    template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) <ins>const</ins>;
    template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) <ins>const</ins>;
  };
  [&hellip;]
}
</pre></blockquote>
</li>
<li><p>Change the prototypes in 20.7.2.3.5 [util.smartptr.weak.obs] before p6 as indicated:</p>
<blockquote><pre>
template&lt;class U&gt; bool owner_before(shared_ptr&lt;U&gt; const&amp; b) <ins>const</ins>;
template&lt;class U&gt; bool owner_before(weak_ptr&lt;U&gt; const&amp; b) <ins>const</ins>;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2085"></a>2085. Wrong description of effect 1 of <tt>basic_istream::ignore</tt></h3>
<p><b>Section:</b> 27.7.2.3 [istream.unformatted] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Krzysztof Zelechowski <b>Opened:</b> 2011-09-11 <b>Last modified:</b> 2011-11-24</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
27.7.2.3 [istream.unformatted] in N3242 currently has the following to say about the
semantics of <tt>basic_istream::ignore</tt>:
</p>

<blockquote><p>
[..]. Characters are extracted until any of the following occurs:
</p>
<ul>
<li>if <tt>n != numeric_limits&lt;streamsize&gt;::max()</tt> (18.3.2), <tt>n</tt> characters are extracted
</li>
</ul>
</blockquote>

<p>
This statement, apart from being slightly ungrammatical, indicates that if
(<tt>n == numeric_limits&lt;streamsize&gt;::max()</tt>), the method returns without
extracting any characters.
<p/>
The description intends to describe the observable behaviour of an
implementation in terms of logical assertions.  Logical assertions are not
"bullets" that can be "entered" but need not; they are predicates that can
evaluate to true or false.
<p/>
The description contains two predicates, either of them causes extraction to
terminate.  In the incriminated case, the first predicate is evaluates to
true because its premise is false, therefore no characters will be
extracted.
<p/>
The intended semantics would be described by the following statement:
</p>

<blockquote><p>
[..]. Characters are extracted until any of the following occurs:
</p>
<ul>
<li><tt>(n != numeric_limits&lt;streamsize&gt;::max())</tt> (18.3.2) and (<tt>n</tt>) characters
have been extracted so far.
</li>
</ul>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 27.7.2.3 [istream.unformatted] p25 as indicated:</p>

<blockquote><pre>
basic_istream&lt;charT,traits&gt;&amp;
  ignore(streamsize n = 1, int_type delim = traits::eof());
</pre><blockquote><p>
-25- <i>Effects</i>: Behaves as an unformatted input function (as described in 27.7.2.3 [istream.unformatted], paragraph 1). After
constructing a <tt>sentry</tt> object, extracts characters and discards them. Characters are extracted until
any of the following occurs:
</p>
<ul>
<li><del>if</del> <tt>n != numeric_limits&lt;streamsize&gt;::max()</tt> (18.3.2.1 [limits.numeric])<del>,</del><ins>and</ins> 
<tt>n</tt> characters <del>are</del><ins>have been</ins> extracted <ins>so far</ins>
</li>
<li>end-of-file occurs on the input sequence (in which case the function calls <tt>setstate(eofbit)</tt>,
which may throw <tt>ios_base::failure</tt> (27.5.5.4 [iostate.flags]));
</li>
<li><tt>traits::eq_int_type(traits::to_int_type(c), delim)</tt> for the next available input character <tt>c</tt> 
(in which case <tt>c</tt> is extracted).
</li>
</ul>
</blockquote></blockquote>





<hr>
<h3><a name="2086"></a>2086. Overly generic type support for math functions</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-09-22 <b>Last modified:</b> 2011-11-26</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
26.8 [c.math] ends with a description of a rule set for "sufficient overloads"
in p11:
</p>

<blockquote>
<p>Moreover, there shall be additional overloads sufficient to ensure:</p>
<ol>
<li>
If any argument corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, then all arguments
corresponding to <tt>double</tt> parameters are effectively cast to <tt>long double</tt>.
</li>
<li>
Otherwise, if any argument corresponding to a <tt>double</tt> parameter has type <tt>double</tt> or an integer type,
then all arguments corresponding to <tt>double</tt> parameters are effectively cast to <tt>double</tt>.
</li>
<li>
Otherwise, all arguments corresponding to <tt>double</tt> parameters are effectively cast to <tt>float</tt>.
</li>
</ol>
</blockquote>

<p>
My impression is that this rule set is probably more generic as intended, my assumption is that it is written 
to mimic the C99&#47;C1x rule set in 7.25 p2+3 in the "C++" way:
</p>

<blockquote>
<p>
-2- Of the <tt>&lt;math.h&gt;</tt> and <tt>&lt;complex.h&gt;</tt> functions without an 
<tt>f</tt> (<tt>float</tt>) or <tt>l</tt> (<tt>long double</tt>) suffix, several have 
one or more parameters whose corresponding real type is <tt>double</tt>. For each such 
function, except <tt>modf</tt>, there is a corresponding type-generic macro. (footnote 313) 
The parameters whose corresponding real type is <tt>double</tt> in the function
synopsis are generic parameters. Use of the macro invokes a function whose
corresponding real type and type domain are determined by the arguments for the generic
parameters. (footnote 314)
<p/>
-3- Use of the macro invokes a function whose generic parameters have the corresponding 
real type determined as follows:
</p>
<ul>
<li>
First, if any argument for generic parameters has type <tt>long double</tt>, the type
determined is <tt>long double</tt>.
</li>
<li>
Otherwise, if any argument for generic parameters has type <tt>double</tt> or is of integer
type, the type determined is <tt>double</tt>.
</li>
<li>
Otherwise, the type determined is <tt>float</tt>.
</li>
</ul>
</blockquote>

<p>
where footnote 314 clarifies the intent:
</p>

<blockquote>
<p>
If the type of the argument is not compatible with the type of the parameter for the selected function,
the behavior is undefined.
</p>
</blockquote>

<p>
The combination of the usage of the unspecific term "cast" with otherwise no further constraints 
(note that C constraints the valid set to types that C++ describes as arithmetic types, but see below 
for one important difference) has the effect that it requires the following examples to be well-formed 
and well-defined:
</p>

<blockquote><pre>
#include &lt;cmath&gt;

enum class Ec { };

struct S { explicit operator long double(); };

void test(Ec e, S s) {
 std::sqrt(e); // OK, behaves like std::sqrt((float) e);
 std::sqrt(s); // OK, behaves like std::sqrt((float) s);
}
</pre></blockquote>
<p>
GCC 4.7 does not accept any of these examples.
<p/>
I found another example where the C++ rule differs from the C set, 
but in this case I'm not so sure, which direction C++ should follow. 
The difference is located in the fact, that in C enumerated types are 
<em>integer types</em> as described in 6.2.5 p17 (see e.g. n1569 or n1256):
<p/>
"The type char, the signed and unsigned integer types, and
the enumerated types are collectively called integer types. The
integer and real floating types are collectively called real types."
<p/>
This indicates that in C the following code
</p>
<blockquote><pre>
#include &lt;math.h&gt;

enum E { e };

void test(void) {
  sqrt(e); // OK, behaves like sqrt((double) e);
}
</pre></blockquote>
<p>
seems to be well-defined and <tt>e</tt> is cast to <tt>double</tt>, but in C++
referring to
</p>
<blockquote><pre>
#include &lt;cmath&gt;

enum E { e };

void test() {
  std::sqrt(e); // OK, behaves like sqrt((float) e);
}
</pre></blockquote>

<p>
is also well-defined (because of our lack of constraints) but we
must skip bullet 2 (because E is not an integer type) and effectively
cast <tt>e</tt> to <tt>float</tt>. Accepting this, we would introduce 
a silent, but observable runtime difference for C and C++.
<p/>
GCC 4.7 does not accept this example, but causes an ambiguity
error among the three floating point overloads of sqrt.
<p/>
My current suggestion to fix these problems would be to constrain the 
valid argument types of these functions to arithmetic types.
</p>

<blockquote><p>
Howard provided wording to solve the issue.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 26.8 [c.math] p11 as indicated:</p>

<blockquote>
<p>Moreover, there shall be additional overloads sufficient to ensure:</p>
<ol>
<li>
If any <ins>arithmetic</ins> argument corresponding to a <tt>double</tt> parameter has 
type <tt>long double</tt>, then all <ins>arithmetic</ins> arguments corresponding to 
<tt>double</tt> parameters are effectively cast to <tt>long double</tt>.
</li>
<li>
Otherwise, if any <ins>arithmetic</ins> argument corresponding to a <tt>double</tt> 
parameter has type <tt>double</tt> or an integer type, then all <ins>arithmetic</ins> 
arguments corresponding to <tt>double</tt> parameters are effectively cast to <tt>double</tt>.
</li>
<li>
Otherwise, all <ins>arithmetic</ins> arguments corresponding to <tt>double</tt> parameters 
<del>are effectively cast to</del><ins>have type</ins> <tt>float</tt>.
</li>
</ol>
</blockquote>






<hr>
<h3><a name="2087"></a>2087. <tt>iostream_category()</tt> and <tt>noexcept</tt></h3>
<p><b>Section:</b> 27.5 [iostreams.base] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-09-22 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all other</b> <a href="lwg-index.html#iostreams.base">issues</a> in [iostreams.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In <tt>&lt;system_error&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; generic_category() noexcept;
const error_category&amp; system_category() noexcept;
</pre></blockquote>

<p>
In <tt>&lt;future&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; future_category() noexcept;
</pre></blockquote>

<p>
But in <tt>&lt;ios&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; iostream_category();
</pre></blockquote>

<p>
Is there any reason that <tt>iostream_category()</tt> is not declared with 
<tt>noexcept</tt> or is this an oversight?
</p>

<p>
Daniel:
<p/>
This looks like an oversight to me. We made the above
mentioned changes as part of noexcept-ifying the thread
library but <tt>iostream_category()</tt> was skipped, so it seems
to be forgotten. There should be no reason, why it cannot
be <tt>noexcept</tt>. When doing so, we should also make these functions
<tt>noexcept</tt> (similar to corresponding overloads):
</p>
<blockquote><pre>
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
</pre></blockquote>

<p>
Suggested wording provided by Daniel.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol><li>
<p>Change 27.5.1 [iostreams.base.overview], header <tt>&lt;ios&gt;</tt> synopsis 
as indicated:
</p>
<blockquote><pre>
#include &lt;iosfwd&gt;
namespace std {
  [&hellip;]
  error_code make_error_code(io_errc e) <ins>noexcept</ins>;
  error_condition make_error_condition(io_errc e) <ins>noexcept</ins>;
  const error_category&amp; iostream_category() <ins>noexcept</ins>;
}
</pre></blockquote>

</li>
<li>
<p>Change the prototype declarations in 27.5.6.5 [error.reporting] as indicated:
</p>
<blockquote><pre>
error_code make_error_code(io_errc e) <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-1- <i>Returns</i>: <tt>error_code(static_cast&lt;int&gt;(e), iostream_category())</tt>.
</p>
</blockquote><blockquote><pre>
error_condition make_error_condition(io_errc e) <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-2- <i>Returns</i>: <tt>error_condition(static_cast&lt;int&gt;(e), iostream_category())</tt>.
</p>
</blockquote><blockquote><pre>
const error_category&amp; iostream_category() <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-3- <i>Returns</i>: A reference to an object of a type derived from class <tt>error_category</tt>.
<p/>
-4- The objects <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual functions shall behave as specified
for the class <tt>error_category</tt>. The objects <tt>name</tt> virtual function shall return a pointer to the string
<tt>"iostream"</tt>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2088"></a>2088. <tt>std::terminate</tt> problem</h3>
<p><b>Section:</b> 18.8.3 [exception.terminate] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-09-25 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Andrzej Krzemienski reported the following on comp.std.c++:
</p>
<blockquote>
<p>
In N3290, which is to become the official standard, in 18.8.3.4 [terminate],
paragraph 1 reads
</p>
<blockquote><p>
<i>Remarks</i>: Called by the implementation when exception handling must
be abandoned for any of several reasons (15.5.1), in effect immediately after 
evaluating the <em>throw-expression</em> (18.8.3.1). May also be called directly by the 
program.
</p></blockquote>
<p>It is not clear what is "in effect". It was clear in previous drafts where paragraphs 
1 and 2 read:
</p>
<blockquote><p>
Called by the implementation when exception handling must be
abandoned for any of several reasons (15.5.1). May also be called directly
by the program.
<p/>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect
immediately after evaluating the <em>throw-expression</em> (18.8.3.1), if called by the
implementation, or calls the current terminate_handler function,
if called by the program.
</p>
</blockquote>
<p>
It was changed by N3189. The same applies to function unexpected (D. 11.4, paragraph 1).
<p/>
Assuming the previous wording is still intended, the wording can be read
"unless <tt>std::terminate</tt> is called by the program, we will use the handler
that was in effect immediately after evaluating the throw-expression".
<p/>
  This assumes that there is some throw-expression connected to every
  situation that triggers the call to <tt>std::terminate</tt>. But this is not
  the case:
</p>
<ul>
<li>
  In case <tt>std::thread</tt> is assigned to or destroyed while being joinable
  there is no throw-expression involved.
</li>
<li>
  In case <tt>std::unexpected</tt> is called by the program, <tt>std::terminate</tt> is
  triggered by the implementation - no throw-expression involved.
</li>
<li>
  In case a destructor throws during stack unwinding we have two throw-expressions 
  involved.
 </li>
 </ul>
<p>
Which one is referred to?
<p/>
In case <tt>std::nested_exception::rethrow_nested</tt> is called for an object that has 
captured no exception, there is no throw-expression involved directly (and may no throw 
be involved even indirectly).
<p/>
Next, 18.8.3.1 [terminate.handler], paragraph 2 says 
</p>
<blockquote><p>
<i>Required behavior</i>: A <tt>terminate_handler</tt> shall terminate execution
of the program without returning to the caller.
</p></blockquote>
<p>
This seems to allow that the function may exit by throwing an
exception (because word "return" implies a normal return).
<p/>
One could argue that words "terminate execution of the program" are sufficient,
but then why "without returning to the caller" would be mentioned. In
case such handler throws, noexcept specification in function <tt>std::terminate</tt> 
is violated, and <tt>std::terminate</tt> would be called recursively - should 
<tt>std::abort</tt> not be called in case of recursive <tt>std::terminate</tt> 
call? On the other hand some controlled recursion could be useful, like in the 
<a href="http://cplusplus.co.il/2010/03/21/catching-uncaught-exceptions-within-terminate/">following technique</a>.
</p>
</blockquote>

<p>
The here mentioned wording changes by N3189 in regard to 18.8.3.4 [terminate] p1 
were done for a better separation of effects (Effects element) and additional normative 
wording explanations (Remarks element), there was no meaning change intended. Further,
there was already a defect existing in the previous wording, which was not updated when 
further situations where defined, when <tt>std::terminate</tt> where supposed to be 
called by the implementation. 
<p/>
The part
<p/>
"in effect immediately after evaluating the throw-expression"
<p/>
should be removed and the quoted reference to 18.8.3.1 [terminate.handler] 
need to be part of the effects element where it refers to the current <tt>terminate_handler</tt> 
function, so should be moved just after
<p/>
"Effects: Calls the current <tt>terminate_handler</tt> function."
<p/>
It seems ok to allow a termination handler to exit via an exception, but the 
suggested idiom should better be replaced by a more simpler one based on
evaluating the current exception pointer in the terminate handler, e.g.
</p>
<blockquote><pre>
void our_terminate (void) {
  std::exception_ptr p = std::current_exception();
  if (p) {
    ... // OK to rethrow and to determine it's nature
  } else {
    ... // Do something else
  }
}
</pre></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2089"></a>2089. <tt>std::allocator::construct</tt> should use uniform initialization</h3>
<p><b>Section:</b> 20.6.9.1 [allocator.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2011-10-07 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When the <tt>EmplaceConstructible</tt> requirement is used to initialize an object, 
direct initialization occurs, i.e. the argument list needs to match a constructor. 
Initializing an aggregate or using a <tt>std::initializer_list</tt> constructor with 
emplace (or other initialization by perfect forwarding) requires naming the 
initialized type and moving a temporary. This is a result of <tt>std::allocator</tt> 
not using the list initialization syntax. The body of <tt>std::allocator&lt;T&gt;::construct</tt> 
should be changed to
</p>
<blockquote><pre>
::new( ptr ) T{ std::forward&lt;Args&gt;( args ) ... };
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 20.6.9.1 [allocator.members] p12 as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</pre><blockquote>
<p>
12 <i>Effects</i>: <tt>::new((void *)p) U<del>(</del><ins>{</ins>std::forward&lt;Args&gt;(args)...<del>)</del><ins>}</ins></tt>
</p>
</blockquote></blockquote>






<hr>
<h3><a name="2090"></a>2090. Minor Overconstraint in Mutex Types</h3>
<p><b>Section:</b> 30.4.1.2 [thread.mutex.requirements.mutex] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-10-17 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;6, fourth bullet requires the 
return type of <tt>m.lock()</tt> to be <tt>void</tt>. 
<p/>
This is over-constrained. The true requirement is that the standard library 
ignores any value that the function returns. Yes, allowing non-void return 
types means that users can't store a pointer to this member function. No, 
that's not the least bit important.
<p/>
[See also the discussion following c++std-lib-31318]
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2091"></a>2091. Misplaced effect in <tt>m.try_lock_for()</tt></h3>
<p><b>Section:</b> 30.4.1.3 [thread.timedmutex.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-10-18 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.3 [thread.timedmutex.requirements]&#47;4 says, in part, 
</p><blockquote><p>
"<i>Requires</i>: If the tick period of [the argument] is not exactly 
convertible &hellip; [it] shall be rounded up &hellip;"
</p></blockquote>
<p>
This doesn't belong in the requires clause. It's an effect. It belongs in paragraph 5. 
Nitpickingly, this would be a technical change: as written it imposes an obligation on 
the caller, while moving it imposes an obligation on the callee. Although that's certainly 
not what was intended.
<p/>
Peter Dimov comments:
<p/>
Not to mention that it should round down, not up. :-)
<p/>
Incidentally, I see that the wrong <tt>try_lock</tt> requirement that the caller shall not own 
the mutex has entered the standard, after all. Oh well. Let's hope that the real world 
continues to ignore it.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2092"></a>2092. Vague Wording for <tt>condition_variable_any</tt></h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-10-20 <b>Last modified:</b> 2011-11-26</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.5.2 [thread.condition.condvarany]&#47;4 says, in part, that 
<tt>condition_variable_any()</tt> throws an exception 
"if any native handle type manipulated is not available". 
<p/>
I don't know what that means. Is this intended to say something different 
from the analogous words for <tt>condition_variable()</tt> [30.5.1 [thread.condition.condvar]&#47;4], 
"if some non-memory resource limitation prevents initialization"? If not, 
it should be worded the same way.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2093"></a>2093. Throws clause of <tt>condition_variable::wait</tt> with predicate</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2011-10-27 <b>Last modified:</b> 2011-12-05</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
the Throws: clause of <tt>condition_variable::wait&#47;wait_xxx</tt> functions that 
take a predicate argument is:
</p>
<blockquote><p>
<i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception]).
</p></blockquote>
<p>
If executing the predicate throws an exception, I would expect such exception to propagate unchanged 
to the caller, but the throws clause seems to indicate that it gets mutated into a system_error. T
hat's because of 17.5.1.4 [structure.specifications]&#47;4:
<p/>
"If Fs semantics contains a Throws:, Postconditions:, or Complexity: element, then that supersedes 
any occurrences of that element in the code sequence."
<p/>
Is my interpretation correct? Does it match the intent?
<p/>
Daniel comments:
<p/>
I don't think that this interpretation is entirely correct, the wording does not say that 
<tt>std::system_error</tt> or a derived class must be thrown, it simply is underspecified 
in this regard (The extreme interpretation is that the behaviour would be undefined, but 
that would be too far reaching I think). We have better wording for this in 
30.4.4.2 [thread.once.callonce] p4, where it says:
<p/>
"<i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception]), 
or any exception thrown by <tt>func</tt>."
<p/>
or in 30.3.2 [thread.thread.this] p6&#47;p9:
<p/>
"<i>Throws</i>: Nothing if <tt>Clock</tt> satisfies the <tt>TrivialClock</tt> requirements 
(20.11.3 [time.clock.req]) and operations of <tt>Duration</tt> do not throw exceptions. 
[ <i>Note</i>: instantiations of time point types and clocks supplied by the implementation 
as specified in 20.11.7 [time.clock] do not throw exceptions. &mdash; <i>end note</i> ]"
<p/>
So, the here discussed Throws elements should add lines along the lines of
<p/>
"Any exception thrown by operations of <tt>pred</tt>."
<p/>
and similar wording for time-related operations:
<p/>
"Any exception thrown by operations of <tt>Duration</tt>",
<p/>
"Any exception thrown by operations of <tt>chrono::duration&lt;Rep, Period&gt;</tt>"
</p>

<p><i>[2011-11-28: Ganesh comments and suggests wording]</i></p>


<p>
As for the discussion about the exception thrown by the manipulation of time-related objects, 
I believe the argument applies to all functions declared in 30 [thread]. Therefore, 
instead of adding wording to each member, I would simply move those requirements from 
30.3.2 [thread.thread.this] p6&#47;p9 to a new paragraph in 30.2.4 [thread.req.timing]. 
<p/>
As for 30.5.2 [thread.condition.condvarany], the member functions <tt>wait()</tt> and 
<tt>wait_until()</tt> are described only in terms of the Effects: clause (so strictly speaking, 
they need no changes), however, <tt>wait_for()</tt> is described with a full set of clauses 
including Throws: and Error conditions:. Either we should add those clauses to <tt>wait&#47;wait_until</tt> 
with changes similar to the one above, or remove paragraphs 29 to 34 entirely. By the way, 
even paragraph 26 could be removed IMHO.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Add a new paragraph at the end of 30.2.4 [thread.req.timing]:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-6- The resolution of timing provided by an implementation depends on both operating system and hardware.
The finest resolution provided by an implementation is called the native resolution.
<p/>
-7- Implementation-provided clocks that are used for these functions shall meet the <tt>TrivialClock</tt> 
requirements (20.11.3 [time.clock.req]).
<p/>
<ins>-?- For all functions that specify a timeout, operations on clocks, time points and time duration 
types may throw exceptions. [ <i>Note</i>: instantiations of clock, time point and duration types supplied 
by the implementation as specified in 20.11.7 [time.clock] do not throw exceptions. &mdash; 
<i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.3.2 [thread.thread.this] as indicated:</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
  void sleep_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);;
</pre><blockquote>
<p>
-4- <i>Effects</i>: Blocks the calling thread for the absolute timeout (30.2.4 [thread.req.timing]) specified by <tt>abs_time</tt>.
<p/>
-5- <i>Synchronization</i>: None.
<p/>
-6- <i>Throws</i>: <ins>timeout-related exceptions (30.2.4 [thread.req.timing]).</ins><del>Nothing if 
<tt>Clock</tt> satisfies the <tt>TrivialClock</tt> requirements (20.11.3 [time.clock.req]) and 
operations of <tt>Duration</tt> do not throw exceptions. [ <i>Note</i>: instantiations of time point types 
and clocks supplied by the implementation as specified in 20.11.7 [time.clock] do not throw 
exceptions. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period&gt;
  void sleep_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);;
</pre><blockquote>
<p>
-7- <i>Effects</i>: Blocks the calling thread for the relative timeout (30.2.4 [thread.req.timing]) specified by <tt>rel_time</tt>.
<p/>
-8- <i>Synchronization</i>: None.
<p/>
-9- <i>Throws</i>: <ins>timeout-related exceptions (30.2.4 [thread.req.timing]).</ins><del>Nothing 
if operations of <tt>chrono::duration&lt;Rep, Period&gt;</tt> do not throw exceptions. 
[ <i>Note</i>: instantiations of time point types and clocks supplied by the implementation
as specified in 20.11.7 [time.clock] do not throw exceptions. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>

</li>

<li><p>Change 30.4.1.3 [thread.timedmutex.requirements] as indicated:</p>

<p>
-3- The expression <tt>m.try_lock_for(rel_time)</tt> shall be well-formed and have the following semantics:
<p/>
[&hellip;]
<p/>
-5- <i>Effects</i>: The function attempts to obtain ownership of the mutex within the relative timeout (30.2.4 [thread.req.timing])
specified by <tt>rel_time</tt>. If the time specified by <tt>rel_time</tt> is less than or equal to <tt>rel_time.zero()</tt>, the
function attempts to obtain ownership without blocking (as if by calling <tt>try_lock()</tt>). The function
shall return within the timeout specified by <tt>rel_time</tt> only if it has obtained ownership of the mutex
object. [<i>Note</i>: As with <tt>try_lock()</tt>, there is no guarantee that ownership will be obtained if the lock
is available, but implementations are expected to make a strong effort to do so. &mdash; <i>end note</i>]
<p/>
[&hellip;]
<p/>
-8- <i>Synchronization</i>: If <tt>try_lock_for()</tt> returns <tt>true</tt>, prior <tt>unlock()</tt> operations on the same object
<i>synchronize with</i> (1.10 [intro.multithread]) this operation.
<p/>
-9- <i>Throws</i>: <ins>timeout-related exceptions (30.2.4 [thread.req.timing]).</ins><del>Nothing</del>.
<p/>
-10- The expression <tt>m.try_lock_until(abs_time)</tt> shall be well-formed and have the following semantics:
<p/>
[&hellip;]
<p/>
-12- <i>Effects</i>: The function attempts to obtain ownership of the mutex. If <tt>abs_time</tt> has already passed, the
function attempts to obtain ownership without blocking (as if by calling <tt>try_lock()</tt>). The function
shall return before the absolute timeout (30.2.4 [thread.req.timing]) specified by <tt>abs_time</tt> only 
if it has obtained ownership of the mutex object. [<i>Note</i>: As with <tt>try_lock()</tt>, there is no guarantee 
that ownership will be obtained if the lock is available, but implementations are expected to make a strong effort 
to do so. &mdash; <i>end note</i>]
<p/>
[&hellip;]
<p/>
-15- <i>Synchronization</i>: If <tt>try_lock_until()</tt> returns true, prior <tt>unlock()</tt> operations on the same object
<i>synchronize with</i> (1.10 [intro.multithread]) this operation.
<p/>
-16- <i>Throws</i>: <ins>timeout-related exceptions (30.2.4 [thread.req.timing]).</ins><del>Nothing</del>.
</p>
</li>

<li><p>Change 30.5.1 [thread.condition.condvar] as indicated:</p>

<blockquote><pre>
template &lt;class Predicate&gt;
  void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects</i>: <ins>Equivalent to:</ins>
</p>
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
<p>
[&hellip;]
<p/>
-17- <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2 [thread.req.exception])<ins>, 
timeout-related exceptions (30.2.4 [thread.req.timing]), or any exception thrown by <tt>pred</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
  cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                       const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-23- <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2 [thread.req.exception])
<ins>or timeout-related exceptions (30.2.4 [thread.req.timing])</ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-26- <i>Effects</i>: <del>as if</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2 [thread.req.exception])
<ins>or timeout-related exceptions (30.2.4 [thread.req.timing])</ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Clock, class Duration, class Predicate&gt;
  bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
                  Predicate pred);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-32- <i>Effects</i>: <ins>Equivalent to:</ins>
</p>
<blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
<p>
<del>-33- <i>Returns</i>: <tt>pred()</tt></del>
<p/>
[&hellip;]
<p/>
-36- <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2 [thread.req.exception])<ins>, 
timeout-related exceptions (30.2.4 [thread.req.timing]), or any exception thrown by <tt>pred</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep, class Period, class Predicate&gt;
  bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                Predicate pred);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-39- <i>Effects</i>: <del>as if</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></blockquote>
<p>
[&hellip;]
<p/>
<del>-42- <i>Returns</i>: <tt>pred()</tt></del>
<p/>
[&hellip;]
<p/>
-44- <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2 [thread.req.exception])<ins>, 
timeout-related exceptions (30.2.4 [thread.req.timing]), or any exception thrown by <tt>pred</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

</li>

<li><p>Change 30.5.2 [thread.condition.condvarany] as indicated:</p>

<blockquote><pre>
template &lt;class Lock, class Predicate&gt;
  void wait(Lock&amp; lock, Predicate pred);
</pre><blockquote>
<p>
-14- <i>Effects</i>: <ins>Equivalent to:</ins>
</p>
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Lock, class Clock, class Duration&gt;
  cv_status wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-18- <i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception])
<ins>or any timeout-related exceptions (30.2.4 [thread.req.timing])</ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-20- <i>Effects</i>: <del>as if</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time);
</pre></blockquote>
<p>
[&hellip;]
<p/>
-23- <i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception])
<ins>or any timeout-related exceptions (30.2.4 [thread.req.timing])</ins>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Lock, class Clock, class Duration, class Predicate&gt;
  bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred);
</pre><blockquote>
<p>
-25- <i>Effects</i>: <ins>Equivalent to:</ins>
</p>
<blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
<p>
-26- <del><i>Returns</i>: <tt>pred()</tt></del><ins>[<i>Note</i>: There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, 
even if the timeout has already expired. &mdash; <i>end note</i>]</ins>
<p/>
-27- [<i>Note</i>: The returned value indicates whether the predicate evaluates to <tt>true</tt> regardless of whether the
timeout was triggered. <i>end note</i>]
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class Lock, class Rep, class Period, class Predicate&gt;
  bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</pre><blockquote>
<p>
-28- <i>Effects</i>: <del>as if</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre>
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
</pre></blockquote>
<p>
<del>-29- [<i>Note</i>: There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, 
even if the timeout has already expired. &mdash; <i>end note</i>]</del>
<del>-30- <i>Postcondition</i>: <tt>lock</tt> is locked by the calling thread.</del>
<p/>
<del>-31- <i>Returns</i>: <tt>pred()</tt></del>
<p/>
<del>-32- [<i>Note</i>: The returned value indicates whether the predicate evaluates to <tt>true</tt> 
regardless of whether the timeout was triggered. &mdash; <i>end note</i>]</del>
<p/>
<del>-33- <i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception]).</del>
<p/>
<del>-34- <i>Error conditions</i>:</del>
</p>
<ul>
<li><del>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.</del></li>
</ul>
</blockquote></blockquote>

</li>
</ol>





<hr>
<h3><a name="2094"></a>2094. <tt>duration</tt> conversion overflow shouldn't participate in overload resolution</h3>
<p><b>Section:</b> 20.11.5.1 [time.duration.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Vicente J. Botet Escriba <b>Opened:</b> 2011-10-31 <b>Last modified:</b> 2011-11-27</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.cons">issues</a> in [time.duration.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
20.11.5.1 [time.duration.cons] says:
</p>
<blockquote><pre>
template &lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre><blockquote>
<p>
<i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>treat_as_floating_point&lt;rep&gt;::value</tt> is <tt>true</tt> or both 
<tt>ratio_divide&lt;Period2, period&gt;::den</tt> is <tt>1</tt> and <tt>treat_as_floating_point&lt;Rep2&gt;::value</tt> 
is <tt>false</tt>.
</p></blockquote></blockquote>
<p>
The evaluation of <tt>ratio_divide&lt;Period2, period&gt;::den</tt> could make 
<tt>ratio_divide&lt;Period2, period&gt;::num</tt> overflow.
<p/>
This occur for example when we try to create a millisecond (<tt>period</tt>=<tt>ratio&lt;1,1000&gt;</tt>) 
from an exa-second (<tt>Period2</tt>=<tt>ratio&lt;10<sup>18</sup>&gt;</tt>).
<p/>
<tt>ratio_divide&lt;ratio&lt;10<sup>18</sup>&gt;, ratio&lt;1,1000&gt;&gt;::num</tt> is 
<tt>10<sup>21</sup></tt> which overflows which makes the compiler error.
<p/>
If the function <tt>f</tt> is overloaded with milliseconds and seconds
</p>
<blockquote><pre>
void f(milliseconds);
void f(seconds);
</pre></blockquote>
<p>
The following fails to compile.
</p>
<blockquote><pre>
duration&lt;int,exa&gt; r(1);
f(r);
</pre></blockquote>
<p>
While the conversion to seconds work, the conversion to milliseconds make the program fail at compile time. 
In my opinion, this program should be well formed and the constructor from <tt>duration&lt;int,exa&gt;</tt> 
to milliseconds shouldn't participate in overload resolution as the result can not be represented.
<p/>
I think the wording of the standard can be improved so no misinterpretations are possible by adding that 
"no overflow is induced by the conversion".
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change the following paragraphs of 20.11.5.1 [time.duration.cons] p4 indicated:</p>

<blockquote><pre>
template &lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre><blockquote>
<p>
<i>Remarks</i>: This constructor shall not participate in overload resolution unless <ins>no 
overflow is induced in the conversion and</ins> <tt>treat_as_floating_point&lt;rep&gt;::value</tt> 
is <tt>true</tt> or both <tt>ratio_divide&lt;Period2, period&gt;::den</tt> is <tt>1</tt> and 
<tt>treat_as_floating_point&lt;Rep2&gt;::value</tt> is <tt>false</tt>. [ <i>Note</i>: This 
requirement prevents implicit truncation error when converting between integral-based duration 
types. Such a construction could easily lead to confusion about the value of the 
duration. &mdash; <i>end note</i> ]
</p></blockquote></blockquote>






<hr>
<h3><a name="2095"></a>2095. <tt>promise</tt> and <tt>packaged_task</tt> missing constructors needed for uses-allocator construction</h3>
<p><b>Section:</b> 30.6.5 [futures.promise], 30.6.9 [futures.task] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-01 <b>Last modified:</b> 2011-11-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This example is ill-formed according to C++11 because <tt>uses_allocator&lt;promise&lt;R&gt;, A&gt;::value</tt> is true, but
<tt>is_constructible&lt;promise&lt;R&gt;, A, promise&lt;R&gt;&amp;&amp;&gt;::value</tt> is false. Similarly for <tt>packaged_task</tt>.
</p>
<blockquote><pre>
#include &lt;future&gt;
#include &lt;memory&gt;
#include &lt;tuple&gt;

using namespace std;

typedef packaged_task&lt;void()&gt; task;
typedef promise&lt;void&gt; prom;
allocator&lt;task&gt; a;

tuple&lt;task, prom&gt; t1{ allocator_arg, a };
tuple&lt;task, prom&gt; t2{ allocator_arg, a, task{}, prom{} };
</pre></blockquote>
<p>
<p/>
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Add to 30.6.5 [futures.promise], class template <tt>promise</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class promise {
  public:
    promise();
    template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a);
    <ins>template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
    promise(promise&amp;&amp; rhs) noexcept;
    promise(const promise&amp; rhs) = delete;
    ~promise();	
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.5 [futures.promise] as indicated:</p>

<blockquote><pre>
promise(promise&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>promise</tt> object and transfers ownership of 
the shared state of <tt>rhs</tt> (if any) to the newly-constructed object.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>

<li><p>Add to 30.6.9 [futures.task], class template <tt>packaged_task</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>undefined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    // construction and destruction
    packaged_task() noexcept;
    template &lt;class F&gt;
    explicit packaged_task(F&amp;&amp; f);
    <ins>template &lt;class Allocator&gt;
    explicit packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;
    template &lt;class Allocator&gt;
    explicit packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;
    template&lt;class Allocator&gt;
    explicit packaged_task(allocator_arg_t, const Allocator&amp; a, const packaged_task&amp;) = delete;</ins>
    template &lt;class F, class Allocator&gt;
    explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.9.1 [futures.task.members] as indicated:</p>

<blockquote><pre>
packaged_task() noexcept;
<ins>template &lt;class Allocator&gt;
  explicit packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
</pre><blockquote>
<p>
-1- <i>Effects</i>: constructs a <tt>packaged_task</tt> object with no shared state and no stored task.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>
<p>[&hellip;]</p>
<blockquote><pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
  explicit packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>packaged_task</tt> object and transfers ownership of <tt>rhs</tt>s 
shared state to <tt>*this</tt>, leaving <tt>rhs</tt> with no shared state. Moves the stored task from <tt>rhs</tt> 
to <tt>*this</tt>.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>
</ol>

<blockquote><pre>
</pre><blockquote>
<p>
</p></blockquote></blockquote>






<hr>
<h3><a name="2097"></a>2097. <tt>packaged_task</tt> constructors should be constrained</h3>
<p><b>Section:</b> 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-02 <b>Last modified:</b> 2011-11-28</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
With the proposed resolution of <a href="lwg-active.html#2067">2067</a>, this no longer selects the
copy constructor:
</p>
<blockquote><pre>
std::packaged_task&lt;void()&gt; p1;
std::packaged_task&lt;void()&gt; p2(p1);
</pre></blockquote>
<p>
Instead this constructor is a better match:
</p>
<blockquote><pre>
template &lt;class F&gt;
 explicit packaged_task(F&amp;&amp; f);
</pre></blockquote>
<p>
This attempts to package a <tt>packaged_task</tt>, which internally tries to
copy <tt>p2</tt>, which fails because the copy constructor is deleted. For at
least one implementation the resulting error message is much less
helpful than the expected "cannot call deleted function" because it
happens after instantiating several more templates rather than in the
context where the constructor is called.
<p/>
I believe the solution is to constrain to the template constructors so
the template argument <tt>F</tt> cannot be deduced as (possibly <i>cv</i>)
<tt>packaged_task&amp;</tt> or <tt>packaged_task</tt>.  It could be argued 
this constraint is already implied because <tt>packaged_task</tt> is not 
copyable and the template constructors require that "invoking a copy of <tt>f</tt> 
shall behave the same as invoking <tt>f</tt>".
<p/>
Daniel points out that the variadic constructor of <tt>std::thread</tt>
described in 30.3.1.2 [thread.thread.constr] has a similar problem and 
suggests a similar wording change, which has been integrated below.
<p/>
An alternative is to declare <tt>thread(thread&amp;)</tt> and
<tt>packaged_task(packaged_task&amp;)</tt> as deleted.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Insert a new Remarks element to 30.3.1.2 [thread.thread.constr] around p3 as indicated:</p>

<blockquote><pre>
template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-3- <i>Requires</i>: <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall satisfy the <tt>MoveConstructible</tt> 
requirements. <tt><i>INVOKE</i>(<i>DECAY_COPY</i> ( std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i> (std::forward&lt;Args&gt;(args))...)</tt> 
(20.8.2) shall be a valid expression.
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution if <tt>decay&lt;F&gt;::type</tt> 
is the same type as <tt>std::thread</tt>.</ins>
</p>
</li>

<li><p>Insert a new Remarks element to 30.6.9.1 [futures.task.members] around p2 as indicated:</p>

<blockquote><pre>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre></blockquote>
<p>
-2- <i>Requires</i>: <tt><i>INVOKE</i>(f, t1, t2, ..., tN, R)</tt>, where <tt>t1, t2, ..., tN</tt> are values of the corresponding
types in <tt>ArgTypes...</tt>, shall be a valid expression. Invoking a copy of <tt>f</tt> shall behave the same as invoking <tt>f</tt>.
<p/>
<ins>-?- <i>Remarks</i>: These constructors shall not participate in overload resolution if <tt>decay&lt;F&gt;::type</tt> 
is the same type as <tt>std::packaged_task&lt;R(ArgTypes...)&gt;</tt>.</ins>
</p>
</li>

</ol>






<hr>
<h3><a name="2098"></a>2098. Minor Inconsistency between <tt>promise::set_value</tt> and <tt>promise::set_value_at_thread_exit</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-11-14 <b>Last modified:</b> 2011-11-28</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.6.5 [futures.promise]&#47;16 says that <tt>promise::set_value(const R&amp;)</tt> throws any exceptions 
thrown by <tt>R</tt>'s copy constructor, and that <tt>promise_set_value(R&amp;&amp;)</tt> throws any exceptions 
thrown by <tt>R</tt>'s move constructor.
<p/>
30.6.5 [futures.promise]&#47;22 is the Throws: clause for <tt>promise::set_value_at_thread_exit</tt>. It 
has no corresponding requirements, only that these functions throw "<tt>future_error</tt> if an error condition 
occurs."
<p/>
Daniel suggests wording to fix this: The approach is a bit more ambitious and also attempts to fix wording glitches
of 30.6.5 [futures.promise]&#47;16, because it would be beyond acceptable efforts of implementations to 
determine whether a constructor call of a user-defined type will indeed call a copy constructor or move constructor 
(in the first case it might be a template constructor, in the second case it might also be a copy-constructor, 
if the type has no move constructor).
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change 30.6.5 [futures.promise]&#47;16 as indicated:</p>
<blockquote><pre>
void promise::set_value(const R&amp; r);
void promise::set_value(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;void&gt;::set_value();
</pre><blockquote><p>
[&hellip;]
<p/>
-16- <i>Throws</i>:
</p>
<ul>
<li><tt>future_error</tt> if its shared state already has a stored value or exception, or</li>
<li>for the first version, any exception thrown by the <del>copy constructor 
of</del><ins>constructor selected to copy an object of</ins> <tt>R</tt>, or</li>
<li>for the second version, any exception thrown by the <del>move constructor 
of</del><ins>constructor selected to move an object of</ins> <tt>R</tt>.</li>
</ul>
</blockquote></blockquote>
</li>

<li><p>Change 30.6.5 [futures.promise]&#47;22 as indicated:</p>
<blockquote><pre>
void promise::set_value_at_thread_exit(const R&amp; r);
void promise::set_value_at_thread_exit(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value_at_thread_exit(R&amp; r);
void promise&lt;void&gt;::set_value_at_thread_exit();
</pre><blockquote><p>
[&hellip;]
<p/>
-16- <i>Throws</i>: <del><tt>future_error</tt> if an error condition occurs.</del>
</p>
<ul>
<li><ins><tt>future_error</tt> if its shared state already has a stored value or exception, or</ins></li>
<li><ins>for the first version, any exception thrown by the constructor selected to copy an object of <tt>R</tt>, or</ins></li>
<li><ins>for the second version, any exception thrown by the constructor selected to move an object of <tt>R</tt>.</ins></li>
</ul>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2099"></a>2099. Unnecessary constraints of <tt>va_start()</tt> usage</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-11-12 <b>Last modified:</b> 2011-11-28</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 18.10 [support.runtime] p3 we find (emphasis mine):
</p>
<blockquote><p>
The restrictions that ISO C places on the second parameter to the <tt>va_start()</tt> macro in header <tt>&lt;stdarg.h&gt;</tt>
are different in this International Standard. The parameter <tt>parmN</tt> is the identifier of the rightmost parameter
in the variable parameter list of the function definition (the one just before the ...).227 <em>If the parameter
<tt>parmN</tt> is <strong>declared</strong> with a <strong>function</strong>, <strong>array</strong></em>, or reference type, 
or with a type that is not compatible with the type that results when passing an argument for which there is no parameter, 
the behavior is undefined.
</p></blockquote>

<p>
It seems astonishing that the constraints on function types and array types imposes these 
on the <strong>declared</strong> parameter <tt>parmN</tt>, not to the adjusted one (which would
not require this extra wording, because that is implicit). This seems to say that a function 
definition of the form (Thanks to Johannes Schaub for this example)
</p>
<blockquote><pre>
#include &lt;stdarg.h&gt;

void f(char const paramN[], ...) {
  va_list ap;
  va_start(ap, paramN);
  va_end(ap);
}
</pre></blockquote>
<p>
would produce undefined behaviour when used.
<p/>
Similar wording exists in C99 and in the most recent C11 draft in 7.16.1.4 p4
<p/>
In my opinion the constraints in regard to array types and function types are
unnecessary and should be relaxed. Are there really implementations out in the 
wild that would (according to my understanding incorrectly) provide the declared and
not the adjusted type of <tt>paramN</tt> as deduced type to <tt>va_start()</tt>?
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 18.10 [support.runtime] p3 as indicated:</p>
<blockquote><p>
The restrictions that ISO C places on the second parameter to the <tt>va_start()</tt> macro in header <tt>&lt;stdarg.h&gt;</tt>
are different in this International Standard. The parameter <tt>parmN</tt> is the identifier of the rightmost parameter
in the variable parameter list of the function definition (the one just before the ...).227 If the parameter
<tt>parmN</tt> is <del>declared with</del><ins>of</ins> a <del>function, array, or</del> reference type, or 
<del>with</del><ins>of</ins> a type that is not compatible with the type that results when passing an argument for 
which there is no parameter, the behavior is undefined.
</p></blockquote>






<hr>
<h3><a name="2100"></a>2100. timed waiting functions cannot timeout if <tt>launch::async</tt> policy used</h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-14 <b>Last modified:</b> 2011-11-28</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.6.8 [futures.async] p5 says
</p>

<blockquote>
<p>
If the implementation chooses the <tt>launch::async</tt> policy,
</p>
<ul><li>a call to a waiting function on an asynchronous return object that shares the 
shared state created by this <tt>async</tt> call shall block until the associated thread has
completed, as if joined (30.3.1.5 [thread.thread.member]);</li>
</ul>
</blockquote>

<p>
That should say a non-timed waiting function, otherwise, calling a timed waiting function 
can block indefinitely waiting for the associated thread to complete, rather than timing 
out after the specified time.
<p/>
Since <tt>std::thread</tt> does not provide a <tt>timed_join()</tt> function (nor does
Pthreads, making it impossible on many platforms) there is no way for a timed waiting 
function to try to join but return early due to timeout, therefore timed waiting 
functions either cannot guarantee to timeout or cannot be used to meet the requirement 
to block until the thread is joined.  In order to allow timed waiting functions to
timeout the requirement should only apply to non-timed waiting functions.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 30.6.8 [futures.async] p5 as indicated:</p>

<blockquote>
<p>
If the implementation chooses the <tt>launch::async</tt> policy,
</p>
<ul><li>a call to a <ins>non-timed</ins> waiting function on an asynchronous return object 
that shares the shared state created by this <tt>async</tt> call shall block until the 
associated thread has completed, as if joined (30.3.1.5 [thread.thread.member]);</li>
</ul>
</blockquote>






<hr>
<h3><a name="2101"></a>2101. Some transformation types can produce impossible types</h3>
<p><b>Section:</b> 20.9.7 [meta.trans] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-11-18 <b>Last modified:</b> 2011-11-29</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 53 &mdash; "Reference modifications" says in regard to the type trait 
<tt>add_lvalue_reference</tt> (emphasize mine)
</p>

<blockquote>
<p>
If <tt>T</tt> names an object or <strong>function</strong> type then the member typedef type
shall name <tt>T&amp;</tt>;
</p>
</blockquote>

<p>
The problem with this specification is that function types with <i>cv</i>-qualifier or <i>ref</i>-qualifier, 
like
</p>
<blockquote><pre>
void() const
void() &amp;
</pre></blockquote>
<p>
are also affected by the first part of the rule, but this would essentially mean, that
instantiating <tt>add_lvalue_reference</tt> with such a type would attempt to form
a type that is not defined in the C++ type system, namely
</p>
<blockquote><pre>
void(&amp;)() const
void(&amp;)() &amp;
</pre></blockquote>
<p>
The general policy for <i>TransformationTrait</i>s is to define always some meaningful 
mapping type, but this does not hold for <tt>add_lvalue_reference</tt>, <tt>add_rvalue_reference</tt>,
and in addition to these two for <tt>add_pointer</tt> as well. The latter one would 
attempt to form the invalid types
</p>
<blockquote><pre>
void(*)() const
void(*)() &amp;
</pre></blockquote>
<p>
A possible reason why those traits were specified in this way is that in C++03 (and that means
for TR1), <i>cv</i>-qualifier were underspecified in the core language and several compilers
just ignored them during template instantiations. This situation became fixed by adopting
CWG issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#295">295</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#547">547</a>.
<p/>
While there is possibly some core language clarification needed (see reflector messages
starting from c++std-core-20740), it seems also clear that the library should fix the
specification. The suggested resolution follows the style of the specification of the
support concepts <tt>PointeeType</tt> and <tt>ReferentType</tt> defined in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 53 &mdash; "Reference modifications" in 20.9.7.2 [meta.trans.ref] as indicated:</p>

<table border="1">
<caption>Table 53 &mdash; Reference modifications</caption>
<tr>
<th>Template</th>
<th>Comments</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T&gt;<br/>
struct<br/>
add_lvalue_reference;</tt>
</td>
<td>
If <tt>T</tt> names an object <tt>type</tt> or <ins>if <tt>T</tt> names a</ins> function type <ins>that does not have<br/>
<i>cv</i>-qualifiers or a <i>ref</i>-qualifier</ins> then the member typedef <tt>type</tt><br/>
shall name <tt>T&amp;</tt>; otherwise, if <tt>T</tt> names a type rvalue reference to <tt>T1</tt> then<br/>
the member typedef <tt>type</tt> shall name <tt>T1&amp;</tt>; otherwise, <tt>type</tt> shall name <tt>T</tt>.
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T&gt;<br/>
struct<br/>
add_rvalue_reference;</tt>
</td>
<td>
If <tt>T</tt> names an object <tt>type</tt> or <ins>if <tt>T</tt> names a</ins> function type <ins>that does not have<br/>
<i>cv</i>-qualifiers or a <i>ref</i>-qualifier</ins> then the member typedef <tt>type</tt><br/>
shall name <tt>T&amp;&amp;</tt>; otherwise, <tt>type</tt> shall name <tt>T</tt>. [ <i>Note</i>: This rule reflects<br/>
the semantics of reference collapsing (8.3.2 [dcl.ref]). For example, when a type <tt>T</tt><br/>
names a type <tt>T1&amp;</tt>, the type <tt>add_rvalue_reference&lt;T&gt;::type</tt> is not an<br/>
rvalue reference. &mdash; <i>end note</i> ]
</td>
</tr>
</table>

</li>

<li><p>Change Table 56 &mdash; "Pointer modifications" in 20.9.7.5 [meta.trans.ptr] as indicated:</p>

<table border="1">
<caption>Table 56 &mdash; Pointer modifications</caption>
<tr>
<th>Template</th>
<th>Comments</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T&gt;<br/>
struct add_pointer;</tt>
</td>
<td>
<del>The member typedef <tt>type</tt> shall name the same type as</del><br/>
<ins>If <tt>T</tt> names a function type that has <i>cv</i>-qualifiers or a <i>ref</i>-qualifier<br/>
then the member typedef <tt>type</tt> shall name <tt>T</tt>; otherwise, it<br/> 
shall name the same type as</ins> <tt>remove_reference&lt;T&gt;::type*</tt>.
</td>
</tr>

</table>

</li>
</ol>





<hr>
<h3><a name="2103"></a>2103. <tt>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</tt></h3>
<p><b>Section:</b> 20.6.9 [default.allocator] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ai Azuma <b>Opened:</b> 2011-11-08 <b>Last modified:</b> 2011-12-04</p>
<p><b>View all other</b> <a href="lwg-index.html#default.allocator">issues</a> in [default.allocator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
&quot;<tt>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment::value</tt>&quot;
is specified as &quot;false&quot;, according to (20.6.9 [default.allocator]) and (20.6.8.1 [allocator.traits.types]).
However, according to (23.2.1 [container.requirements.general]), this specification leads to the unneeded requirements
(<tt>MoveInsertable</tt> and <tt>MoveAssignable</tt> of the value type) on the move assignment operator of containers
with the default allocator. 
<p/>
Proposed resolution:
<p/>
Either of the following two changes;  
</p>
<ol>
<li>
adding the nested typedef like
&quot;<tt>typedef std::true_type propagate_on_container_move_assignment;</tt>&quot;
in the definition of <tt>std::allocator</tt> class template,
</li>
<li>
adding the explicit partial specialization of
&quot;<tt>std::allocator_traits</tt>&quot; class template for &quot;<tt>std::allocator</tt>&quot;
class template, in which &quot;<tt>propagate_on_container_move_assignment</tt>&quot;
nested typedef is specified as &quot;<tt>std::true_type</tt>&quot;. 
</li>
</ol>
<p>
Pablo prefers the first resolution.
</p>

<p><i>[2011-12-02: Pablo comments]</i></p>


<p>
This issue has potentially some overlap with <a href="lwg-active.html#2108">2108</a>. Should the trait <tt>always_compare_equal</tt>
been added, this issue's resolution should be improved based on that.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 20.6.9 [default.allocator], the class template <tt>allocator</tt> synopsis as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class T&gt; class allocator;

  <i>// specialize for <tt>void</tt>:</i>
  template &lt;&gt; class allocator&lt;void&gt; {
  public:
    typedef void* pointer;
    typedef const void* const_pointer;
    <i>// reference-to-<tt>void</tt> members are impossible.</i>
    typedef void value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
  };

  template &lt;class T&gt; class allocator {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T&amp; reference;
    typedef const T&amp; const_reference;
    typedef T value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
    <ins>typedef true_type propagate_on_container_move_assignment;</ins>

    [&hellip;]
  };
}
</pre></blockquote>






<hr>
<h3><a name="2104"></a>2104. <tt>unique_lock</tt> move-assignment should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 30.4.2.2 [thread.lock.unique] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2011-11-27 <b>Last modified:</b> 2011-12-02</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
I just noticed that the <tt>unique_lock</tt> move-assignment operator is declared <tt>noexcept</tt>. This 
function may call <tt>unlock()</tt> on the wrapped mutex, which may throw.
<p/>
Suggested change: remove the <tt>noexcept</tt> specification from <tt>unique_lock::operator=(unique_lock&amp;&amp;)</tt> 
in 30.4.2.2 [thread.lock.unique] and 30.4.2.2.1 [thread.lock.unique.cons]. 
<p/>
Daniel:
<p/>
I think the situation is actually a bit more complex as it initially looks.
<p/>
First, the effects of the move-assignment operator are (emphasize mine):
</p>
<blockquote><p>
<i>Effects</i>: <strong>If</strong> <tt>owns</tt> calls <tt>pm->unlock()</tt>.
</p></blockquote>
<p>
Now according to the <tt>BasicLockable</tt> requirements:
</p>
<blockquote><p>
<tt>m.unlock()</tt>
<p/>
3 <i>Requires</i>: The current execution agent shall hold a lock on <tt>m</tt>.
<p/>
4 <i>Effects</i>: Releases a lock on <tt>m</tt> held by the current execution agent.
<p/>
<i>Throws</i>: Nothing.
</p></blockquote>
<p>
This shows that unlock itself is a function with narrow contract and for 
this reasons no unlock function of a mutex or lock itself does have a noexcept 
specifier according to our mental model.
<p/>
Now the move-assignment operator <strong>attempts</strong> to satisfy these
requirement of the function and calls it only when it assumes that the conditions 
are ok, so from the view-point of the caller of the move-assignment operator it 
looks as if the move-assignment operator would in total a function with a
wide contract.
<p/>
The problem with this analysis so far is, that it depends on the assumed 
correctness of the state "owns".
<p/>
Looking at the construction or state-changing functions, there do exist several 
ones that depend on caller-code satisfying the requirements and there is one 
guy, who looks most suspicious:
</p>
<blockquote><p>
<tt>unique_lock(mutex_type&amp; m, adopt_lock_t);</tt>
<p/>
11 <i>Requires</i>: The calling thread own the mutex.<br/>
[&hellip;]<br/>
13 <i>Postconditions</i>: <tt>pm == &amp;m</tt> and <tt>owns == true</tt>.<br/>
</p></blockquote>
<p>
because this function does not even call <tt>lock()</tt> (which may, but is not 
required to throw an exception if the calling thread does already own the mutex). 
So we have in fact still a move-assignment operator that might throw an exception, 
if the mutex was either constructed or used (call of lock) incorrectly.
<p/>
The correct fix seems to me to also add a "<i>Throws</i>: Nothing" element to
the move-assignment operator, because using it correctly shall now throw an
exception.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Change 30.4.2.2 [thread.lock.unique], class template <tt>unique_lock</tt> synopsis as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Mutex&gt;
  class unique_lock {
  public:
    typedef Mutex mutex_type;
    [&hellip;]
    unique_lock(unique_lock&amp;&amp; u) noexcept;
    unique_lock&amp; operator=(unique_lock&amp;&amp; u) <del>noexcept</del>;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li>
<p>Change 30.4.2.2.1 [thread.lock.unique.cons] around p22 as indicated:</p>

<blockquote><pre>
unique_lock&amp; operator=(unique_lock&amp;&amp; u) <del>noexcept</del>;
</pre><blockquote>
<p>
-22- <i>Effects</i>: If <tt>owns</tt> calls <tt>pm->unlock()</tt>.
<p/>
-23- <i>Postconditions</i>: <tt>pm == u_p.pm</tt> and <tt>owns == u_p.owns</tt> (where <tt>u_p</tt> 
is the state of <tt>u</tt> just prior to this construction), <tt>u.pm == 0</tt> and <tt>u.owns == false</tt>.
<p/>
-24- [<i>Note</i>: With a recursive mutex it is possible for both <tt>*this</tt> and <tt>u</tt> to own 
the same mutex before the assignment. In this case, <tt>*this</tt> will own the mutex after the assignment 
and <tt>u</tt> will not. &mdash; <i>end note</i>]
</p>
<ins>-??- <i>Throws</i>: Nothing.</ins>
<p/>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2105"></a>2105. Inconsistent requirements on <tt>const_iterator</tt>'s <tt>value_type</tt></h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-11-28 <b>Last modified:</b> 2011-12-02</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In the FDIS, Table 96 specifies <tt>X::const_iterator</tt> as a "constant iterator type 
whose value type is <tt>T</tt>". However, Table 97 specifies <tt>X::const_reverse_iterator</tt> 
as an "iterator type whose value type is <tt>const T</tt>" and which is defined as 
<tt>reverse_iterator&lt;const_iterator&gt;</tt>. But <tt>reverse_iterator::value_type</tt> is 
just "<tt>typename iterator_traits&lt;Iterator&gt;::value_type</tt>" 24.5.1.1 [reverse.iterator], 
so <tt>const_iterator</tt> and <tt>const_reverse_iterator</tt> must have the same <tt>value_type</tt>.
</p>
<p>
The resolution to issue <a href="lwg-defects.html#322">322</a> implies that
<tt>const_reverse_iterator</tt> should change.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change Table 97 &mdash; "Reversible container requirements" as indicated</p>

<table border="1">
<caption>Table 97 &mdash; Reversible container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>X::reverse_-<br/>
iterator</tt>
</td>
<td>
iterator type whose value type<br/>
is <tt>T</tt>
</td>
<td>
<tt>reverse_iterator&lt;iterator&gt;</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_-<br/>
reverse_-<br/>
iterator</tt>
</td>
<td>
<ins>constant</ins> iterator type whose value type<br/>
is <tt><del>const</del> T</tt>
</td>
<td>
<tt>reverse_iterator&lt;const_iterator&gt;</tt>
</td>
<td>
compile time
</td>
</tr>
</table>







<hr>
<h3><a name="2106"></a>2106. <tt>move_iterator</tt> wrapping iterators returning prvalues</h3>
<p><b>Section:</b> 24.5.3 [move.iterators] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-11-30 <b>Last modified:</b> 2011-12-03</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iterators">issues</a> in [move.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Shouldn't <tt>move_iterator</tt> be specialized so that if the iterator it wraps
returns a prvalue when dereferenced, the <tt>move_iterator</tt> also returns by
value? Otherwise, it creates a dangling reference.
<p/>
Howard: I believe just changing <tt>move_iterator&lt;I&gt;::reference</tt> would do.
A direction might be testing on <tt>is_reference&lt;iterator_traits&lt;I&gt;::reference&gt;</tt>, 
or <tt>is_reference&lt;decltype(*declval&lt;I&gt;())&gt;</tt>.
<p/>
Daniel: I would prefer to use a consistent style among the iterator adaptors, so I
suggest to keep with the <tt>iterator_traits</tt> typedefs if possible. 
</p>
<blockquote><pre>
using reference = typename conditional&lt;
  is_reference&lt;typename iterator_traits&lt;Iterator&gt;::reference&gt;::value,
  value_type&amp;&amp;,
  value_type
&gt;::type;
</pre></blockquote>
<p>
We might also want to ensure that if <tt>Iterator</tt>'s <tt>reference</tt> type <em>is</em>
a reference, the referent is equal to <tt>value_type</tt> (after removal of <i>cv</i>-qualifiers). 
In <em>general</em> we have no such guarantee.
<p/>
Marc: In the default case where we don't return <tt>value_type&amp;&amp;</tt>, should we use 
<tt>value_type</tt> or should we keep the <tt>reference</tt> type of the wrapped iterator?
<p/>
Daniel: This suggestion looks appealing at first, but the problem here is that using this typedef
can make it impossible for <tt>move_iterator</tt> to satisfy its contract, which means returning
an rvalue of the value type (Currently it says rvalue-reference, but this must be fixed as of
this issue anyway). I think that user-code can reasonably expect that when it has constructed
an object <tt>m</tt> of <tt>move_iterator&lt;It&gt;</tt>, where <tt>It</tt> is a valid 
mutable iterator type, the expression
</p>
<blockquote><pre>
<span style="color:#C80000;font-weight:bold">It::value_type&amp;&amp; rv = *m;</span>
</pre></blockquote>
<p>
is well-formed.
<p/>
Let's set <tt>R</tt> equal to <tt>iterator_traits&lt;Iterator&gt;::reference</tt>
in the following. We can discuss the following situations:
</p>
<ol><li><tt>R</tt> is a reference type: We can only return the corresponding xvalue of <tt>R</tt>,
if <tt>value_type</tt> is reference-related to the referent type, else this is presumably no
forward iterator and we cannot say much about it, except that it must be convertible to
<tt>value_type</tt>, so it better should return a prvalue.</li>
<li><tt>R</tt> is not a reference type: In this case we can rely on a conversion to
<tt>value_type</tt> again, but not much more. Assume we would return <tt>R</tt> directly,
this might turn out to have a conversion to an lvalue-reference type of the value type (for
example). If that is the case, this would indirectly violate the contract of 
<tt>move_iterator</tt>.</li>
</ol>
<p>
In regard to the first scenario I suggest that implementations are simply required to
check that <tt>V2 = remove_cv&lt;remove_reference&lt;R&gt;::type&gt;::type</tt> is equal
to the value type <tt>V1</tt> as a criterion to return this reference as an xvalue, in all other
cases it should return the value type directly as prvalue.
<p/>
The additional advantage of this strategy is, that we always ensure that <tt>reference</tt> has 
the correct <i>cv</i>-qualification, if <tt>R</tt> is a real reference.
<p/>
It is possible to improve this a bit by indeed supporting reference-related types,
this would require to test <tt>is_same&lt;V1, V2&gt;::value || is_base_of&lt;V1, V2&gt;::value</tt> 
instead. I'm unsure whether (a) this additional effort is worth it and (b) a strict reading of
the forward iterator requirements seems not to allow to return a reference-related type (Whether 
this is a defect or not is another question).
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change 24.5.3 [move.iterators] p1 as indicated:</p>

<blockquote><p>
Class template <tt>move_iterator</tt> is an iterator adaptor with the same behavior as the underlying iterator
except that its dereference operator implicitly converts the value returned by the underlying iterators
dereference operator to an rvalue <del>reference</del><ins>of the value type</ins>. Some generic algorithms 
can be called with move iterators to replace copying with moving.
</p></blockquote>
</li>

<li><p>Change 24.5.3.1 [move.iterator], class template <tt>move_iterator</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class move_iterator {
  public:
    typedef Iterator iterator_type;
    typedef typename iterator_traits&lt;Iterator&gt;::difference_type difference_type;
    typedef Iterator pointer;
    typedef typename iterator_traits&lt;Iterator&gt;::value_type value_type;
    typedef typename iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;
    typedef <del>value_type&amp;&amp;</del><ins><i>see below</i></ins> reference;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Immediately following the class template <tt>move_iterator</tt> synopsis in 
24.5.3.1 [move.iterator] insert a new paragraph as indicated:</p>

<blockquote><p>
<ins>-?- Let <tt><i>R</i></tt> be <tt>iterator_traits&lt;Iterator&gt;::reference</tt> and
let <tt><i>V</i></tt> be <tt>iterator_traits&lt;Iterator&gt;::value_type</tt>. If 
<tt>is_reference&lt;<i>R</i>&gt;::value</tt> is <tt>true</tt> and if 
<tt>remove_cv&lt;remove_reference&lt;<i>R</i>&gt;::type&gt;::type</tt> is the same type as <tt><i>V</i></tt>, 
the template instantiation <tt>move_iterator&lt;Iterator&gt;</tt> shall define the nested type 
named <tt>reference</tt> as a synonym for <tt>remove_reference&lt;<i>R</i>&gt;::type&amp;&amp;</tt>, 
otherwise as a synonym for <tt><i>V</i></tt>.</ins>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2107"></a>2107. Some iterator category should guarantee the lifetime of references</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-11-21 <b>Last modified:</b> 2011-12-03</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Many iterators guarantee that references and pointers returned from
their methods will outlive the iterator itself. Other useful iterators
can't guarantee this, leading to the rule in 24.2 [iterator.requirements] 
p9 that "Destruction of an iterator may invalidate pointers and references 
previously obtained from that iterator."
<p/>
Some algorithms can take advantage of long-lived references by
returning them, while they can adapt to short-lived references by
returning by value instead. However, there doesn't seem to be a way in
the standard to distinguish between these two types of iterators.
<p/>
The <tt>ForwardIterator</tt> requirements come close by saying "If <tt>a</tt> and <tt>b</tt> are
both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and <tt>*b</tt> are bound
to the same object." (24.2.5 [forward.iterators] p6) However, there are some
subtle ways to satisfy this rule and still return a short-lived reference, meaning 
algorithms can't be guaranteed that <tt>forward_iterator_tag</tt> will imply 
long-lived references.
<p/>
On the other hand, defect <a href="lwg-defects.html#198">198</a>, which added the invalidation wording
to iterator.requirements.general, refers to iterators with short-lived references 
being used as arguments to reverse_iterator, which requires <tt>BidirectionalIterator</tt>s. 
If <tt>ForwardIterator</tt> required long-lived references, this would be impossible.
<p/>
Either <tt>ForwardIterator</tt> should be clarified to require long-lived
references, or a new category should be added that does.
<p/>
See also the discussion around c++std-lib-31477.
<p/>
Daniel: Related to this issue is that when applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
we unintentionally lost some forward iterator requirements from C++03, where we 
had the post-conditions <tt>a == X(a)</tt> of <tt>X(a)</tt>, and <tt>u == a</tt> 
of any copy operation from <tt>a</tt> to <tt>u</tt>. This wording must be restored as well.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2108"></a>2108. No way to identify allocator types that always compare equal</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-12-01 <b>Last modified:</b> 2011-12-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Whether two allocator objects compare equal affects the complexity of
container copy and move assignments and also the possibility of an
exception being thrown by container move assignments. The latter point
means container move assignment cannot be <tt>noexcept</tt> when
<tt>propagate_on_container_move_assignment</tt> (POCMA) is false for the
allocator because there is no way to detect at compile-time if two
allocators will compare equal. LWG <a href="lwg-active.html#2013">2013</a> means this affects all
containers using <tt>std::allocator</tt>, but even if that is resolved, this
affects all stateless allocators which do not explicitly define POCMA
to <tt>true_type</tt>.
<p/>
One solution would be to add an "always_compare_equal" trait to
<tt>allocator_traits</tt>, but that would be duplicating information that is
already defined by the type's equality operator if that operator
always returns true. Requiring users to write <tt>operator==</tt> that simply
returns true and also explicitly override a trait to repeat the same
information would be unfortunate and risk user errors that allow the
trait and actual <tt>operator==</tt> to disagree.
<p/>
Dave Abrahams suggested a better solution in message c++std-lib-31532,
namely to allow <tt>operator==</tt> to return <tt>true_type</tt>, which is convertible
to <tt>bool</tt> but also detectable at compile-time. Adopting this as the
recommended way to identify allocator types that always compare equal
only requires a slight relaxation of the allocator requirements so
that <tt>operator==</tt> is not required to return <tt>bool</tt> exactly.
<p/>
The allocator requirements do not make it clear that it is well-defined 
to compare non-const values, that should be corrected too.
<p/>
In message c++std-lib-31615 Pablo Halpern suggested an <tt>always_compare_equal</tt> 
trait that could still be defined, but with a sensible default value rather 
than requiring users to override it, and using that to set sensible values for 
other allocator traits:
</p>
<blockquote><p>
Do we still need <tt>always_compare_equal</tt> if we can have an <tt>operator==</tt>
that returns <tt>true_type</tt>?  What would its default value be? <tt>is_empty&lt;A&gt;
|| is_convertible&lt;decltype(a == a), true_type&gt;::value</tt>, perhaps?  One
benefit I see to such a definition is that stateless C++03 allocators
that don't use the <tt>true_type</tt> idiom will still benefit from the new
trait.
<p/>
[&hellip;]
<p/>
One point that I want to ensure doesn't get lost is that if we adopt some sort of 
<tt>always_compare_equal</tt>-like trait, then <tt>propagate_on_container_swap</tt> 
and <tt>propagate_on_container_move_assignment</tt> should default to 
<tt>always_compare_equal</tt>. Doing this will eliminate unnecessary requirements 
on the container element type, as per [LWG <a href="lwg-active.html#2103">2103</a>].
</p></blockquote>
<p>
Optionally, <tt>operator==</tt> for <tt>std::allocator</tt> could be made to return 
<tt>true_type</tt>, however if LWG <a href="lwg-active.html#2103">2103</a> is adopted that is less important.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 27 &mdash; "Descriptive variable definitions" in 17.6.3.5 [allocator.requirements]:</p>

<table border="1">
<caption>Table 27 &mdash; Descriptive variable definitions</caption>
<tr>
<th>Variable</th>
<th>Definition</th>
</tr> 

<tr>
<td>
<tt>a3<ins>, a4</ins></tt>
</td>
<td>
<del>an rvalue of</del><ins>values of (possibly <tt>const</tt>)</ins> type <tt>X</tt>
</td>
</tr>

<tr>
<td>
<tt>b</tt>
</td>
<td>
a value of <ins>(possibly <tt>const</tt>)</ins> type <tt>Y</tt>
</td>
</tr>

</table>

</li>

<li><p>Change Table 28 &mdash; "Allocator requirements" in 17.6.3.5 [allocator.requirements]:</p>

<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr> 

<tr>
<td>
<tt><del>a1 == a2</del><ins>a3 == a4</ins></tt>
</td>
<td>
<ins>contextually converted to</ins> <tt>bool</tt>
</td>
<td>
returns true only if storage<br/>
allocated from each can be<br/>
deallocated via the other.<br/>
<tt>operator==</tt> shall be reflexive,<br/>
symmetric, and transitive, and<br/>
shall not exit via an exception.
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt><del>a1 != a2</del><ins>a3 != a4</ins></tt>
</td>
<td>
<ins>contextually converted to</ins> <tt>bool</tt>
</td>
<td>
same as <tt><del>!(a1 == a2)</del><ins>!(a3 == a4)</ins></tt>
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt>a<ins>3</ins> == b</tt>
</td>
<td>
<ins>contextually converted to</ins> <tt>bool</tt>
</td>
<td>
same as <tt>a<ins>3</ins> ==<br/>
Y::rebind&lt;T&gt;::other(b)</tt>
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt>a<ins>3</ins> != b</tt>
</td>
<td>
<ins>contextually converted to</ins> <tt>bool</tt>
</td>
<td>
same as <tt>!(a<ins>3</ins> == b)</tt>
</td>
<td>
</td>
</tr>

</table>

</li>

</ol>






<hr>
<h3><a name="2109"></a>2109. Incorrect requirements for <tt>hash</tt> specializations</h3>
<p><b>Section:</b> 19.5.5 [syserr.hash], 20.7.2.6 [util.smartptr.hash], 20.8.12 [unord.hash], 20.13.1 [type.index.synopsis], 21.6 [basic.string.hash], 23.3.7 [vector.bool], 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-12-04 <b>Last modified:</b> 2011-12-06</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
20.7.2.6 [util.smartptr.hash] p2 is specified as follows:
</p>

<blockquote><p>
<i>Requires</i>: the template specializations shall meet the requirements of class template <tt>hash</tt> (20.8.12).
</p></blockquote>

<p>
The problem here is the usage of a <i>Requires</i> element, which is actually a pre-condition
that a <em>user</em> of a component has to satisfy. But the intent of this wording is actually
to be a requirement on implementations. The <i>Requires</i> element should be removed here and
the wording should be improved to say what it was intended for.
<p/>
We have similar situations in basically all other places where the specification of library-provided
<tt>hash</tt> specializations is defined. Usually, the <i>Requires</i> element is incorrect. In the
special case of <tt>hash&lt;unique_ptr&lt;T, D&gt;&gt;</tt> the implementation depends on 
the behaviour of <tt>hash</tt> specializations, that could be user-provided. In this case
the specification needs to separate the requirements on these specializations and those
that are imposed on the implementation.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change 19.5.5 [syserr.hash] as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;system_error&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;error_code&gt;</tt>. The requirements for the members of 
this specialization are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.5.3 [bitset.hash] as indicated:</p>

<blockquote><pre>
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;bitset&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>bitset&lt;N&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.7.2.6 [util.smartptr.hash] as indicated:</p>

<blockquote><pre>
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;memory&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>unique_ptr&lt;T, D&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>. For an object <tt>p</tt> of type 
<tt>UP</tt>, where <tt>UP</tt> is <tt>unique_ptr&lt;T, D&gt;</tt>, 
<tt>hash&lt;UP&gt;()(p)</tt> shall evaluate to the same value as 
<tt>hash&lt;typename UP::pointer&gt;()(p.get())</tt>. <del>The specialization 
<tt>hash&lt;typename UP::pointer&gt;</tt> shall be well-formed.</del>
<p/>
<ins>-?- <i>Requires</i>: The specialization <tt>hash&lt;typename UP::pointer&gt;</tt> 
shall be well-formed and well-defined [<i>Note:</i> the general requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]) are implied &mdash; 
<i>end note</i>].</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;memory&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>shared_ptr&lt;T&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>. For an object <tt>p</tt> of type 
<tt>shared_ptr&lt;T&gt;</tt>, <tt>hash&lt;shared_ptr&lt;T&gt; &gt;()(p)</tt> 
shall evaluate to the same value as <tt>hash&lt;T*&gt;()(p.get())</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.8.12 [unord.hash] p2 as indicated: [<i>Comment</i>: For unknown
reasons the extended integer types are not mentioned here, which looks like an oversight to
me and makes also the wording more complicated &mdash; <i>end comment</i>]</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
[&hellip;]
template &lt;&gt; struct hash&lt;long double&gt;;
template &lt;class T&gt; struct hash&lt;T*&gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: the template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;functional&gt;</tt> provides definitions for specializations of the 
<tt>hash</tt> class template for each arithmetic type except for the extended integer
types. This header also provides a definition for a partial specialization of the 
<tt>hash</tt> class template for any pointer type. The requirements for the members 
of these specializations are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.13.4 [type.index.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;type_index&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;typeindex&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;type_index&gt;</tt>. The requirements for the members 
of this specialization are given in sub-clause 20.8.12 [unord.hash]</ins>. For 
an object <tt>index</tt> of type <tt>type_index</tt>, <tt>hash&lt;type_index&gt;()(index)</tt> 
shall evaluate to the same result as <tt>index.hash_code()</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 21.6 [basic.string.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;string&gt;</tt> provides definitions for specializations of the 
<tt>hash</tt> class template for the types <tt>string</tt>, <tt>u16string</tt>,
<tt>u32string</tt>, and <tt>wstring</tt>. The requirements for the members 
of these specializations are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 23.3.7 [vector.bool] p7 as indicated:</p>

<blockquote><pre>
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt; &gt;;
</pre><blockquote>
<p>
-7- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;vector&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>vector&lt;bool, Allocator&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 30.3.1.1 [thread.thread.id] p14 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</pre><blockquote>
<p>
-14- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;thread&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;thread::id&gt;</tt>. The requirements for the members of this 
specialization are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

</ol>






</body>
</html>
