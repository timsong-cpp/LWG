<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="2931" status="Open">
<title>Missed optimization opportunity with single-argument <tt>std::next</tt></title>
<section><sref ref="[iterator.operations]"/></section>
<submitter>Morwenn</submitter>
<date>4 Feb 2017</date>
<priority>3</priority>

<discussion>
<p>
It seems that <tt>std::next</tt> is missing an optimization opportunity when taking a single parameter. The standard 
mandates that <tt>std::next</tt> shall call <tt>std::advance</tt> on the passed iterator and return it. For random-access 
iterators, it means that <tt>operator+=</tt> will be called on the iterator. However, if a single-argument overload was 
added to <tt>std::next</tt>, it could call <tt>++it</tt> directly instead of <tt>std::advance(it, 1)</tt>, which means 
that <tt>operator++</tt> would be called instead of <tt>operator+=</tt>. This might make a small performance difference 
for complicated iterators such as <tt>std::deque</tt>'s ones, where <tt>operator++</tt> has a simpler logic than 
<tt>operator+=</tt>.
<p/>
An equivalent optimization could be allowed by adding a single-argument overload to <tt>std::prev</tt> too.
</p>

<note>2017-03-04, Kona</note>
<p>Set priority to 3. Alisdair to provide wording.</p>

<note>2018-11-30, Jonathan comments, recommending NAD</note>
<p>
Jonathan suggested NAD, because the proposed "just use increment when <tt>n==1</tt>" optimization can be done in 
<tt>std::next</tt> (and/or <tt>std::advance</tt>, and/or complicated iterators like <tt>deque::iterator</tt>) without 
adding an overload. Billy said the overload would avoid metaprogramming costs for dispatching to the right 
<tt>std::distance</tt>, and help in non-optimized builds. Zhihao said the overload would make it clear to users that 
the <tt>n==1</tt> case is optimized (Jonathan thinks this is irrelevant as there's no requirement that we tell users 
what we optimize).
</p>
</discussion>

<resolution>
<p>
</p>
</resolution>

</issue>

