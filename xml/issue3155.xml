<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3155" status="New">
<title><tt>tuple&lt;any, any&gt;{allocator_arg_t, an_allocator}</tt></title>
<section><sref ref="[tuple.cnstr]"/></section>
<submitter>Jonathan Wakely</submitter>
<date>18 Aug 2018</date>
<priority>99</priority>

<discussion>
<p>
For a 2-element <tt>std::tuple</tt>, attempting to call the "allocator-extended default constructor" might actually 
pass the <tt>allocator_arg</tt> tag and the allocator to the tuple element constructors:
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{allocator_arg, allocator&lt;int&gt;{}};
assert(std::get&lt;0&gt;(t).has_value());
</pre>
</blockquote>
<p>
This assertion should pass according to the standard, but users might expect the elements to be default constructed. 
If you really wanted to construct the elements with the tag and the allocator, you could do:
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{{allocator_arg}, {allocator&lt;int&gt;{}}};
</pre>
</blockquote>
<p>
or
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{tuple&lt;allocator_arg_t, allocator&lt;int&gt;&gt;{allocator_arg, allocator&lt;int&gt;{}}};
</pre>
</blockquote>
<p>
The deduction guides for <tt>std::tuple</tt> always treat <tt>{allocator_arg_t, <i>an_allocator</i>}</tt> as the 
allocator-extended default constructor, so this creates an empty tuple:
</p>
<blockquote>
<pre>
tuple t{allocator_arg, allocator&lt;int&gt;{}};
</pre>
</blockquote>
<p>
And this is needed to create <tt>tuple&lt;any, any&gt;</tt>:
</p>
<blockquote>
<pre>
tuple t{allocator_arg, allocator&lt;int&gt;{}, any{}, any{}};
</pre>
</blockquote>
<p>
The proposed resolution seems consistent with that, always calling an allocator-extended constructor for 
<tt>{allocator_arg_t, <i>a</i>}</tt>, instead of the <tt>tuple(UTypes&amp;&amp;...)</tt> constructor.
<p/>
Ville Voutilainen:
<p/>
This was discussed in <a href="http://lists.isocpp.org/lib-ext/2016/10/3154.php">this reflector thread</a>, 
where Andrzej convinced me to change libstdc++ tuple.
</p>
</discussion>

<resolution>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify <sref ref="[tuple.cnstr]"/> as indicated:</p>
<blockquote>
<pre>
template&lt;class... UTypes&gt; explicit(<i>see below</i>) constexpr tuple(UTypes&amp;&amp;... u);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Initializes the elements in the tuple with the corresponding value in 
<tt>std::forward&lt;UTypes&gt;(u)</tt>.
<p/>
-10- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>sizeof...(Types) == sizeof...(UTypes)</tt> and <tt>sizeof...(Types) &gt;= 1</tt> and 
<tt>is_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> 
for all <tt><i>i</i></tt> <ins>and <tt>(sizeof...(Types) != 2 || !is_same_v&lt;remove_cvref_t&lt;U<sub>0</sub>&gt;, 
allocator_arg_t&gt;)</tt></ins>. The expression inside <tt>explicit</tt> is equivalent to:
<p/>
<tt>!conjunction_v&lt;is_convertible&lt;UTypes, Types&gt;...&gt;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ul>
</resolution>

</issue>
