<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3795" status="New">
<title>Self-move-assignment of <tt>std::future</tt> and <tt>std::shared_future</tt> have unimplementable postconditions</title>
<section><sref ref="[futures.unique.future]"/><sref ref="[futures.shared.future]"/></section>
<submitter>Jiang An</submitter>
<date>19 Oct 2022</date>
<priority>99</priority>

<discussion>
<p>
The move assignment operators of <tt>std::future</tt> and <tt>std::shared_future</tt> have their postconditions specified as below:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Postconditions</i>:
</p>
<ul>
<li><p><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> returned prior to the assignment.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>        
</blockquote>
<p>
It can be found that when <tt>*this</tt> and <tt>rhs</tt> is the same object and <tt>this-&gt;valid()</tt> 
is <tt>true</tt> before the assignment, the postconditions can't be achieved.
<p/>
Mainstream implementations (libc++, libstdc++, msvc stl) currently implement such self-move-assignment as no-op, 
which doesn't meet the requirements in the <i>Effects:</i> element. As discussed in LWG <iref ref="3788"/>, I think 
we should say self-move-assignment has no effects for these types.
</p>
</discussion>

<resolution>
</resolution>

</issue>
